From e9bb108a4957dce100454537e7a8f11562efee02 Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Mon, 8 Jan 2024 17:08:23 -0600
Subject: [PATCH] merge: ksmbd: https://github.com/cifsd-team/ksmbd

https://github.com/cifsd-team/ksmbd/commit/0590dfae7a6e0a50eda6584286b2c6215aaddea1
Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 fs/ksmbd/Kconfig             |   13 +-
 fs/ksmbd/Makefile            |   65 +-
 fs/ksmbd/README.md           |  170 +
 fs/ksmbd/asn1.c              |  169 +-
 fs/ksmbd/auth.c              |  355 +-
 fs/ksmbd/auth.h              |   16 +-
 fs/ksmbd/build_ksmbd.sh      |  177 +
 fs/ksmbd/compat.c            |  149 +
 fs/ksmbd/compat.h            |   26 +
 fs/ksmbd/connection.c        |  142 +-
 fs/ksmbd/connection.h        |    3 +-
 fs/ksmbd/crypto_ctx.c        |   16 +
 fs/ksmbd/crypto_ctx.h        |    8 +
 fs/ksmbd/dkms.conf           |    6 +
 fs/ksmbd/glob.h              |   11 +-
 fs/ksmbd/ksmbd.rst           |  183 +
 fs/ksmbd/ksmbd_netlink.h     |    5 +-
 fs/ksmbd/ksmbd_work.c        |  101 +
 fs/ksmbd/ksmbd_work.h        |   45 +-
 fs/ksmbd/mgmt/ksmbd_ida.c    |   17 +-
 fs/ksmbd/mgmt/ksmbd_ida.h    |    6 +
 fs/ksmbd/mgmt/share_config.h |   29 +-
 fs/ksmbd/mgmt/tree_connect.c |   53 +-
 fs/ksmbd/mgmt/tree_connect.h |   14 +-
 fs/ksmbd/mgmt/user_config.h  |    1 -
 fs/ksmbd/mgmt/user_session.c |  104 +-
 fs/ksmbd/mgmt/user_session.h |    9 +-
 fs/ksmbd/misc.c              |  107 +
 fs/ksmbd/ndr.c               |   36 +-
 fs/ksmbd/ndr.h               |    4 +
 fs/ksmbd/netmisc.c           |  606 +++
 fs/ksmbd/ntlmssp.h           |    6 +-
 fs/ksmbd/oplock.c            |  569 ++-
 fs/ksmbd/oplock.h            |   21 +-
 fs/ksmbd/server.c            |   77 +-
 fs/ksmbd/smb1misc.c          |  298 ++
 fs/ksmbd/smb1ops.c           |   91 +
 fs/ksmbd/smb1pdu.c           | 8881 ++++++++++++++++++++++++++++++++++
 fs/ksmbd/smb1pdu.h           | 1651 +++++++
 fs/ksmbd/smb2misc.c          |   47 +-
 fs/ksmbd/smb2ops.c           |   78 +-
 fs/ksmbd/smb2pdu.c           | 1947 +++++---
 fs/ksmbd/smb2pdu.h           | 1202 ++++-
 fs/ksmbd/smb_common.c        |  125 +-
 fs/ksmbd/smb_common.h        |   77 +-
 fs/ksmbd/smbacl.c            |  258 +-
 fs/ksmbd/smbacl.h            |   71 +-
 fs/ksmbd/smberr.h            |  235 +
 fs/ksmbd/transport_ipc.c     |    7 +-
 fs/ksmbd/transport_rdma.c    |  111 +-
 fs/ksmbd/transport_tcp.c     |   46 +-
 fs/ksmbd/unicode.c           |  181 +-
 fs/ksmbd/unicode.h           |    3 +
 fs/ksmbd/vfs.c               | 2235 +++++++--
 fs/ksmbd/vfs.h               |  203 +-
 fs/ksmbd/vfs_cache.c         |  138 +-
 fs/ksmbd/vfs_cache.h         |   36 +-
 fs/ksmbd/xattr.h             |    2 +-
 58 files changed, 19685 insertions(+), 1557 deletions(-)
 create mode 100644 fs/ksmbd/README.md
 create mode 100755 fs/ksmbd/build_ksmbd.sh
 create mode 100644 fs/ksmbd/compat.c
 create mode 100644 fs/ksmbd/compat.h
 create mode 100644 fs/ksmbd/dkms.conf
 create mode 100644 fs/ksmbd/ksmbd.rst
 create mode 100644 fs/ksmbd/netmisc.c
 create mode 100644 fs/ksmbd/smb1misc.c
 create mode 100644 fs/ksmbd/smb1ops.c
 create mode 100644 fs/ksmbd/smb1pdu.c
 create mode 100644 fs/ksmbd/smb1pdu.h
 create mode 100644 fs/ksmbd/smberr.h

diff --git a/fs/ksmbd/Kconfig b/fs/ksmbd/Kconfig
index e1fe17747ed6..8514bbb385d7 100644
--- a/fs/ksmbd/Kconfig
+++ b/fs/ksmbd/Kconfig
@@ -1,11 +1,12 @@
 config SMB_SERVER
-	tristate "SMB3 server support (EXPERIMENTAL)"
+	tristate "SMB3 server support"
 	depends on INET
 	depends on MULTIUSER
 	depends on FILE_LOCKING
 	select NLS
 	select NLS_UTF8
 	select CRYPTO
+	select CRYPTO_MD4
 	select CRYPTO_MD5
 	select CRYPTO_HMAC
 	select CRYPTO_ECB
@@ -42,6 +43,16 @@ config SMB_SERVER
 	  smb3 encryption, copy-offload, secure per-user session
 	  establishment via NTLM or NTLMv2.
 
+config SMB_INSECURE_SERVER
+        bool "Support for insecure SMB1/CIFS and SMB2.0 protocols"
+        depends on SMB_SERVER && INET
+        select NLS
+	default n
+
+        help
+	  This enables deprecated insecure protocols dialects: SMB1/CIFS
+	  and SMB2.0
+
 config SMB_SERVER_SMBDIRECT
 	bool "Support for SMB Direct protocol"
 	depends on SMB_SERVER=m && INFINIBAND && INFINIBAND_ADDR_TRANS || SMB_SERVER=y && INFINIBAND=y && INFINIBAND_ADDR_TRANS=y
diff --git a/fs/ksmbd/Makefile b/fs/ksmbd/Makefile
index 7d6337a7dee4..84099c782504 100644
--- a/fs/ksmbd/Makefile
+++ b/fs/ksmbd/Makefile
@@ -2,19 +2,74 @@
 #
 # Makefile for Linux SMB3 kernel server
 #
+ifneq ($(KERNELRELEASE),)
+# For kernel build
+
+# CONFIG_SMB_SERVER_SMBDIRECT is supported in the kernel above 4.12 version.
+SMBDIRECT_SUPPORTED = $(shell [ $(VERSION) -gt 4 -o \( $(VERSION) -eq 4 -a \
+		      $(PATCHLEVEL) -gt 12 \) ] && echo y)
+
+ifeq "$(CONFIG_SMB_SERVER_SMBDIRECT)" "y"
+ifneq "$(call SMBDIRECT_SUPPORTED)" "y"
+$(error CONFIG_SMB_SERVER_SMBDIRECT is supported in the kernel above 4.12 version)
+endif
+endif
+
 obj-$(CONFIG_SMB_SERVER) += ksmbd.o
 
-ksmbd-y :=	unicode.o auth.o vfs.o vfs_cache.o server.o ndr.o \
-		misc.o oplock.o connection.o ksmbd_work.o crypto_ctx.o \
+ksmbd-y :=	unicode.o auth.o vfs.o vfs_cache.o connection.o crypto_ctx.o \
+		server.o misc.o oplock.o ksmbd_work.o smbacl.o ndr.o\
 		mgmt/ksmbd_ida.o mgmt/user_config.o mgmt/share_config.o \
 		mgmt/tree_connect.o mgmt/user_session.o smb_common.o \
-		transport_tcp.o transport_ipc.o smbacl.o smb2pdu.o \
-		smb2ops.o smb2misc.o ksmbd_spnego_negtokeninit.asn1.o \
-		ksmbd_spnego_negtokentarg.asn1.o asn1.o
+		transport_tcp.o transport_ipc.o
+
+ksmbd-y +=	smb2pdu.o smb2ops.o smb2misc.o ksmbd_spnego_negtokeninit.asn1.o \
+		ksmbd_spnego_negtokentarg.asn1.o asn1.o compat.o
 
 $(obj)/asn1.o: $(obj)/ksmbd_spnego_negtokeninit.asn1.h $(obj)/ksmbd_spnego_negtokentarg.asn1.h
 
 $(obj)/ksmbd_spnego_negtokeninit.asn1.o: $(obj)/ksmbd_spnego_negtokeninit.asn1.c $(obj)/ksmbd_spnego_negtokeninit.asn1.h
 $(obj)/ksmbd_spnego_negtokentarg.asn1.o: $(obj)/ksmbd_spnego_negtokentarg.asn1.c $(obj)/ksmbd_spnego_negtokentarg.asn1.h
 
+ksmbd-$(CONFIG_SMB_INSECURE_SERVER) += smb1pdu.o smb1ops.o smb1misc.o netmisc.o
 ksmbd-$(CONFIG_SMB_SERVER_SMBDIRECT) += transport_rdma.o
+else
+# For external module build
+EXTRA_FLAGS += -I$(PWD)
+KDIR	?= /lib/modules/$(shell uname -r)/build
+MDIR	?= /lib/modules/$(shell uname -r)
+PWD	:= $(shell pwd)
+PWD	:= $(shell pwd)
+
+export CONFIG_SMB_SERVER := m
+
+all:
+	$(MAKE) -C $(KDIR) M=$(PWD) modules
+
+clean:
+	$(MAKE) -C $(KDIR) M=$(PWD) clean
+
+install: ksmbd.ko
+	rm -f ${MDIR}/kernel/fs/ksmbd/ksmbd.ko
+	install -m644 -b -D ksmbd.ko ${MDIR}/kernel/fs/ksmbd/ksmbd.ko
+	depmod -a
+
+# install dkms
+PKGVER=$(shell echo `git rev-parse --short HEAD`)
+dkms-install:
+	sudo rm -rf "/usr/src/ksmbd*"
+	sudo cp -r "$(PWD)" "/usr/src/ksmbd-$(PKGVER)"
+	sudo sed -e "s/@VERSION@/$(PKGVER)/" -i "/usr/src/ksmbd-$(PKGVER)/dkms.conf"
+	sudo dkms install -m ksmbd/$(PKGVER) --force
+
+dkms-uninstall:
+	sudo modprobe -r ksmbd
+	sudo dkms remove ksmbd/$(PKGVER)
+	sudo rm -rf "/usr/src/ksmbd-$(PKGVER)"
+
+uninstall:
+	rm -rf ${MDIR}/kernel/fs/ksmbd
+	depmod -a
+endif
+
+.PHONY : all clean install uninstall
diff --git a/fs/ksmbd/README.md b/fs/ksmbd/README.md
new file mode 100644
index 000000000000..2726cefe4e47
--- /dev/null
+++ b/fs/ksmbd/README.md
@@ -0,0 +1,170 @@
+
+# Content
+
+- [What is KSMBD?](#KSMBDwhat-is-ksmbd)
+- [Under PFIF](#under-pfif)
+- [Git](#git)
+- [Maintainers](#maintainers)
+- [Bug reports or contribution](#Bug-reports-or-contribution)
+- [Features](#features)
+- [Supported Linux Kernel Versions](#supported-linux-kernel-versions)
+- [KSMBD architecture](#ksmbd-architecture)
+
+
+## What is KSMBD?
+
+KSMBD is an opensource In-kernel CIFS/SMB3 server created by Namjae Jeon for Linux Kernel. It's an implementation of SMB/CIFS protocol in kernel space for sharing files and IPC services over network. Initially the target is to provide improved file I/O performances, but the bigger goal is to have some new features which are much easier to develop and maintain inside the kernel and expose the layers fully. Directions can be attributed to sections where SAMBA is moving to few modules inside the kernel to have features like RDMA(Remote direct memory access) to work with actual performance gain.
+
+
+## Under PFIF
+
+This code was developed in participation with the Protocol Freedom Information Foundation.
+
+Please see
+* http://samba.org/samba/PFIF/
+for more details.
+
+
+## Git
+
+The development git tree is available at
+* https://github.com/cifsd-team/ksmbd
+* https://github.com/cifsd-team/ksmbd-tools
+
+
+## Maintainers
+
+* Namjae Jeon <linkinjeon@kernel.org>
+
+
+## Bug reports or contribution
+
+For reporting bugs and sending patches, please send the patches to the following mail address:
+
+* linkinjeon@kernel.org
+
+or open issues/send PRs to [KSMBD](https://github.com/cifsd-team/ksmbd).
+
+## Installing as a stand-alone module
+
+Install prerequisite package for Fedora, RHEL:
+```
+	yum install kernel-devel-$(uname -r)
+```
+
+Build step:
+```
+	make
+	sudo make install
+```
+
+To load the driver manually, run this as root:
+```
+	modprobe ksmbd
+```
+
+
+## Installing as a part of the kernel
+
+1. Let's take [linux] as the path to your kernel source dir.
+```
+	cd [linux]
+	cp -ar ksmbd [linux]/fs/
+```
+
+2. edit [linux]/fs/Kconfig
+```
+	source "fs/cifs/Kconfig"
+	+source "fs/ksmbd/Kconfig"
+	source "fs/coda/Kconfig"
+```
+
+3. edit [linux]/fs/Makefile
+```
+	obj-$(CONFIG_CIFS)              += cifs/
+	+obj-$(CONFIG_SMB_SERVER)       += ksmbd/
+	obj-$(CONFIG_HPFS_FS)           += hpfs/
+```
+4. make menuconfig and set ksmbd
+```
+	[*] Network File Systems  --->
+		<M>   SMB server support
+```
+
+build your kernel
+
+
+## Features
+
+*Implemented*
+1. SMB1(CIFS), SMB2/3 protocols for basic file sharing
+2. Dynamic crediting
+3. Compound requests
+4. oplock/lease
+5. Large MTU
+6. NTLM/NTLMv2
+7. Auto negotiation
+8. HMAC-SHA256 Signing
+9. Secure negotiate
+10. Signing Update
+11. Pre-authentication integrity(SMB 3.1.1)
+12. SMB3 encryption(CCM, GCM)
+13. SMB direct(RDMA)
+14. Win-ACL
+15. Kerberos
+16. Multi-channel
+
+*Planned*
+1. Durable handle v1/v2
+2. Persistent handles
+3. Directory lease
+
+
+## Supported Linux Kernel Versions
+
+* Linux Kernel 5.4 or later
+
+
+## KSMBD architecture
+
+```
+               |--- ...
+       --------|--- ksmbd/3 - Client 3
+       |-------|--- ksmbd/2 - Client 2
+       |       |         _____________________________________________________
+       |       |        |- Client 1                                           |
+<--- Socket ---|--- ksmbd/1   <<= Authentication : NTLM/NTLM2, Kerberos(TODO)|
+       |       |      | |      <<= SMB : SMB1, SMB2, SMB2.1, SMB3, SMB3.0.2,  |
+       |       |      | |                SMB3.1.1                             |
+       |       |      | |_____________________________________________________|
+       |       |      |
+       |       |      |--- VFS --- Local Filesystem
+       |       |
+KERNEL |--- ksmbd/0(forker kthread)
+---------------||---------------------------------------------------------------
+USER           ||
+               || communication using NETLINK
+               ||  ______________________________________________
+               || |                                              |
+        ksmbd.mountd <<= DCE/RPC, WINREG                         |
+               ^  |  <<= configure shares setting, user accounts |
+               |  |______________________________________________|
+               |
+               |------ smb.conf(config file)
+               |
+               |------ ksmbdpwd.db(user account/password file)
+                            ^
+  ksmbd.adduser ---------------|
+
+```
+
+## Performance
+
+1. ksmbd vs samba performance comparison using iozone (Linux Client)
+<br/><br/><img src="https://github.com/cifsd-team/cifsd-perf/blob/master/4k_read-write_performance.PNG"  width="850" height="450">
+
+2. ksmbd vs samba performance comparison using fileop (Linux Client)
+<br/><br/><img src="https://github.com/cifsd-team/cifsd-perf/blob/master/Fileop_throughput_Performance.PNG"  width="850" height="450">
+
+3. ksmbd vs samba performance comparison using CrystalDiskMark (Windows Client)
+<br/><br/>![CrystalDiskMark](https://github.com/cifsd-team/cifsd-perf/blob/master/CrystalDiskMark_Performance.JPG)
diff --git a/fs/ksmbd/asn1.c b/fs/ksmbd/asn1.c
index c03eba090368..a82739dc92b3 100644
--- a/fs/ksmbd/asn1.c
+++ b/fs/ksmbd/asn1.c
@@ -21,11 +21,101 @@
 #include "ksmbd_spnego_negtokeninit.asn1.h"
 #include "ksmbd_spnego_negtokentarg.asn1.h"
 
+#define SPNEGO_OID_LEN 7
 #define NTLMSSP_OID_LEN  10
+#define KRB5_OID_LEN  7
+#define KRB5U2U_OID_LEN  8
+#define MSKRB5_OID_LEN  7
+static unsigned long SPNEGO_OID[7] = { 1, 3, 6, 1, 5, 5, 2 };
+static unsigned long NTLMSSP_OID[10] = { 1, 3, 6, 1, 4, 1, 311, 2, 2, 10 };
+static unsigned long KRB5_OID[7] = { 1, 2, 840, 113554, 1, 2, 2 };
+static unsigned long KRB5U2U_OID[8] = { 1, 2, 840, 113554, 1, 2, 2, 3 };
+static unsigned long MSKRB5_OID[7] = { 1, 2, 840, 48018, 1, 2, 2 };
 
 static char NTLMSSP_OID_STR[NTLMSSP_OID_LEN] = { 0x2b, 0x06, 0x01, 0x04, 0x01,
 	0x82, 0x37, 0x02, 0x02, 0x0a };
 
+static bool
+asn1_subid_decode(const unsigned char **begin, const unsigned char *end,
+		  unsigned long *subid)
+{
+	const unsigned char *ptr = *begin;
+	unsigned char ch;
+
+	*subid = 0;
+
+	do {
+		if (ptr >= end)
+			return false;
+
+		ch = *ptr++;
+		*subid <<= 7;
+		*subid |= ch & 0x7F;
+	} while ((ch & 0x80) == 0x80);
+
+	*begin = ptr;
+	return true;
+}
+
+static bool asn1_oid_decode(const unsigned char *value, size_t vlen,
+			    unsigned long **oid, size_t *oidlen)
+{
+	const unsigned char *iptr = value, *end = value + vlen;
+	unsigned long *optr;
+	unsigned long subid;
+
+	vlen += 1;
+	if (vlen < 2 || vlen > UINT_MAX / sizeof(unsigned long))
+		goto fail_nullify;
+
+	*oid = kmalloc(vlen * sizeof(unsigned long), GFP_KERNEL);
+	if (!*oid)
+		return false;
+
+	optr = *oid;
+
+	if (!asn1_subid_decode(&iptr, end, &subid))
+		goto fail;
+
+	if (subid < 40) {
+		optr[0] = 0;
+		optr[1] = subid;
+	} else if (subid < 80) {
+		optr[0] = 1;
+		optr[1] = subid - 40;
+	} else {
+		optr[0] = 2;
+		optr[1] = subid - 80;
+	}
+
+	*oidlen = 2;
+	optr += 2;
+
+	while (iptr < end) {
+		if (++(*oidlen) > vlen)
+			goto fail;
+
+		if (!asn1_subid_decode(&iptr, end, optr++))
+			goto fail;
+	}
+	return true;
+
+fail:
+	kfree(*oid);
+fail_nullify:
+	*oid = NULL;
+	return false;
+}
+
+static bool oid_eq(unsigned long *oid1, unsigned int oid1len,
+		   unsigned long *oid2, unsigned int oid2len)
+{
+	if (oid1len != oid2len)
+		return false;
+
+	return memcmp(oid1, oid2, oid1len) == 0;
+}
+
 int
 ksmbd_decode_negTokenInit(unsigned char *security_blob, int length,
 			  struct ksmbd_conn *conn)
@@ -162,18 +252,26 @@ int build_spnego_ntlmssp_auth_blob(unsigned char **pbuffer, u16 *buflen,
 int ksmbd_gssapi_this_mech(void *context, size_t hdrlen, unsigned char tag,
 			   const void *value, size_t vlen)
 {
-	enum OID oid;
+	unsigned long *oid;
+	size_t oidlen;
+	int err = 0;
+
+	if (!asn1_oid_decode(value, vlen, &oid, &oidlen)) {
+		err = -EBADMSG;
+		goto out;
+	}
 
-	oid = look_up_OID(value, vlen);
-	if (oid != OID_spnego) {
+	if (!oid_eq(oid, oidlen, SPNEGO_OID, SPNEGO_OID_LEN))
+		err = -EBADMSG;
+	kfree(oid);
+out:
+	if (err) {
 		char buf[50];
 
 		sprint_oid(value, vlen, buf, sizeof(buf));
 		ksmbd_debug(AUTH, "Unexpected OID: %s\n", buf);
-		return -EBADMSG;
 	}
-
-	return 0;
+	return err;
 }
 
 int ksmbd_neg_token_init_mech_type(void *context, size_t hdrlen,
@@ -181,59 +279,62 @@ int ksmbd_neg_token_init_mech_type(void *context, size_t hdrlen,
 				   size_t vlen)
 {
 	struct ksmbd_conn *conn = context;
-	enum OID oid;
+	unsigned long *oid;
+	size_t oidlen;
 	int mech_type;
+	char buf[50];
+
+	if (!asn1_oid_decode(value, vlen, &oid, &oidlen))
+		goto fail;
 
-	oid = look_up_OID(value, vlen);
-	if (oid == OID_ntlmssp) {
+	if (oid_eq(oid, oidlen, NTLMSSP_OID, NTLMSSP_OID_LEN))
 		mech_type = KSMBD_AUTH_NTLMSSP;
-	} else if (oid == OID_mskrb5) {
+	else if (oid_eq(oid, oidlen, MSKRB5_OID, MSKRB5_OID_LEN))
 		mech_type = KSMBD_AUTH_MSKRB5;
-	} else if (oid == OID_krb5) {
+	else if (oid_eq(oid, oidlen, KRB5_OID, KRB5_OID_LEN))
 		mech_type = KSMBD_AUTH_KRB5;
-	} else if (oid == OID_krb5u2u) {
+	else if (oid_eq(oid, oidlen, KRB5U2U_OID, KRB5U2U_OID_LEN))
 		mech_type = KSMBD_AUTH_KRB5U2U;
-	} else {
-		char buf[50];
-
-		sprint_oid(value, vlen, buf, sizeof(buf));
-		ksmbd_debug(AUTH, "Unexpected OID: %s\n", buf);
-		return -EBADMSG;
-	}
+	else
+		goto fail;
 
 	conn->auth_mechs |= mech_type;
 	if (conn->preferred_auth_mech == 0)
 		conn->preferred_auth_mech = mech_type;
 
+	kfree(oid);
 	return 0;
+
+fail:
+	kfree(oid);
+	sprint_oid(value, vlen, buf, sizeof(buf));
+	ksmbd_debug(AUTH, "Unexpected OID: %s\n", buf);
+	return -EBADMSG;
 }
 
-int ksmbd_neg_token_init_mech_token(void *context, size_t hdrlen,
-				    unsigned char tag, const void *value,
-				    size_t vlen)
+static int ksmbd_neg_token_alloc(void *context, size_t hdrlen,
+				 unsigned char tag, const void *value,
+				 size_t vlen)
 {
 	struct ksmbd_conn *conn = context;
 
-	conn->mechToken = kmalloc(vlen + 1, GFP_KERNEL);
+	conn->mechToken = kmemdup_nul(value, vlen, GFP_KERNEL);
 	if (!conn->mechToken)
 		return -ENOMEM;
 
-	memcpy(conn->mechToken, value, vlen);
-	conn->mechToken[vlen] = '\0';
 	return 0;
 }
 
-int ksmbd_neg_token_targ_resp_token(void *context, size_t hdrlen,
+int ksmbd_neg_token_init_mech_token(void *context, size_t hdrlen,
 				    unsigned char tag, const void *value,
 				    size_t vlen)
 {
-	struct ksmbd_conn *conn = context;
-
-	conn->mechToken = kmalloc(vlen + 1, GFP_KERNEL);
-	if (!conn->mechToken)
-		return -ENOMEM;
+	return ksmbd_neg_token_alloc(context, hdrlen, tag, value, vlen);
+}
 
-	memcpy(conn->mechToken, value, vlen);
-	conn->mechToken[vlen] = '\0';
-	return 0;
+int ksmbd_neg_token_targ_resp_token(void *context, size_t hdrlen,
+				    unsigned char tag, const void *value,
+				    size_t vlen)
+{
+	return ksmbd_neg_token_alloc(context, hdrlen, tag, value, vlen);
 }
diff --git a/fs/ksmbd/auth.c b/fs/ksmbd/auth.c
index df8fb076f6f1..c6c3d69c208a 100644
--- a/fs/ksmbd/auth.c
+++ b/fs/ksmbd/auth.c
@@ -29,7 +29,6 @@
 #include "mgmt/user_config.h"
 #include "crypto_ctx.h"
 #include "transport_ipc.h"
-#include "../smbfs_common/arc4.h"
 
 /*
  * Fixed format data defining GSS header and fixed string
@@ -69,6 +68,127 @@ void ksmbd_copy_gss_neg_header(void *buf)
 	memcpy(buf, NEGOTIATE_GSS_HEADER, AUTH_GSS_LENGTH);
 }
 
+static void
+str_to_key(unsigned char *str, unsigned char *key)
+{
+	int i;
+
+	key[0] = str[0] >> 1;
+	key[1] = ((str[0] & 0x01) << 6) | (str[1] >> 2);
+	key[2] = ((str[1] & 0x03) << 5) | (str[2] >> 3);
+	key[3] = ((str[2] & 0x07) << 4) | (str[3] >> 4);
+	key[4] = ((str[3] & 0x0F) << 3) | (str[4] >> 5);
+	key[5] = ((str[4] & 0x1F) << 2) | (str[5] >> 6);
+	key[6] = ((str[5] & 0x3F) << 1) | (str[6] >> 7);
+	key[7] = str[6] & 0x7F;
+	for (i = 0; i < 8; i++)
+		key[i] = (key[i] << 1);
+}
+
+static int
+smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)
+{
+	unsigned char key2[8];
+	struct des_ctx ctx;
+
+	if (fips_enabled) {
+		ksmbd_debug(AUTH, "FIPS compliance enabled: DES not permitted\n");
+		return -ENOENT;
+	}
+
+	str_to_key(key, key2);
+	des_expand_key(&ctx, key2, DES_KEY_SIZE);
+	des_encrypt(&ctx, out, in);
+	memzero_explicit(&ctx, sizeof(ctx));
+	return 0;
+}
+
+static int ksmbd_enc_p24(unsigned char *p21, const unsigned char *c8, unsigned char *p24)
+{
+	int rc;
+
+	rc = smbhash(p24, c8, p21);
+	if (rc)
+		return rc;
+	rc = smbhash(p24 + 8, c8, p21 + 7);
+	if (rc)
+		return rc;
+	return smbhash(p24 + 16, c8, p21 + 14);
+}
+
+/* produce a md4 message digest from data of length n bytes */
+static int ksmbd_enc_md4(unsigned char *md4_hash, unsigned char *link_str,
+			 int link_len)
+{
+	int rc;
+	struct ksmbd_crypto_ctx *ctx;
+
+	ctx = ksmbd_crypto_ctx_find_md4();
+	if (!ctx) {
+		ksmbd_debug(AUTH, "Crypto md4 allocation error\n");
+		return -ENOMEM;
+	}
+
+	rc = crypto_shash_init(CRYPTO_MD4(ctx));
+	if (rc) {
+		ksmbd_debug(AUTH, "Could not init md4 shash\n");
+		goto out;
+	}
+
+	rc = crypto_shash_update(CRYPTO_MD4(ctx), link_str, link_len);
+	if (rc) {
+		ksmbd_debug(AUTH, "Could not update with link_str\n");
+		goto out;
+	}
+
+	rc = crypto_shash_final(CRYPTO_MD4(ctx), md4_hash);
+	if (rc)
+		ksmbd_debug(AUTH, "Could not generate md4 hash\n");
+out:
+	ksmbd_release_crypto_ctx(ctx);
+	return rc;
+}
+
+#ifdef CONFIG_SMB_INSECURE_SERVER
+static int ksmbd_enc_update_sess_key(unsigned char *md5_hash, char *nonce,
+				     char *server_challenge, int len)
+{
+	int rc;
+	struct ksmbd_crypto_ctx *ctx;
+
+	ctx = ksmbd_crypto_ctx_find_md5();
+	if (!ctx) {
+		ksmbd_debug(AUTH, "Crypto md5 allocation error\n");
+		return -ENOMEM;
+	}
+
+	rc = crypto_shash_init(CRYPTO_MD5(ctx));
+	if (rc) {
+		ksmbd_debug(AUTH, "Could not init md5 shash\n");
+		goto out;
+	}
+
+	rc = crypto_shash_update(CRYPTO_MD5(ctx), server_challenge, len);
+	if (rc) {
+		ksmbd_debug(AUTH, "Could not update with challenge\n");
+		goto out;
+	}
+
+	rc = crypto_shash_update(CRYPTO_MD5(ctx), nonce, len);
+	if (rc) {
+		ksmbd_debug(AUTH, "Could not update with nonce\n");
+		goto out;
+	}
+
+	rc = crypto_shash_final(CRYPTO_MD5(ctx), md5_hash);
+	if (rc)
+		ksmbd_debug(AUTH, "Could not generate md5 hash\n");
+out:
+	ksmbd_release_crypto_ctx(ctx);
+	return rc;
+}
+#endif
+
 /**
  * ksmbd_gen_sess_key() - function to generate session key
  * @sess:	session of connection
@@ -206,6 +326,43 @@ static int calc_ntlmv2_hash(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 	return ret;
 }
 
+/**
+ * ksmbd_auth_ntlm() - NTLM authentication handler
+ * @sess:	session of connection
+ * @pw_buf:	NTLM challenge response
+ * @passkey:	user password
+ *
+ * Return:	0 on success, error number on error
+ */
+int ksmbd_auth_ntlm(struct ksmbd_session *sess, char *pw_buf, char *cryptkey)
+{
+	int rc;
+	unsigned char p21[21];
+	char key[CIFS_AUTH_RESP_SIZE];
+
+	memset(p21, '\0', 21);
+	memcpy(p21, user_passkey(sess->user), CIFS_NTHASH_SIZE);
+	rc = ksmbd_enc_p24(p21, cryptkey, key);
+	if (rc) {
+		pr_err("password processing failed\n");
+		return rc;
+	}
+
+	ksmbd_enc_md4(sess->sess_key, user_passkey(sess->user),
+		      CIFS_SMB1_SESSKEY_SIZE);
+	memcpy(sess->sess_key + CIFS_SMB1_SESSKEY_SIZE, key,
+	       CIFS_AUTH_RESP_SIZE);
+	sess->sequence_number = 1;
+
+	if (strncmp(pw_buf, key, CIFS_AUTH_RESP_SIZE) != 0) {
+		ksmbd_debug(AUTH, "ntlmv1 authentication failed\n");
+		return -EINVAL;
+	}
+
+	ksmbd_debug(AUTH, "ntlmv1 authentication pass\n");
+	return 0;
+}
+
 /**
  * ksmbd_auth_ntlmv2() - NTLMv2 authentication handler
  * @sess:	session of connection
@@ -290,6 +447,105 @@ int ksmbd_auth_ntlmv2(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 	return rc;
 }
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+/**
+ * __ksmbd_auth_ntlmv2() - NTLM2(extended security) authentication handler
+ * @sess:	session of connection
+ * @client_nonce:	client nonce from LM response.
+ * @ntlm_resp:		ntlm response data from client.
+ *
+ * Return:	0 on success, error number on error
+ */
+static int __ksmbd_auth_ntlmv2(struct ksmbd_session *sess,
+			       char *client_nonce,
+			       char *ntlm_resp,
+			       char *cryptkey)
+{
+	char sess_key[CIFS_SMB1_SESSKEY_SIZE] = {0};
+	int rc;
+	unsigned char p21[21];
+	char key[CIFS_AUTH_RESP_SIZE];
+
+	rc = ksmbd_enc_update_sess_key(sess_key, client_nonce, cryptkey, 8);
+	if (rc) {
+		pr_err("password processing failed\n");
+		goto out;
+	}
+
+	memset(p21, '\0', 21);
+	memcpy(p21, user_passkey(sess->user), CIFS_NTHASH_SIZE);
+	rc = ksmbd_enc_p24(p21, sess_key, key);
+	if (rc) {
+		pr_err("password processing failed\n");
+		goto out;
+	}
+
+	if (memcmp(ntlm_resp, key, CIFS_AUTH_RESP_SIZE) != 0)
+		rc = -EINVAL;
+out:
+	return rc;
+}
+#endif
+
+static int cifs_arc4_setkey(struct arc4_ctx *ctx, const u8 *in_key, unsigned int key_len)
+{
+	int i, j = 0, k = 0;
+
+	ctx->x = 1;
+	ctx->y = 0;
+
+	for (i = 0; i < 256; i++)
+		ctx->S[i] = i;
+
+	for (i = 0; i < 256; i++) {
+		u32 a = ctx->S[i];
+
+		j = (j + in_key[k] + a) & 0xff;
+		ctx->S[i] = ctx->S[j];
+		ctx->S[j] = a;
+		if (++k >= key_len)
+			k = 0;
+	}
+
+	return 0;
+}
+
+static void cifs_arc4_crypt(struct arc4_ctx *ctx, u8 *out, const u8 *in, unsigned int len)
+{
+	u32 *const S = ctx->S;
+	u32 x, y, a, b;
+	u32 ty, ta, tb;
+
+	if (len == 0)
+		return;
+
+	x = ctx->x;
+	y = ctx->y;
+
+	a = S[x];
+	y = (y + a) & 0xff;
+	b = S[y];
+
+	do {
+		S[y] = a;
+		a = (a + b) & 0xff;
+		S[x] = b;
+		x = (x + 1) & 0xff;
+		ta = S[x];
+		ty = (y + ta) & 0xff;
+		tb = S[ty];
+		*out++ = *in++ ^ S[a];
+		if (--len == 0)
+			break;
+		y = ty;
+		a = ta;
+		b = tb;
+	} while (true);
+
+	ctx->x = x;
+	ctx->y = y;
+}
+
 /**
  * ksmbd_decode_ntlmssp_auth_blob() - helper function to construct
  * authenticate blob
@@ -306,6 +562,10 @@ int ksmbd_decode_ntlmssp_auth_blob(struct authenticate_message *authblob,
 	char *domain_name;
 	unsigned int nt_off, dn_off;
 	unsigned short nt_len, dn_len;
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	unsigned int lm_off;
+	unsigned short lm_len;
+#endif
 	int ret;
 
 	if (blob_len < sizeof(struct authenticate_message)) {
@@ -322,6 +582,7 @@ int ksmbd_decode_ntlmssp_auth_blob(struct authenticate_message *authblob,
 
 	nt_off = le32_to_cpu(authblob->NtChallengeResponse.BufferOffset);
 	nt_len = le16_to_cpu(authblob->NtChallengeResponse.Length);
+
 	dn_off = le32_to_cpu(authblob->DomainName.BufferOffset);
 	dn_len = le16_to_cpu(authblob->DomainName.Length);
 
@@ -329,6 +590,26 @@ int ksmbd_decode_ntlmssp_auth_blob(struct authenticate_message *authblob,
 	    nt_len < CIFS_ENCPWD_SIZE)
 		return -EINVAL;
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	lm_off = le32_to_cpu(authblob->LmChallengeResponse.BufferOffset);
+	lm_len = le16_to_cpu(authblob->LmChallengeResponse.Length);
+	if (blob_len < (u64)lm_off + lm_len)
+		return -EINVAL;
+
+	/* process NTLM authentication */
+	if (nt_len == CIFS_AUTH_RESP_SIZE) {
+		if (le32_to_cpu(authblob->NegotiateFlags) &
+		    NTLMSSP_NEGOTIATE_EXTENDED_SEC)
+			return __ksmbd_auth_ntlmv2(sess,
+						   (char *)authblob + lm_off,
+						   (char *)authblob + nt_off,
+						   conn->ntlmssp.cryptkey);
+		else
+			return ksmbd_auth_ntlm(sess, (char *)authblob +
+				nt_off, conn->ntlmssp.cryptkey);
+	}
+#endif
+
 	/* TODO : use domain name that imported from configuration file */
 	domain_name = smb_strndup_from_utf16((const char *)authblob + dn_off,
 					     dn_len, true, conn->local_nls);
@@ -355,6 +636,9 @@ int ksmbd_decode_ntlmssp_auth_blob(struct authenticate_message *authblob,
 		if (blob_len < (u64)sess_key_off + sess_key_len)
 			return -EINVAL;
 
+		if (sess_key_len > CIFS_KEY_SIZE)
+			return -EINVAL;
+
 		ctx_arc4 = kmalloc(sizeof(*ctx_arc4), GFP_KERNEL);
 		if (!ctx_arc4)
 			return -ENOMEM;
@@ -363,7 +647,12 @@ int ksmbd_decode_ntlmssp_auth_blob(struct authenticate_message *authblob,
 				 SMB2_NTLMV2_SESSKEY_SIZE);
 		cifs_arc4_crypt(ctx_arc4, sess->sess_key,
 				(char *)authblob + sess_key_off, sess_key_len);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
 		kfree_sensitive(ctx_arc4);
+#else
+		memzero_explicit((void *)ctx_arc4, sizeof(*ctx_arc4));
+		kfree(ctx_arc4);
+#endif
 	}
 
 	return ret;
@@ -560,6 +849,59 @@ int ksmbd_krb5_authenticate(struct ksmbd_session *sess, char *in_blob,
 }
 #endif
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+/**
+ * ksmbd_sign_smb1_pdu() - function to generate SMB1 packet signing
+ * @sess:	session of connection
+ * @iov:        buffer iov array
+ * @n_vec:	number of iovecs
+ * @sig:        signature value generated for client request packet
+ *
+ */
+int ksmbd_sign_smb1_pdu(struct ksmbd_session *sess, struct kvec *iov, int n_vec,
+			char *sig)
+{
+	struct ksmbd_crypto_ctx *ctx;
+	int rc, i;
+
+	ctx = ksmbd_crypto_ctx_find_md5();
+	if (!ctx) {
+		ksmbd_debug(AUTH, "could not crypto alloc md5\n");
+		return -ENOMEM;
+	}
+
+	rc = crypto_shash_init(CRYPTO_MD5(ctx));
+	if (rc) {
+		ksmbd_debug(AUTH, "md5 init error %d\n", rc);
+		goto out;
+	}
+
+	rc = crypto_shash_update(CRYPTO_MD5(ctx), sess->sess_key, 40);
+	if (rc) {
+		ksmbd_debug(AUTH, "md5 update error %d\n", rc);
+		goto out;
+	}
+
+	for (i = 0; i < n_vec; i++) {
+		rc = crypto_shash_update(CRYPTO_MD5(ctx),
+					 iov[i].iov_base,
+					 iov[i].iov_len);
+		if (rc) {
+			ksmbd_debug(AUTH, "md5 update error %d\n", rc);
+			goto out;
+		}
+	}
+
+	rc = crypto_shash_final(CRYPTO_MD5(ctx), sig);
+	if (rc)
+		ksmbd_debug(AUTH, "md5 generation error %d\n", rc);
+
+out:
+	ksmbd_release_crypto_ctx(ctx);
+	return rc;
+}
+#endif
+
 /**
  * ksmbd_sign_smb2_pdu() - function to generate packet signing
  * @conn:	connection
@@ -1029,11 +1371,15 @@ static struct scatterlist *ksmbd_init_sg(struct kvec *iov, unsigned int nvec,
 {
 	struct scatterlist *sg;
 	unsigned int assoc_data_len = sizeof(struct smb2_transform_hdr) - 20;
-	int i, nr_entries[3] = {0}, total_entries = 0, sg_idx = 0;
+	int i, *nr_entries, total_entries = 0, sg_idx = 0;
 
 	if (!nvec)
 		return NULL;
 
+	nr_entries = kcalloc(nvec, sizeof(int), GFP_KERNEL);
+	if (!nr_entries)
+		return NULL;
+
 	for (i = 0; i < nvec - 1; i++) {
 		unsigned long kaddr = (unsigned long)iov[i + 1].iov_base;
 
@@ -1051,8 +1397,10 @@ static struct scatterlist *ksmbd_init_sg(struct kvec *iov, unsigned int nvec,
 	total_entries += 2;
 
 	sg = kmalloc_array(total_entries, sizeof(struct scatterlist), GFP_KERNEL);
-	if (!sg)
+	if (!sg) {
+		kfree(nr_entries);
 		return NULL;
+	}
 
 	sg_init_table(sg, total_entries);
 	smb2_sg_set_buf(&sg[sg_idx++], iov[0].iov_base + 24, assoc_data_len);
@@ -1086,6 +1434,7 @@ static struct scatterlist *ksmbd_init_sg(struct kvec *iov, unsigned int nvec,
 		}
 	}
 	smb2_sg_set_buf(&sg[sg_idx], sign, SMB2_SIGNATURE_SIZE);
+	kfree(nr_entries);
 	return sg;
 }
 
diff --git a/fs/ksmbd/auth.h b/fs/ksmbd/auth.h
index 362b6159a6cf..caba4341988b 100644
--- a/fs/ksmbd/auth.h
+++ b/fs/ksmbd/auth.h
@@ -39,6 +39,7 @@ struct kvec;
 int ksmbd_crypt_message(struct ksmbd_work *work, struct kvec *iov,
 			unsigned int nvec, int enc);
 void ksmbd_copy_gss_neg_header(void *buf);
+int ksmbd_auth_ntlm(struct ksmbd_session *sess, char *pw_buf, char *cryptkey);
 int ksmbd_auth_ntlmv2(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 		      struct ntlmv2_resp *ntlmv2, int blen, char *domain_name,
 		      char *cryptkey);
@@ -51,7 +52,11 @@ unsigned int
 ksmbd_build_ntlmssp_challenge_blob(struct challenge_message *chgblob,
 				   struct ksmbd_conn *conn);
 int ksmbd_krb5_authenticate(struct ksmbd_session *sess, char *in_blob,
-			    int in_len,	char *out_blob, int *out_len);
+			    int in_len, char *out_blob, int *out_len);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+int ksmbd_sign_smb1_pdu(struct ksmbd_session *sess, struct kvec *iov, int n_vec,
+			char *sig);
+#endif
 int ksmbd_sign_smb2_pdu(struct ksmbd_conn *conn, char *key, struct kvec *iov,
 			int n_vec, char *sig);
 int ksmbd_sign_smb3_pdu(struct ksmbd_conn *conn, char *key, struct kvec *iov,
@@ -68,4 +73,13 @@ int ksmbd_gen_preauth_integrity_hash(struct ksmbd_conn *conn, char *buf,
 				     __u8 *pi_hash);
 int ksmbd_gen_sd_hash(struct ksmbd_conn *conn, char *sd_buf, int len,
 		      __u8 *pi_hash);
+
+#define ARC4_MIN_KEY_SIZE	1
+#define ARC4_MAX_KEY_SIZE	256
+#define ARC4_BLOCK_SIZE		1
+
+struct arc4_ctx {
+	u32 S[256];
+	u32 x, y;
+};
 #endif
diff --git a/fs/ksmbd/build_ksmbd.sh b/fs/ksmbd/build_ksmbd.sh
new file mode 100755
index 000000000000..4b10f0417d84
--- /dev/null
+++ b/fs/ksmbd/build_ksmbd.sh
@@ -0,0 +1,177 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Copyright (C) 2019 Samsung Electronics Co., Ltd.
+#
+
+#!/bin/sh
+
+KERNEL_SRC=''
+COMP_FLAGS=''
+
+function is_module
+{
+	local ok=$(cat "$KERNEL_SRC"/.config | grep "CONFIG_SMB_SERVER=m")
+
+	if [ "z$ok" == "z" ]; then
+		echo "1"
+		return 1
+	fi
+
+	echo "0"
+	return 0
+}
+
+function patch_fs_config
+{
+	local ok=$(pwd |  grep -c "fs/smbd")
+	if [ "z$ok" != "z1" ]; then
+		echo "ERROR: please ``cd`` to fs/smbd"
+		exit 1
+	fi
+
+	KERNEL_SRC=$(pwd | sed -e 's/fs\/smbd//')
+	if [ ! -f "$KERNEL_SRC"/fs/Kconfig ]; then
+		echo "ERROR: please ``cd`` to fs/smbd"
+		exit 1
+	fi
+
+	ok=$(cat "$KERNEL_SRC"/fs/Makefile | grep smbd)
+	if [ "z$ok" == "z" ]; then
+		echo 'obj-$(CONFIG_SMB_SERVER)	+= smbd/' \
+			>> "$KERNEL_SRC"/fs/Makefile
+	fi
+
+	ok=$(cat "$KERNEL_SRC"/fs/Kconfig | grep smbd)
+	if [ "z$ok" == "z" ]; then
+		ok=$(cat "$KERNEL_SRC"/fs/Kconfig \
+			| sed -e 's/fs\/cifs\/Kconfig/fs\/cifs\/Kconfig\"\nsource \"fs\/smbd\/Kconfig/' \
+			> "$KERNEL_SRC"/fs/Kconfig.new)
+		if [ $? != 0 ]; then
+			exit 1
+		fi
+		mv "$KERNEL_SRC"/fs/Kconfig.new "$KERNEL_SRC"/fs/Kconfig
+	fi
+
+	ok=$(cat "$KERNEL_SRC"/.config | grep "CONFIG_NETWORK_FILESYSTEMS=y")
+	if [ "z$ok" == "z" ]; then
+		ok=$(echo "CONFIG_NETWORK_FILESYSTEMS=y" \
+			>> "$KERNEL_SRC"/.config)
+		if [ $? != 0 ]; then
+			exit 1
+		fi
+	fi
+
+	ok=$(is_module)
+	if [ "z$ok" == "z1" ]; then
+		ok=$(echo "CONFIG_SMB_SERVER=m" >> "$KERNEL_SRC"/.config)
+		if [ $? != 0 ]; then
+			exit 1
+		fi
+		ok=$(echo "CONFIG_SMB_INSECURE_SERVER=y" \
+			>> "$KERNEL_SRC"/.config)
+		if [ $? != 0 ]; then
+			exit 1
+		fi
+	fi
+}
+
+function ksmbd_module_make
+{
+	echo "Running smbd make"
+
+	local c="make "$COMP_FLAGS" -C "$KERNEL_SRC" M="$KERNEL_SRC"/fs/smbd"
+
+	rm smbd.ko
+
+	cd "$KERNEL_SRC"
+	echo $c
+	$c
+	cd "$KERNEL_SRC"/fs/smbd
+
+	if [ $? != 0 ]; then
+		exit 1
+	fi
+}
+
+function ksmbd_module_install
+{
+	echo "Running smbd install"
+
+	local ok=$(lsmod | grep -c smbd)
+	if [ "z$ok" == "z1" ]; then
+		sudo rmmod smbd
+		if [ $? -ne 0 ]; then
+			echo "ERROR: unable to rmmod smbd"
+			exit 1
+		fi
+	fi
+
+	ok=$(is_module)
+	if [ "z$ok" == "z1" ]; then
+		echo "It doesn't look like SMB_SERVER is as a kernel module"
+		exit 1
+	fi
+
+	if [ ! -f "$KERNEL_SRC"/fs/smbd/smbd.ko ]; then
+		echo "ERROR: smbd.ko was not found"
+		exit 1
+	fi
+
+	cd "$KERNEL_SRC"
+	if [ -f "/lib/modules/$(uname -r)/kernel/fs/smbd/smbd.ko*" ]; then
+		sudo rm /lib/modules/$(uname -r)/kernel/fs/smbd/smbd.ko*
+		sudo cp "$KERNEL_SRC"/fs/smbd/smbd.ko \
+			/lib/modules/$(uname -r)/kernel/fs/smbd/smbd.ko
+
+		local VER=$(make kernelrelease)
+		sudo depmod -A $VER
+	else
+		sudo make -C "$KERNEL_SRC" M="$KERNEL_SRC"/fs/smbd/ \
+			modules_install
+		local VER=$(make kernelrelease)
+		sudo depmod -A $VER
+	fi
+	cd "$KERNEL_SRC"/fs/smbd
+}
+
+function ksmbd_module_clean
+{
+	echo "Running smbd clean"
+
+	cd "$KERNEL_SRC"
+	make -C "$KERNEL_SRC" M="$KERNEL_SRC"/fs/smbd/ clean
+	cd "$KERNEL_SRC"/fs/smbd
+}
+
+function main
+{
+	patch_fs_config
+
+	COMP_FLAGS="$FLAGS"
+
+	case $1 in
+		clean)
+			ksmbd_module_clean
+			exit 0
+			;;
+		install)
+			ksmbd_module_make
+			ksmbd_module_install
+			exit 0
+			;;
+		make)
+			ksmbd_module_make
+			exit 0
+			;;
+		help)
+			echo "Usage: build_ksmbd.sh [clean | make | install]"
+			exit 0
+			;;
+		*)
+			ksmbd_module_make
+			exit 0
+			;;
+	esac
+}
+
+main $1
diff --git a/fs/ksmbd/compat.c b/fs/ksmbd/compat.c
new file mode 100644
index 000000000000..cd48401f28c5
--- /dev/null
+++ b/fs/ksmbd/compat.c
@@ -0,0 +1,149 @@
+#include <linux/version.h>
+#include <linux/fs.h>
+#include "compat.h"
+#include "vfs.h"
+
+#ifndef STATX_BASIC_STATS
+#define STATX_BASIC_STATS 0x000007ffU
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+void compat_generic_fillattr(struct path *path, u32 request_mask,
+			     struct inode *inode, struct kstat *kstat)
+{
+	generic_fillattr(mnt_idmap(path->mnt), request_mask,
+			 inode, kstat);
+
+}
+
+int compat_ksmbd_vfs_get_dos_attrib_xattr(const struct path *path,
+					  struct dentry *dentry,
+					  struct xattr_dos_attrib *da)
+{
+	return ksmbd_vfs_get_dos_attrib_xattr(mnt_idmap(path->mnt), dentry,
+					      da);
+}
+
+int compat_ksmbd_vfs_set_dos_attrib_xattr(const struct path *path,
+					  struct xattr_dos_attrib *da,
+					  bool get_write)
+{
+	return ksmbd_vfs_set_dos_attrib_xattr(mnt_idmap(path->mnt), path, da,
+			get_write);
+}
+
+ssize_t compat_ksmbd_vfs_getxattr(struct path *path, struct dentry *dentry,
+				  char *xattr_name, char **xattr_buf)
+{
+	return ksmbd_vfs_getxattr(mnt_idmap(path->mnt), dentry,
+				  xattr_name, xattr_buf);
+}
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int compat_inode_permission(struct path *path, struct inode *inode, int mask)
+{
+	return inode_permission(mnt_idmap(path->mnt), inode, mask);
+
+}
+
+void compat_generic_fillattr(struct path *path, u32 request_mask,
+			     struct inode *inode, struct kstat *kstat)
+{
+	generic_fillattr(mnt_idmap(path->mnt), inode, kstat);
+
+}
+
+int compat_ksmbd_vfs_get_dos_attrib_xattr(const struct path *path,
+					  struct dentry *dentry,
+					  struct xattr_dos_attrib *da)
+{
+	return ksmbd_vfs_get_dos_attrib_xattr(mnt_idmap(path->mnt), dentry,
+					      da);
+}
+
+int compat_ksmbd_vfs_set_dos_attrib_xattr(const struct path *path,
+					  struct xattr_dos_attrib *da,
+					  bool get_write)
+{
+	return ksmbd_vfs_set_dos_attrib_xattr(mnt_idmap(path->mnt), path, da,
+			get_write);
+}
+
+ssize_t compat_ksmbd_vfs_getxattr(struct path *path, struct dentry *dentry,
+				  char *xattr_name, char **xattr_buf)
+{
+	return ksmbd_vfs_getxattr(mnt_idmap(path->mnt), dentry,
+				  xattr_name, xattr_buf);
+}
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+int compat_inode_permission(struct path *path, struct inode *inode, int mask)
+{
+	return inode_permission(mnt_user_ns(path->mnt), inode, mask);
+
+}
+void compat_generic_fillattr(struct path *path, u32 request_mask,
+			     struct inode *inode, struct kstat *kstat)
+{
+	generic_fillattr(mnt_user_ns(path->mnt), inode, kstat);
+
+}
+
+int compat_ksmbd_vfs_get_dos_attrib_xattr(const struct path *path,
+					  struct dentry *dentry,
+					  struct xattr_dos_attrib *da)
+{
+	return ksmbd_vfs_get_dos_attrib_xattr(mnt_user_ns(path->mnt), dentry,
+					      da);
+}
+
+int compat_ksmbd_vfs_set_dos_attrib_xattr(const struct path *path,
+					  struct xattr_dos_attrib *da,
+					  bool get_write)
+{
+	return ksmbd_vfs_set_dos_attrib_xattr(mnt_user_ns(path->mnt), path, da,
+			get_write);
+}
+
+ssize_t compat_ksmbd_vfs_getxattr(struct path *path, struct dentry *dentry,
+				  char *xattr_name, char **xattr_buf)
+{
+	return ksmbd_vfs_getxattr(mnt_user_ns(path->mnt), dentry,
+				  xattr_name, xattr_buf);
+}
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 12, 0)
+int compat_inode_permission(struct path *path, struct inode *inode, int mask)
+{
+	return inode_permission(inode, mask);
+
+}
+void compat_generic_fillattr(struct path *path, u32 request_mask,
+			     struct inode *inode, struct kstat *kstat)
+{
+	generic_fillattr(inode, kstat);
+}
+int compat_ksmbd_vfs_get_dos_attrib_xattr(const struct path *path,
+					  struct dentry *dentry,
+					  struct xattr_dos_attrib *da)
+{
+	return ksmbd_vfs_get_dos_attrib_xattr(mnt_user_ns(path->mnt), dentry,
+					      da);
+}
+
+int compat_ksmbd_vfs_set_dos_attrib_xattr(const struct path *path,
+					  struct xattr_dos_attrib *da,
+					  bool get_write)
+{
+	return ksmbd_vfs_set_dos_attrib_xattr(mnt_user_ns(path->mnt), path,
+					      da, get_write);
+}
+ssize_t compat_ksmbd_vfs_getxattr(struct path *path, struct dentry *dentry,
+				  char *xattr_name, char **xattr_buf)
+{
+	return ksmbd_vfs_getxattr(mnt_user_ns(path->mnt), dentry,
+				  xattr_name, xattr_buf);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(5, 12, 0) */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0) */
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0) */
diff --git a/fs/ksmbd/compat.h b/fs/ksmbd/compat.h
new file mode 100644
index 000000000000..0c03f5c9a3e8
--- /dev/null
+++ b/fs/ksmbd/compat.h
@@ -0,0 +1,26 @@
+#ifndef COMPAT_H
+#define COMPAT_H
+
+struct dentry;
+struct inode;
+struct path;
+struct xattr_dos_attrib;
+
+/* linux vfs */
+int compat_inode_permission(struct path *path, struct inode *inode, int mask);
+void compat_generic_fillattr(struct path *path, u32 request_mask,
+			     struct inode *inode, struct kstat *kstat);
+
+
+/* ksmbd vfs */
+ssize_t compat_ksmbd_vfs_getxattr(struct path *path, struct dentry *dentry,
+				  char *xattr_name, char **xattr_buf);
+int compat_ksmbd_vfs_get_dos_attrib_xattr(const struct path *path,
+					  struct dentry *dentry,
+					  struct xattr_dos_attrib *da);
+
+int compat_ksmbd_vfs_set_dos_attrib_xattr(const struct path *path,
+					  struct xattr_dos_attrib *da,
+					  bool get_write);
+
+#endif
diff --git a/fs/ksmbd/connection.c b/fs/ksmbd/connection.c
index e3312fbf4c09..7fc3e75de1b1 100644
--- a/fs/ksmbd/connection.c
+++ b/fs/ksmbd/connection.c
@@ -10,6 +10,9 @@
 
 #include "server.h"
 #include "smb_common.h"
+#ifdef CONFIG_SMB_INSECURE_SERVER
+#include "smb1pdu.h"
+#endif
 #include "mgmt/ksmbd_ida.h"
 #include "connection.h"
 #include "transport_tcp.h"
@@ -61,7 +64,11 @@ struct ksmbd_conn *ksmbd_conn_alloc(void)
 	if (!conn->local_nls)
 		conn->local_nls = load_nls_default();
 	if (IS_ENABLED(CONFIG_UNICODE))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
 		conn->um = utf8_load(UNICODE_AGE(12, 1, 0));
+#else
+		conn->um = utf8_load("12.1.0");
+#endif
 	else
 		conn->um = ERR_PTR(-EOPNOTSUPP);
 	if (IS_ERR(conn->um))
@@ -84,6 +91,8 @@ struct ksmbd_conn *ksmbd_conn_alloc(void)
 	spin_lock_init(&conn->llist_lock);
 	INIT_LIST_HEAD(&conn->lock_list);
 
+	init_rwsem(&conn->session_lock);
+
 	down_write(&conn_list_lock);
 	list_add(&conn->conns_list, &conn_list);
 	up_write(&conn_list_lock);
@@ -111,11 +120,20 @@ void ksmbd_conn_enqueue_request(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
 	struct list_head *requests_queue = NULL;
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	struct smb2_hdr *hdr = work->request_buf;
 
-	if (conn->ops->get_cmd_val(work) != SMB2_CANCEL_HE) {
-		requests_queue = &conn->requests;
-		work->syncronous = true;
+	if (hdr->ProtocolId == SMB2_PROTO_NUMBER) {
+		if (conn->ops->get_cmd_val(work) != SMB2_CANCEL_HE)
+			requests_queue = &conn->requests;
+	} else {
+		if (conn->ops->get_cmd_val(work) != SMB_COM_NT_CANCEL)
+			requests_queue = &conn->requests;
 	}
+#else
+	if (conn->ops->get_cmd_val(work) != SMB2_CANCEL_HE)
+		requests_queue = &conn->requests;
+#endif
 
 	if (requests_queue) {
 		atomic_inc(&conn->req_running);
@@ -125,28 +143,22 @@ void ksmbd_conn_enqueue_request(struct ksmbd_work *work)
 	}
 }
 
-int ksmbd_conn_try_dequeue_request(struct ksmbd_work *work)
+void ksmbd_conn_try_dequeue_request(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
-	int ret = 1;
 
 	if (list_empty(&work->request_entry) &&
 	    list_empty(&work->async_request_entry))
-		return 0;
+		return;
 
-	if (!work->multiRsp)
-		atomic_dec(&conn->req_running);
+	atomic_dec(&conn->req_running);
 	spin_lock(&conn->request_lock);
-	if (!work->multiRsp) {
-		list_del_init(&work->request_entry);
-		if (work->syncronous == false)
-			list_del_init(&work->async_request_entry);
-		ret = 0;
-	}
+	list_del_init(&work->request_entry);
 	spin_unlock(&conn->request_lock);
+	if (work->asynchronous)
+		release_async_work(work);
 
 	wake_up_all(&conn->req_running_q);
-	return ret;
 }
 
 void ksmbd_conn_lock(struct ksmbd_conn *conn)
@@ -173,64 +185,66 @@ void ksmbd_all_conn_set_status(u64 sess_id, u32 status)
 
 void ksmbd_conn_wait_idle(struct ksmbd_conn *conn, u64 sess_id)
 {
-	struct ksmbd_conn *bind_conn;
-
 	wait_event(conn->req_running_q, atomic_read(&conn->req_running) < 2);
-
-	down_read(&conn_list_lock);
-	list_for_each_entry(bind_conn, &conn_list, conns_list) {
-		if (bind_conn == conn)
-			continue;
-
-		if ((bind_conn->binding || xa_load(&bind_conn->sessions, sess_id)) &&
-		    !ksmbd_conn_releasing(bind_conn) &&
-		    atomic_read(&bind_conn->req_running)) {
-			wait_event(bind_conn->req_running_q,
-				atomic_read(&bind_conn->req_running) == 0);
-		}
-	}
-	up_read(&conn_list_lock);
 }
 
 int ksmbd_conn_write(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
-	size_t len = 0;
 	int sent;
-	struct kvec iov[3];
-	int iov_idx = 0;
 
 	if (!work->response_buf) {
 		pr_err("NULL response header\n");
 		return -EINVAL;
 	}
 
-	if (work->tr_buf) {
-		iov[iov_idx] = (struct kvec) { work->tr_buf,
-				sizeof(struct smb2_transform_hdr) + 4 };
-		len += iov[iov_idx++].iov_len;
-	}
+	if (work->send_no_response)
+		return 0;
 
-	if (work->aux_payload_sz) {
-		iov[iov_idx] = (struct kvec) { work->response_buf, work->resp_hdr_sz };
-		len += iov[iov_idx++].iov_len;
-		iov[iov_idx] = (struct kvec) { work->aux_payload_buf, work->aux_payload_sz };
-		len += iov[iov_idx++].iov_len;
-	} else {
-		if (work->tr_buf)
-			iov[iov_idx].iov_len = work->resp_hdr_sz;
-		else
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (!work->iov_idx) {
+		struct kvec iov[2];
+		int iov_idx = 0;
+		size_t len = 0;
+
+		if (work->aux_payload_sz) {
+			iov[iov_idx] = (struct kvec) { work->response_buf, work->resp_hdr_sz };
+			len += iov[iov_idx++].iov_len;
+			iov[iov_idx] = (struct kvec) { work->aux_payload_buf, work->aux_payload_sz };
+			len += iov[iov_idx++].iov_len;
+		} else {
 			iov[iov_idx].iov_len = get_rfc1002_len(work->response_buf) + 4;
-		iov[iov_idx].iov_base = work->response_buf;
-		len += iov[iov_idx++].iov_len;
+			iov[iov_idx].iov_base = work->response_buf;
+			len += iov[iov_idx++].iov_len;
+		}
+
+		ksmbd_conn_lock(conn);
+		sent = conn->transport->ops->writev(conn->transport, &iov[0],
+				iov_idx, len, work->need_invalidate_rkey,
+				work->remote_key);
+		ksmbd_conn_unlock(conn);
+
+	} else {
+		ksmbd_conn_lock(conn);
+		sent = conn->transport->ops->writev(conn->transport, work->iov,
+				work->iov_cnt,
+				get_rfc1002_len(work->iov[0].iov_base) + 4,
+				work->need_invalidate_rkey,
+				work->remote_key);
+		ksmbd_conn_unlock(conn);
 	}
+#else
+	if (!work->iov_idx)
+		return -EINVAL;
 
 	ksmbd_conn_lock(conn);
-	sent = conn->transport->ops->writev(conn->transport, &iov[0],
-					iov_idx, len,
-					work->need_invalidate_rkey,
-					work->remote_key);
+	sent = conn->transport->ops->writev(conn->transport, work->iov,
+			work->iov_cnt,
+			get_rfc1002_len(work->iov[0].iov_base) + 4,
+			work->need_invalidate_rkey,
+			work->remote_key);
 	ksmbd_conn_unlock(conn);
+#endif
 
 	if (sent < 0) {
 		pr_err("Failed to send message: %d\n", sent);
@@ -296,6 +310,9 @@ bool ksmbd_conn_alive(struct ksmbd_conn *conn)
 	return true;
 }
 
+#define SMB1_MIN_SUPPORTED_HEADER_SIZE (sizeof(struct smb_hdr))
+#define SMB2_MIN_SUPPORTED_HEADER_SIZE (sizeof(struct smb2_hdr) + 4)
+
 /**
  * ksmbd_conn_handler_loop() - session thread to listen on new smb requests
  * @p:		connection instance
@@ -352,15 +369,17 @@ int ksmbd_conn_handler_loop(void *p)
 		if (pdu_size > MAX_STREAM_PROT_LEN)
 			break;
 
+		if (pdu_size < SMB1_MIN_SUPPORTED_HEADER_SIZE)
+			break;
+
 		/* 4 for rfc1002 length field */
-		size = pdu_size + 4;
+		/* 1 for implied bcc[0] */
+		size = pdu_size + 4 + 1;
 		conn->request_buf = kvmalloc(size, GFP_KERNEL);
 		if (!conn->request_buf)
 			break;
 
 		memcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf));
-		if (!ksmbd_smb_request(conn))
-			break;
 
 		/*
 		 * We already read 4 bytes to find out PDU size, now
@@ -378,6 +397,15 @@ int ksmbd_conn_handler_loop(void *p)
 			continue;
 		}
 
+		if (!ksmbd_smb_request(conn))
+			break;
+
+		if (((struct smb2_hdr *)smb2_get_msg(conn->request_buf))->ProtocolId ==
+		    SMB2_PROTO_NUMBER) {
+			if (pdu_size < SMB2_MIN_SUPPORTED_HEADER_SIZE)
+				break;
+		}
+
 		if (!default_conn_ops.process_fn) {
 			pr_err("No connection request callback\n");
 			break;
diff --git a/fs/ksmbd/connection.h b/fs/ksmbd/connection.h
index ad8dfaa48ffb..3c005246a32e 100644
--- a/fs/ksmbd/connection.h
+++ b/fs/ksmbd/connection.h
@@ -50,6 +50,7 @@ struct ksmbd_conn {
 	struct nls_table		*local_nls;
 	struct unicode_map		*um;
 	struct list_head		conns_list;
+	struct rw_semaphore		session_lock;
 	/* smb session 1 per user */
 	struct xarray			sessions;
 	unsigned long			last_active;
@@ -158,7 +159,7 @@ int ksmbd_conn_rdma_write(struct ksmbd_conn *conn,
 			  struct smb2_buffer_desc_v1 *desc,
 			  unsigned int desc_len);
 void ksmbd_conn_enqueue_request(struct ksmbd_work *work);
-int ksmbd_conn_try_dequeue_request(struct ksmbd_work *work);
+void ksmbd_conn_try_dequeue_request(struct ksmbd_work *work);
 void ksmbd_conn_init_server_callbacks(struct ksmbd_conn_ops *ops);
 int ksmbd_conn_handler_loop(void *p);
 int ksmbd_conn_transport_init(void);
diff --git a/fs/ksmbd/crypto_ctx.c b/fs/ksmbd/crypto_ctx.c
index 81488d04199d..5f4b1008d17e 100644
--- a/fs/ksmbd/crypto_ctx.c
+++ b/fs/ksmbd/crypto_ctx.c
@@ -81,6 +81,12 @@ static struct shash_desc *alloc_shash_desc(int id)
 	case CRYPTO_SHASH_SHA512:
 		tfm = crypto_alloc_shash("sha512", 0, 0);
 		break;
+	case CRYPTO_SHASH_MD4:
+		tfm = crypto_alloc_shash("md4", 0, 0);
+		break;
+	case CRYPTO_SHASH_MD5:
+		tfm = crypto_alloc_shash("md5", 0, 0);
+		break;
 	default:
 		return NULL;
 	}
@@ -208,6 +214,16 @@ struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_sha512(void)
 	return ____crypto_shash_ctx_find(CRYPTO_SHASH_SHA512);
 }
 
+struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_md4(void)
+{
+	return ____crypto_shash_ctx_find(CRYPTO_SHASH_MD4);
+}
+
+struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_md5(void)
+{
+	return ____crypto_shash_ctx_find(CRYPTO_SHASH_MD5);
+}
+
 static struct ksmbd_crypto_ctx *____crypto_aead_ctx_find(int id)
 {
 	struct ksmbd_crypto_ctx *ctx;
diff --git a/fs/ksmbd/crypto_ctx.h b/fs/ksmbd/crypto_ctx.h
index 4a367c62f653..ef11154b43df 100644
--- a/fs/ksmbd/crypto_ctx.h
+++ b/fs/ksmbd/crypto_ctx.h
@@ -15,6 +15,8 @@ enum {
 	CRYPTO_SHASH_CMACAES,
 	CRYPTO_SHASH_SHA256,
 	CRYPTO_SHASH_SHA512,
+	CRYPTO_SHASH_MD4,
+	CRYPTO_SHASH_MD5,
 	CRYPTO_SHASH_MAX,
 };
 
@@ -41,6 +43,8 @@ struct ksmbd_crypto_ctx {
 #define CRYPTO_CMACAES(c)	((c)->desc[CRYPTO_SHASH_CMACAES])
 #define CRYPTO_SHA256(c)	((c)->desc[CRYPTO_SHASH_SHA256])
 #define CRYPTO_SHA512(c)	((c)->desc[CRYPTO_SHASH_SHA512])
+#define CRYPTO_MD4(c)		((c)->desc[CRYPTO_SHASH_MD4])
+#define CRYPTO_MD5(c)		((c)->desc[CRYPTO_SHASH_MD5])
 
 #define CRYPTO_HMACMD5_TFM(c)	((c)->desc[CRYPTO_SHASH_HMACMD5]->tfm)
 #define CRYPTO_HMACSHA256_TFM(c)\
@@ -48,6 +52,8 @@ struct ksmbd_crypto_ctx {
 #define CRYPTO_CMACAES_TFM(c)	((c)->desc[CRYPTO_SHASH_CMACAES]->tfm)
 #define CRYPTO_SHA256_TFM(c)	((c)->desc[CRYPTO_SHASH_SHA256]->tfm)
 #define CRYPTO_SHA512_TFM(c)	((c)->desc[CRYPTO_SHASH_SHA512]->tfm)
+#define CRYPTO_MD4_TFM(c)	((c)->desc[CRYPTO_SHASH_MD4]->tfm)
+#define CRYPTO_MD5_TFM(c)	((c)->desc[CRYPTO_SHASH_MD5]->tfm)
 
 #define CRYPTO_GCM(c)		((c)->ccmaes[CRYPTO_AEAD_AES_GCM])
 #define CRYPTO_CCM(c)		((c)->ccmaes[CRYPTO_AEAD_AES_CCM])
@@ -58,6 +64,8 @@ struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_hmacsha256(void);
 struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_cmacaes(void);
 struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_sha512(void);
 struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_sha256(void);
+struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_md4(void);
+struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_md5(void);
 struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_gcm(void);
 struct ksmbd_crypto_ctx *ksmbd_crypto_ctx_find_ccm(void);
 void ksmbd_crypto_destroy(void);
diff --git a/fs/ksmbd/dkms.conf b/fs/ksmbd/dkms.conf
new file mode 100644
index 000000000000..61f057559ead
--- /dev/null
+++ b/fs/ksmbd/dkms.conf
@@ -0,0 +1,6 @@
+PACKAGE_NAME="ksmbd"
+PACKAGE_VERSION="@VERSION@"
+MAKE="'make' KDIR=$kernel_source_dir"
+BUILT_MODULE_NAME="ksmbd"
+DEST_MODULE_LOCATION="/kernel/fs/ksmbd"
+AUTOINSTALL="yes"
diff --git a/fs/ksmbd/glob.h b/fs/ksmbd/glob.h
index 5b8f3e0ebdb3..9bbd90431cc1 100644
--- a/fs/ksmbd/glob.h
+++ b/fs/ksmbd/glob.h
@@ -12,7 +12,7 @@
 #include "unicode.h"
 #include "vfs_cache.h"
 
-#define KSMBD_VERSION	"3.4.2"
+#define KSMBD_VERSION	"3.4.8"
 
 extern int ksmbd_debug_types;
 
@@ -46,4 +46,13 @@ extern int ksmbd_debug_types;
 
 #define UNICODE_LEN(x)		((x) * 2)
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+/* ksmbd misc functions */
+extern void ntstatus_to_dos(__le32 ntstatus, __u8 *eclass, __le16 *ecode);
+#endif
+
+#ifndef LOOKUP_NO_SYMLINKS
+#define LOOKUP_NO_SYMLINKS 0
+#endif
+
 #endif /* __KSMBD_GLOB_H */
diff --git a/fs/ksmbd/ksmbd.rst b/fs/ksmbd/ksmbd.rst
new file mode 100644
index 000000000000..438eca2ed278
--- /dev/null
+++ b/fs/ksmbd/ksmbd.rst
@@ -0,0 +1,183 @@
+.. SPDX-License-Identifier: GPL-2.0
+
+==========================
+KSMBD - SMB3 Kernel Server
+==========================
+
+ksmbd is a linux kernel server which implements SMB3 protocol in kernel space
+for sharing files over network.
+
+KSMBD architecture
+==================
+
+The subset of performance related operations belong in kernelspace and
+the other subset which belong to operations which are not really related with
+performance in userspace. So, DCE/RPC management that has historically resulted
+into number of buffer overflow issues and dangerous security bugs and user
+account management are implemented in user space as ksmbd.mountd.
+File operations that are related with performance (open/read/write/close etc.)
+in kernel space (ksmbd). This also allows for easier integration with VFS
+interface for all file operations.
+
+ksmbd (kernel daemon)
+---------------------
+
+When the server daemon is started, It starts up a forker thread
+(ksmbd/interface name) at initialization time and open a dedicated port 445
+for listening to SMB requests. Whenever new clients make request, Forker
+thread will accept the client connection and fork a new thread for dedicated
+communication channel between the client and the server. It allows for parallel
+processing of SMB requests(commands) from clients as well as allowing for new
+clients to make new connections. Each instance is named ksmbd/1~n(port number)
+to indicate connected clients. Depending on the SMB request types, each new
+thread can decide to pass through the commands to the user space (ksmbd.mountd),
+currently DCE/RPC commands are identified to be handled through the user space.
+To further utilize the linux kernel, it has been chosen to process the commands
+as workitems and to be executed in the handlers of the ksmbd-io kworker threads.
+It allows for multiplexing of the handlers as the kernel take care of initiating
+extra worker threads if the load is increased and vice versa, if the load is
+decreased it destroys the extra worker threads. So, after connection is
+established with client. Dedicated ksmbd/1..n(port number) takes complete
+ownership of receiving/parsing of SMB commands. Each received command is worked
+in parallel i.e., There can be multiple clients commands which are worked in
+parallel. After receiving each command a separated kernel workitem is prepared
+for each command which is further queued to be handled by ksmbd-io kworkers.
+So, each SMB workitem is queued to the kworkers. This allows the benefit of load
+sharing to be managed optimally by the default kernel and optimizing client
+performance by handling client commands in parallel.
+
+ksmbd.mountd (user space daemon)
+--------------------------------
+
+ksmbd.mountd is userspace process to, transfer user account and password that
+are registered using ksmbd.adduser(part of utils for user space). Further it
+allows sharing information parameters that parsed from smb.conf to ksmbd in
+kernel. For the execution part it has a daemon which is continuously running
+and connected to the kernel interface using netlink socket, it waits for the
+requests(dcerpc and share/user info). It handles RPC calls (at a minimum few
+dozen) that are most important for file server from NetShareEnum and
+NetServerGetInfo. Complete DCE/RPC response is prepared from the user space
+and passed over to the associated kernel thread for the client.
+
+
+KSMBD Feature Status
+====================
+
+============================== =================================================
+Feature name                   Status
+============================== =================================================
+Dialects                       Supported. SMB2.1 SMB3.0, SMB3.1.1 dialects
+                               (intentionally excludes security vulnerable SMB1
+                               dialect).
+Auto Negotiation               Supported.
+Compound Request               Supported.
+Oplock Cache Mechanism         Supported.
+SMB2 leases(v1 lease)          Supported.
+Directory leases(v2 lease)     Planned for future.
+Multi-credits                  Supported.
+NTLM/NTLMv2                    Supported.
+HMAC-SHA256 Signing            Supported.
+Secure negotiate               Supported.
+Signing Update                 Supported.
+Pre-authentication integrity   Supported.
+SMB3 encryption(CCM, GCM)      Supported. (CCM and GCM128 supported, GCM256 in
+                               progress)
+SMB direct(RDMA)               Partially Supported. SMB3 Multi-channel is
+                               required to connect to Windows client.
+SMB3 Multi-channel             Partially Supported. Planned to implement
+                               replay/retry mechanisms for future.
+SMB3.1.1 POSIX extension       Supported.
+ACLs                           Partially Supported. only DACLs available, SACLs
+                               (auditing) is planned for the future. For
+                               ownership (SIDs) ksmbd generates random subauth
+                               values(then store it to disk) and use uid/gid
+                               get from inode as RID for local domain SID.
+                               The current acl implementation is limited to
+                               standalone server, not a domain member.
+                               Integration with Samba tools is being worked on
+                               to allow future support for running as a domain
+                               member.
+Kerberos                       Supported.
+Durable handle v1,v2           Planned for future.
+Persistent handle              Planned for future.
+SMB2 notify                    Planned for future.
+Sparse file support            Supported.
+DCE/RPC support                Partially Supported. a few calls(NetShareEnumAll,
+                               NetServerGetInfo, SAMR, LSARPC) that are needed
+                               for file server handled via netlink interface
+                               from ksmbd.mountd. Additional integration with
+                               Samba tools and libraries via upcall is being
+                               investigated to allow support for additional
+                               DCE/RPC management calls (and future support
+                               for Witness protocol e.g.)
+ksmbd/nfsd interoperability    Planned for future. The features that ksmbd
+                               support are Leases, Notify, ACLs and Share modes.
+============================== =================================================
+
+
+How to run
+==========
+
+1. Download ksmbd-tools(https://github.com/cifsd-team/ksmbd-tools/releases) and
+   compile them.
+
+   - Refer README(https://github.com/cifsd-team/ksmbd-tools/blob/master/README.md)
+     to know how to use ksmbd.mountd/adduser/addshare/control utils
+
+     $ ./autogen.sh
+     $ ./configure --with-rundir=/run
+     $ make && sudo make install
+
+2. Create /usr/local/etc/ksmbd/ksmbd.conf file, add SMB share in ksmbd.conf file.
+
+   - Refer ksmbd.conf.example in ksmbd-utils, See ksmbd.conf manpage
+     for details to configure shares.
+
+        $ man ksmbd.conf
+
+3. Create user/password for SMB share.
+
+   - See ksmbd.adduser manpage.
+
+     $ man ksmbd.adduser
+     $ sudo ksmbd.adduser -a <Enter USERNAME for SMB share access>
+
+4. Insert ksmbd.ko module after build your kernel. No need to load module
+   if ksmbd is built into the kernel.
+
+   - Set ksmbd in menuconfig(e.g. $ make menuconfig)
+       [*] Network File Systems  --->
+           <M> SMB3 server support (EXPERIMENTAL)
+
+	$ sudo modprobe ksmbd.ko
+
+5. Start ksmbd user space daemon
+
+	$ sudo ksmbd.mountd
+
+6. Access share from Windows or Linux using SMB3 client (cifs.ko or smbclient of samba)
+
+Shutdown KSMBD
+==============
+
+1. kill user and kernel space daemon
+	# sudo ksmbd.control -s
+
+How to turn debug print on
+==========================
+
+Each layer
+/sys/class/ksmbd-control/debug
+
+1. Enable all component prints
+	# sudo ksmbd.control -d "all"
+
+2. Enable one of components(smb, auth, vfs, oplock, ipc, conn, rdma)
+	# sudo ksmbd.control -d "smb"
+
+3. Show what prints are enable.
+	# cat/sys/class/ksmbd-control/debug
+	  [smb] auth vfs oplock ipc conn [rdma]
+
+4. Disable prints:
+	If you try the selected component once more, It is disabled without brackets.
diff --git a/fs/ksmbd/ksmbd_netlink.h b/fs/ksmbd/ksmbd_netlink.h
index fb8b2d566efb..821ed8e3cbee 100644
--- a/fs/ksmbd/ksmbd_netlink.h
+++ b/fs/ksmbd/ksmbd_netlink.h
@@ -245,7 +245,7 @@ struct ksmbd_rpc_command {
 struct ksmbd_spnego_authen_request {
 	__u32	handle;
 	__u16	spnego_blob_len;	/* the length of spnego_blob */
-	__u8	spnego_blob[];		/*
+	__u8	spnego_blob[0];		/*
 					 * the GSS token from SecurityBuffer of
 					 * SMB2 SESSION SETUP request
 					 */
@@ -352,7 +352,8 @@ enum KSMBD_TREE_CONN_STATUS {
 #define KSMBD_SHARE_FLAG_STREAMS		BIT(11)
 #define KSMBD_SHARE_FLAG_FOLLOW_SYMLINKS	BIT(12)
 #define KSMBD_SHARE_FLAG_ACL_XATTR		BIT(13)
-#define KSMBD_SHARE_FLAG_UPDATE		BIT(14)
+#define KSMBD_SHARE_FLAG_UPDATE			BIT(14)
+#define KSMBD_SHARE_FLAG_CROSSMNT		BIT(15)
 
 /*
  * Tree connect request flags.
diff --git a/fs/ksmbd/ksmbd_work.c b/fs/ksmbd/ksmbd_work.c
index 14b9caebf7a4..33b675bee565 100644
--- a/fs/ksmbd/ksmbd_work.c
+++ b/fs/ksmbd/ksmbd_work.c
@@ -27,18 +27,41 @@ struct ksmbd_work *ksmbd_alloc_work_struct(void)
 		INIT_LIST_HEAD(&work->async_request_entry);
 		INIT_LIST_HEAD(&work->fp_entry);
 		INIT_LIST_HEAD(&work->interim_entry);
+		INIT_LIST_HEAD(&work->aux_read_list);
+		work->iov_alloc_cnt = 4;
+		work->iov = kzalloc(sizeof(struct kvec) * work->iov_alloc_cnt,
+				    GFP_KERNEL);
+		if (!work->iov) {
+			kmem_cache_free(work_cache, work);
+			work = NULL;
+		}
 	}
 	return work;
 }
 
 void ksmbd_free_work_struct(struct ksmbd_work *work)
 {
+	struct aux_read *ar, *tmp;
+
 	WARN_ON(work->saved_cred != NULL);
 
 	kvfree(work->response_buf);
+#ifdef CONFIG_SMB_INSECURE_SERVER
 	kvfree(work->aux_payload_buf);
+#endif
+
+	list_for_each_entry_safe(ar, tmp, &work->aux_read_list, entry) {
+		kvfree(ar->buf);
+		list_del(&ar->entry);
+		kfree(ar);
+	}
+
 	kfree(work->tr_buf);
 	kvfree(work->request_buf);
+	kfree(work->iov);
+	if (!list_empty(&work->interim_entry))
+		list_del(&work->interim_entry);
+
 	if (work->async_id)
 		ksmbd_release_id(&work->conn->async_ida, work->async_id);
 	kmem_cache_free(work_cache, work);
@@ -77,3 +100,81 @@ bool ksmbd_queue_work(struct ksmbd_work *work)
 {
 	return queue_work(ksmbd_wq, &work->work);
 }
+
+static inline void __ksmbd_iov_pin(struct ksmbd_work *work, void *ib,
+				   unsigned int ib_len)
+{
+	work->iov[++work->iov_idx].iov_base = ib;
+	work->iov[work->iov_idx].iov_len = ib_len;
+	work->iov_cnt++;
+}
+
+static int __ksmbd_iov_pin_rsp(struct ksmbd_work *work, void *ib, int len,
+			       void *aux_buf, unsigned int aux_size)
+{
+	struct aux_read *ar;
+	int need_iov_cnt = 1;
+
+	if (aux_size) {
+		need_iov_cnt++;
+		ar = kmalloc(sizeof(struct aux_read), GFP_KERNEL);
+		if (!ar)
+			return -ENOMEM;
+	}
+
+	if (work->iov_alloc_cnt < work->iov_cnt + need_iov_cnt) {
+		struct kvec *new;
+
+		work->iov_alloc_cnt += 4;
+		new = krealloc(work->iov,
+			       sizeof(struct kvec) * work->iov_alloc_cnt,
+			       GFP_KERNEL | __GFP_ZERO);
+		if (!new) {
+			kfree(ar);
+			work->iov_alloc_cnt -= 4;
+			return -ENOMEM;
+		}
+		work->iov = new;
+	}
+
+	/* Plus rfc_length size on first iov */
+	if (!work->iov_idx) {
+		work->iov[work->iov_idx].iov_base = work->response_buf;
+		*(__be32 *)work->iov[0].iov_base = 0;
+		work->iov[work->iov_idx].iov_len = 4;
+		work->iov_cnt++;
+	}
+
+	__ksmbd_iov_pin(work, ib, len);
+	inc_rfc1001_len(work->iov[0].iov_base, len);
+
+	if (aux_size) {
+		__ksmbd_iov_pin(work, aux_buf, aux_size);
+		inc_rfc1001_len(work->iov[0].iov_base, aux_size);
+
+		ar->buf = aux_buf;
+		list_add(&ar->entry, &work->aux_read_list);
+	}
+
+	return 0;
+}
+
+int ksmbd_iov_pin_rsp(struct ksmbd_work *work, void *ib, int len)
+{
+	return __ksmbd_iov_pin_rsp(work, ib, len, NULL, 0);
+}
+
+int ksmbd_iov_pin_rsp_read(struct ksmbd_work *work, void *ib, int len,
+			   void *aux_buf, unsigned int aux_size)
+{
+	return __ksmbd_iov_pin_rsp(work, ib, len, aux_buf, aux_size);
+}
+
+int allocate_interim_rsp_buf(struct ksmbd_work *work)
+{
+	work->response_buf = kzalloc(MAX_CIFS_SMALL_BUFFER_SIZE, GFP_KERNEL);
+	if (!work->response_buf)
+		return -ENOMEM;
+	work->response_sz = MAX_CIFS_SMALL_BUFFER_SIZE;
+	return 0;
+}
diff --git a/fs/ksmbd/ksmbd_work.h b/fs/ksmbd/ksmbd_work.h
index 5ece58e40c97..99016162ed34 100644
--- a/fs/ksmbd/ksmbd_work.h
+++ b/fs/ksmbd/ksmbd_work.h
@@ -19,6 +19,11 @@ enum {
 	KSMBD_WORK_CLOSED,
 };
 
+struct aux_read {
+	void *buf;
+	struct list_head entry;
+};
+
 /* one of these for every pending CIFS request at the connection */
 struct ksmbd_work {
 	/* Server corresponding to this mid */
@@ -31,13 +36,19 @@ struct ksmbd_work {
 	/* Response buffer */
 	void                            *response_buf;
 
-	/* Read data buffer */
-	void                            *aux_payload_buf;
+	struct list_head		aux_read_list;
+
+	struct kvec			*iov;
+	int				iov_alloc_cnt;
+	int				iov_cnt;
+	int				iov_idx;
 
 	/* Next cmd hdr in compound req buf*/
 	int                             next_smb2_rcv_hdr_off;
 	/* Next cmd hdr in compound rsp buf*/
 	int                             next_smb2_rsp_hdr_off;
+	/* Current cmd hdr in compound rsp buf*/
+	int                             curr_smb2_rsp_hdr_off;
 
 	/*
 	 * Current Local FID assigned compound response if SMB2 CREATE
@@ -53,22 +64,17 @@ struct ksmbd_work {
 	unsigned int			credits_granted;
 
 	/* response smb header size */
-	unsigned int                    resp_hdr_sz;
 	unsigned int                    response_sz;
-	/* Read data count */
-	unsigned int                    aux_payload_sz;
 
 	void				*tr_buf;
 
 	unsigned char			state;
-	/* Multiple responses for one request e.g. SMB ECHO */
-	bool                            multiRsp:1;
 	/* No response for cancelled request */
 	bool                            send_no_response:1;
 	/* Request is encrypted */
 	bool                            encrypted:1;
 	/* Is this SYNC or ASYNC ksmbd_work */
-	bool                            syncronous:1;
+	bool                            asynchronous:1;
 	bool                            need_invalidate_rkey:1;
 
 	unsigned int                    remote_key;
@@ -84,6 +90,15 @@ struct ksmbd_work {
 	struct list_head                async_request_entry;
 	struct list_head                fp_entry;
 	struct list_head                interim_entry;
+
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	/* Read data buffer */
+	void                            *aux_payload_buf;
+	/* Read data count */
+	unsigned int                    aux_payload_sz;
+	/* response smb header size */
+	unsigned int                    resp_hdr_sz;
+#endif
 };
 
 /**
@@ -95,6 +110,15 @@ static inline void *ksmbd_resp_buf_next(struct ksmbd_work *work)
 	return work->response_buf + work->next_smb2_rsp_hdr_off + 4;
 }
 
+/**
+ * ksmbd_resp_buf_curr - Get current buffer on compound response.
+ * @work: smb work containing response buffer
+ */
+static inline void *ksmbd_resp_buf_curr(struct ksmbd_work *work)
+{
+	return work->response_buf + work->curr_smb2_rsp_hdr_off + 4;
+}
+
 /**
  * ksmbd_req_buf_next - Get next buffer on compound request.
  * @work: smb work containing response buffer
@@ -113,5 +137,8 @@ int ksmbd_work_pool_init(void);
 int ksmbd_workqueue_init(void);
 void ksmbd_workqueue_destroy(void);
 bool ksmbd_queue_work(struct ksmbd_work *work);
-
+int ksmbd_iov_pin_rsp_read(struct ksmbd_work *work, void *ib, int len,
+			   void *aux_buf, unsigned int aux_size);
+int ksmbd_iov_pin_rsp(struct ksmbd_work *work, void *ib, int len);
+int allocate_interim_rsp_buf(struct ksmbd_work *work);
 #endif /* __KSMBD_WORK_H__ */
diff --git a/fs/ksmbd/mgmt/ksmbd_ida.c b/fs/ksmbd/mgmt/ksmbd_ida.c
index 54194d959a5e..f70833c81997 100644
--- a/fs/ksmbd/mgmt/ksmbd_ida.c
+++ b/fs/ksmbd/mgmt/ksmbd_ida.c
@@ -10,14 +10,25 @@ static inline int __acquire_id(struct ida *ida, int from, int to)
 	return ida_simple_get(ida, from, to, GFP_KERNEL);
 }
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+int ksmbd_acquire_smb1_tid(struct ida *ida)
+{
+	return __acquire_id(ida, 1, 0xFFFF);
+}
+#endif
+
 int ksmbd_acquire_smb2_tid(struct ida *ida)
 {
-	int id;
+	return __acquire_id(ida, 1, 0xFFFFFFFF);
 
-	id = __acquire_id(ida, 1, 0xFFFFFFFF);
+}
 
-	return id;
+#ifdef CONFIG_SMB_INSECURE_SERVER
+int ksmbd_acquire_smb1_uid(struct ida *ida)
+{
+	return __acquire_id(ida, 1, 0xFFFE);
 }
+#endif
 
 int ksmbd_acquire_smb2_uid(struct ida *ida)
 {
diff --git a/fs/ksmbd/mgmt/ksmbd_ida.h b/fs/ksmbd/mgmt/ksmbd_ida.h
index 2bc07b16cfde..e7df7786f431 100644
--- a/fs/ksmbd/mgmt/ksmbd_ida.h
+++ b/fs/ksmbd/mgmt/ksmbd_ida.h
@@ -16,6 +16,9 @@
  *    The value 0xFFFF is used to specify all TIDs or no TID,
  *    depending upon the context in which it is used.
  */
+#ifdef CONFIG_SMB_INSECURE_SERVER
+int ksmbd_acquire_smb1_tid(struct ida *ida);
+#endif
 int ksmbd_acquire_smb2_tid(struct ida *ida);
 
 /*
@@ -25,6 +28,9 @@ int ksmbd_acquire_smb2_tid(struct ida *ida);
  *    valid UID.<21> All other possible values for a UID, excluding
  *    zero (0x0000), are valid.
  */
+#ifdef CONFIG_SMB_INSECURE_SERVER
+int ksmbd_acquire_smb1_uid(struct ida *ida);
+#endif
 int ksmbd_acquire_smb2_uid(struct ida *ida);
 int ksmbd_acquire_async_msg_id(struct ida *ida);
 
diff --git a/fs/ksmbd/mgmt/share_config.h b/fs/ksmbd/mgmt/share_config.h
index 3fd338293942..5f591751b923 100644
--- a/fs/ksmbd/mgmt/share_config.h
+++ b/fs/ksmbd/mgmt/share_config.h
@@ -34,29 +34,22 @@ struct ksmbd_share_config {
 #define KSMBD_SHARE_INVALID_UID	((__u16)-1)
 #define KSMBD_SHARE_INVALID_GID	((__u16)-1)
 
-static inline int share_config_create_mode(struct ksmbd_share_config *share,
-					   umode_t posix_mode)
+static inline umode_t
+share_config_create_mode(struct ksmbd_share_config *share,
+			 umode_t posix_mode)
 {
-	if (!share->force_create_mode) {
-		if (!posix_mode)
-			return share->create_mask;
-		else
-			return posix_mode & share->create_mask;
-	}
-	return share->force_create_mode & share->create_mask;
+	umode_t mode = (posix_mode ?: (umode_t)-1) & share->create_mask;
+
+	return mode | share->force_create_mode;
 }
 
-static inline int share_config_directory_mode(struct ksmbd_share_config *share,
-					      umode_t posix_mode)
+static inline umode_t
+share_config_directory_mode(struct ksmbd_share_config *share,
+			    umode_t posix_mode)
 {
-	if (!share->force_directory_mode) {
-		if (!posix_mode)
-			return share->directory_mask;
-		else
-			return posix_mode & share->directory_mask;
-	}
+	umode_t mode = (posix_mode ?: (umode_t)-1) & share->directory_mask;
 
-	return share->force_directory_mode & share->directory_mask;
+	return mode | share->force_directory_mode;
 }
 
 static inline int test_share_config_flag(struct ksmbd_share_config *share,
diff --git a/fs/ksmbd/mgmt/tree_connect.c b/fs/ksmbd/mgmt/tree_connect.c
index f07a05f37651..d2c81a8a11dd 100644
--- a/fs/ksmbd/mgmt/tree_connect.c
+++ b/fs/ksmbd/mgmt/tree_connect.c
@@ -73,7 +73,10 @@ ksmbd_tree_conn_connect(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 
 	tree_conn->user = sess->user;
 	tree_conn->share_conf = sc;
+	tree_conn->t_state = TREE_NEW;
 	status.tree_conn = tree_conn;
+	atomic_set(&tree_conn->refcount, 1);
+	init_waitqueue_head(&tree_conn->refcount_q);
 
 	ret = xa_err(xa_store(&sess->tree_conns, tree_conn->id, tree_conn,
 			      GFP_KERNEL));
@@ -93,14 +96,33 @@ ksmbd_tree_conn_connect(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 	return status;
 }
 
+void ksmbd_tree_connect_put(struct ksmbd_tree_connect *tcon)
+{
+	/*
+	 * Checking waitqueue to releasing tree connect on
+	 * tree disconnect. waitqueue_active is safe because it
+	 * uses atomic operation for condition.
+	 */
+	if (!atomic_dec_return(&tcon->refcount) &&
+	    waitqueue_active(&tcon->refcount_q))
+		wake_up(&tcon->refcount_q);
+}
+
 int ksmbd_tree_conn_disconnect(struct ksmbd_session *sess,
 			       struct ksmbd_tree_connect *tree_conn)
 {
 	int ret;
 
+	write_lock(&sess->tree_conns_lock);
+	xa_erase(&sess->tree_conns, tree_conn->id);
+	write_unlock(&sess->tree_conns_lock);
+
+	if (!atomic_dec_and_test(&tree_conn->refcount))
+		wait_event(tree_conn->refcount_q,
+			   atomic_read(&tree_conn->refcount) == 0);
+
 	ret = ksmbd_ipc_tree_disconnect_request(sess->id, tree_conn->id);
 	ksmbd_release_tree_conn_id(sess, tree_conn->id);
-	xa_erase(&sess->tree_conns, tree_conn->id);
 	ksmbd_share_config_put(tree_conn->share_conf);
 	kfree(tree_conn);
 	return ret;
@@ -111,26 +133,19 @@ struct ksmbd_tree_connect *ksmbd_tree_conn_lookup(struct ksmbd_session *sess,
 {
 	struct ksmbd_tree_connect *tcon;
 
+	read_lock(&sess->tree_conns_lock);
 	tcon = xa_load(&sess->tree_conns, id);
 	if (tcon) {
-		if (test_bit(TREE_CONN_EXPIRE, &tcon->status))
+		if (tcon->t_state != TREE_CONNECTED)
+			tcon = NULL;
+		else if (!atomic_inc_not_zero(&tcon->refcount))
 			tcon = NULL;
 	}
+	read_unlock(&sess->tree_conns_lock);
 
 	return tcon;
 }
 
-struct ksmbd_share_config *ksmbd_tree_conn_share(struct ksmbd_session *sess,
-						 unsigned int id)
-{
-	struct ksmbd_tree_connect *tc;
-
-	tc = ksmbd_tree_conn_lookup(sess, id);
-	if (tc)
-		return tc->share_conf;
-	return NULL;
-}
-
 int ksmbd_tree_conn_session_logoff(struct ksmbd_session *sess)
 {
 	int ret = 0;
@@ -140,8 +155,18 @@ int ksmbd_tree_conn_session_logoff(struct ksmbd_session *sess)
 	if (!sess)
 		return -EINVAL;
 
-	xa_for_each(&sess->tree_conns, id, tc)
+	xa_for_each(&sess->tree_conns, id, tc) {
+		write_lock(&sess->tree_conns_lock);
+		if (tc->t_state == TREE_DISCONNECTED) {
+			write_unlock(&sess->tree_conns_lock);
+			ret = -ENOENT;
+			continue;
+		}
+		tc->t_state = TREE_DISCONNECTED;
+		write_unlock(&sess->tree_conns_lock);
+
 		ret |= ksmbd_tree_conn_disconnect(sess, tc);
+	}
 	xa_destroy(&sess->tree_conns);
 	return ret;
 }
diff --git a/fs/ksmbd/mgmt/tree_connect.h b/fs/ksmbd/mgmt/tree_connect.h
index 700df36cf3e3..6377a70b811c 100644
--- a/fs/ksmbd/mgmt/tree_connect.h
+++ b/fs/ksmbd/mgmt/tree_connect.h
@@ -14,7 +14,11 @@ struct ksmbd_share_config;
 struct ksmbd_user;
 struct ksmbd_conn;
 
-#define TREE_CONN_EXPIRE		1
+enum {
+	TREE_NEW = 0,
+	TREE_CONNECTED,
+	TREE_DISCONNECTED
+};
 
 struct ksmbd_tree_connect {
 	int				id;
@@ -27,7 +31,9 @@ struct ksmbd_tree_connect {
 
 	int				maximal_access;
 	bool				posix_extensions;
-	unsigned long			status;
+	atomic_t			refcount;
+	wait_queue_head_t		refcount_q;
+	unsigned int			t_state;
 };
 
 struct ksmbd_tree_conn_status {
@@ -46,6 +52,7 @@ struct ksmbd_session;
 struct ksmbd_tree_conn_status
 ksmbd_tree_conn_connect(struct ksmbd_conn *conn, struct ksmbd_session *sess,
 			const char *share_name);
+void ksmbd_tree_connect_put(struct ksmbd_tree_connect *tcon);
 
 int ksmbd_tree_conn_disconnect(struct ksmbd_session *sess,
 			       struct ksmbd_tree_connect *tree_conn);
@@ -53,9 +60,6 @@ int ksmbd_tree_conn_disconnect(struct ksmbd_session *sess,
 struct ksmbd_tree_connect *ksmbd_tree_conn_lookup(struct ksmbd_session *sess,
 						  unsigned int id);
 
-struct ksmbd_share_config *ksmbd_tree_conn_share(struct ksmbd_session *sess,
-						 unsigned int id);
-
 int ksmbd_tree_conn_session_logoff(struct ksmbd_session *sess);
 
 #endif /* __TREE_CONNECT_MANAGEMENT_H__ */
diff --git a/fs/ksmbd/mgmt/user_config.h b/fs/ksmbd/mgmt/user_config.h
index 6a44109617f1..e068a19fd904 100644
--- a/fs/ksmbd/mgmt/user_config.h
+++ b/fs/ksmbd/mgmt/user_config.h
@@ -18,7 +18,6 @@ struct ksmbd_user {
 
 	size_t			passkey_sz;
 	char			*passkey;
-	unsigned int		failed_login_count;
 };
 
 static inline bool user_guest(struct ksmbd_user *user)
diff --git a/fs/ksmbd/mgmt/user_session.c b/fs/ksmbd/mgmt/user_session.c
index ea4b56d570fb..50936fadc31a 100644
--- a/fs/ksmbd/mgmt/user_session.c
+++ b/fs/ksmbd/mgmt/user_session.c
@@ -25,7 +25,6 @@ static DECLARE_RWSEM(sessions_table_lock);
 struct ksmbd_session_rpc {
 	int			id;
 	unsigned int		method;
-	struct list_head	list;
 };
 
 static void free_channel_list(struct ksmbd_session *sess)
@@ -58,15 +57,14 @@ static void __session_rpc_close(struct ksmbd_session *sess,
 static void ksmbd_session_rpc_clear_list(struct ksmbd_session *sess)
 {
 	struct ksmbd_session_rpc *entry;
+	long index;
 
-	while (!list_empty(&sess->rpc_handle_list)) {
-		entry = list_entry(sess->rpc_handle_list.next,
-				   struct ksmbd_session_rpc,
-				   list);
-
-		list_del(&entry->list);
+	xa_for_each(&sess->rpc_handle_list, index, entry) {
+		xa_erase(&sess->rpc_handle_list, index);
 		__session_rpc_close(sess, entry);
 	}
+
+	xa_destroy(&sess->rpc_handle_list);
 }
 
 static int __rpc_method(char *rpc_name)
@@ -102,13 +100,13 @@ int ksmbd_session_rpc_open(struct ksmbd_session *sess, char *rpc_name)
 
 	entry = kzalloc(sizeof(struct ksmbd_session_rpc), GFP_KERNEL);
 	if (!entry)
-		return -EINVAL;
+		return -ENOMEM;
 
-	list_add(&entry->list, &sess->rpc_handle_list);
 	entry->method = method;
 	entry->id = ksmbd_ipc_id_alloc();
 	if (entry->id < 0)
 		goto free_entry;
+	xa_store(&sess->rpc_handle_list, entry->id, entry, GFP_KERNEL);
 
 	resp = ksmbd_rpc_open(sess, entry->id);
 	if (!resp)
@@ -117,9 +115,9 @@ int ksmbd_session_rpc_open(struct ksmbd_session *sess, char *rpc_name)
 	kvfree(resp);
 	return entry->id;
 free_id:
+	xa_erase(&sess->rpc_handle_list, entry->id);
 	ksmbd_rpc_id_free(entry->id);
 free_entry:
-	list_del(&entry->list);
 	kfree(entry);
 	return -EINVAL;
 }
@@ -128,24 +126,17 @@ void ksmbd_session_rpc_close(struct ksmbd_session *sess, int id)
 {
 	struct ksmbd_session_rpc *entry;
 
-	list_for_each_entry(entry, &sess->rpc_handle_list, list) {
-		if (entry->id == id) {
-			list_del(&entry->list);
-			__session_rpc_close(sess, entry);
-			break;
-		}
-	}
+	entry = xa_erase(&sess->rpc_handle_list, id);
+	if (entry)
+		__session_rpc_close(sess, entry);
 }
 
 int ksmbd_session_rpc_method(struct ksmbd_session *sess, int id)
 {
 	struct ksmbd_session_rpc *entry;
 
-	list_for_each_entry(entry, &sess->rpc_handle_list, list) {
-		if (entry->id == id)
-			return entry->method;
-	}
-	return 0;
+	entry = xa_load(&sess->rpc_handle_list, id);
+	return entry ? entry->method : 0;
 }
 
 void ksmbd_session_destroy(struct ksmbd_session *sess)
@@ -183,18 +174,23 @@ static void ksmbd_expire_session(struct ksmbd_conn *conn)
 	unsigned long id;
 	struct ksmbd_session *sess;
 
-	down_write(&sessions_table_lock);
+	down_write(&conn->session_lock);
 	xa_for_each(&conn->sessions, id, sess) {
 		if (sess->state != SMB2_SESSION_VALID ||
 		    time_after(jiffies,
 			       sess->last_active + SMB2_SESSION_TIMEOUT)) {
 			xa_erase(&conn->sessions, sess->id);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+			if (hash_hashed(&sess->hlist))
+				hash_del(&sess->hlist);
+#else
 			hash_del(&sess->hlist);
+#endif
 			ksmbd_session_destroy(sess);
 			continue;
 		}
 	}
-	up_write(&sessions_table_lock);
+	up_write(&conn->session_lock);
 }
 
 int ksmbd_session_register(struct ksmbd_conn *conn,
@@ -231,12 +227,19 @@ void ksmbd_sessions_deregister(struct ksmbd_conn *conn)
 		hash_for_each_safe(sessions_table, bkt, tmp, sess, hlist) {
 			if (!ksmbd_chann_del(conn, sess) &&
 			    xa_empty(&sess->ksmbd_chann_list)) {
+#ifdef CONFIG_SMB_INSECURE_SERVER
+			if (hash_hashed(&sess->hlist))
+				hash_del(&sess->hlist);
+#else
 				hash_del(&sess->hlist);
+#endif
 				ksmbd_session_destroy(sess);
 			}
 		}
 	}
+	up_write(&sessions_table_lock);
 
+	down_write(&conn->session_lock);
 	xa_for_each(&conn->sessions, id, sess) {
 		unsigned long chann_id;
 		struct channel *chann;
@@ -249,11 +252,16 @@ void ksmbd_sessions_deregister(struct ksmbd_conn *conn)
 		ksmbd_chann_del(conn, sess);
 		if (xa_empty(&sess->ksmbd_chann_list)) {
 			xa_erase(&conn->sessions, sess->id);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+			if (hash_hashed(&sess->hlist))
+				hash_del(&sess->hlist);
+#else
 			hash_del(&sess->hlist);
+#endif
 			ksmbd_session_destroy(sess);
 		}
 	}
-	up_write(&sessions_table_lock);
+	up_write(&conn->session_lock);
 }
 
 struct ksmbd_session *ksmbd_session_lookup(struct ksmbd_conn *conn,
@@ -261,9 +269,11 @@ struct ksmbd_session *ksmbd_session_lookup(struct ksmbd_conn *conn,
 {
 	struct ksmbd_session *sess;
 
+	down_read(&conn->session_lock);
 	sess = xa_load(&conn->sessions, id);
 	if (sess)
 		sess->last_active = jiffies;
+	up_read(&conn->session_lock);
 	return sess;
 }
 
@@ -328,6 +338,18 @@ struct preauth_session *ksmbd_preauth_session_lookup(struct ksmbd_conn *conn,
 	return NULL;
 }
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+static int __init_smb1_session(struct ksmbd_session *sess)
+{
+	int id = ksmbd_acquire_smb1_uid(&session_ida);
+
+	if (id < 0)
+		return -EINVAL;
+	sess->id = id;
+	return 0;
+}
+#endif
+
 static int __init_smb2_session(struct ksmbd_session *sess)
 {
 	int id = ksmbd_acquire_smb2_uid(&session_ida);
@@ -343,9 +365,6 @@ static struct ksmbd_session *__session_create(int protocol)
 	struct ksmbd_session *sess;
 	int ret;
 
-	if (protocol != CIFDS_SESSION_FLAG_SMB2)
-		return NULL;
-
 	sess = kzalloc(sizeof(struct ksmbd_session), GFP_KERNEL);
 	if (!sess)
 		return NULL;
@@ -358,10 +377,24 @@ static struct ksmbd_session *__session_create(int protocol)
 	set_session_flag(sess, protocol);
 	xa_init(&sess->tree_conns);
 	xa_init(&sess->ksmbd_chann_list);
-	INIT_LIST_HEAD(&sess->rpc_handle_list);
+	xa_init(&sess->rpc_handle_list);
 	sess->sequence_number = 1;
+	rwlock_init(&sess->tree_conns_lock);
+
+	switch (protocol) {
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	case CIFDS_SESSION_FLAG_SMB1:
+		ret = __init_smb1_session(sess);
+		break;
+#endif
+	case CIFDS_SESSION_FLAG_SMB2:
+		ret = __init_smb2_session(sess);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
 
-	ret = __init_smb2_session(sess);
 	if (ret)
 		goto error;
 
@@ -378,6 +411,13 @@ static struct ksmbd_session *__session_create(int protocol)
 	return NULL;
 }
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+struct ksmbd_session *ksmbd_smb1_session_create(void)
+{
+	return __session_create(CIFDS_SESSION_FLAG_SMB1);
+}
+#endif
+
 struct ksmbd_session *ksmbd_smb2_session_create(void)
 {
 	return __session_create(CIFDS_SESSION_FLAG_SMB2);
@@ -387,6 +427,10 @@ int ksmbd_acquire_tree_conn_id(struct ksmbd_session *sess)
 {
 	int id = -EINVAL;
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (test_session_flag(sess, CIFDS_SESSION_FLAG_SMB1))
+		id = ksmbd_acquire_smb1_tid(&sess->tree_conn_ida);
+#endif
 	if (test_session_flag(sess, CIFDS_SESSION_FLAG_SMB2))
 		id = ksmbd_acquire_smb2_tid(&sess->tree_conn_ida);
 
diff --git a/fs/ksmbd/mgmt/user_session.h b/fs/ksmbd/mgmt/user_session.h
index 51f38e5b61ab..c5d5bbe759ae 100644
--- a/fs/ksmbd/mgmt/user_session.h
+++ b/fs/ksmbd/mgmt/user_session.h
@@ -12,6 +12,9 @@
 #include "../smb_common.h"
 #include "../ntlmssp.h"
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+#define CIFDS_SESSION_FLAG_SMB1		BIT(0)
+#endif
 #define CIFDS_SESSION_FLAG_SMB2		BIT(1)
 
 #define PREAUTH_HASHVALUE_SIZE		64
@@ -52,7 +55,7 @@ struct ksmbd_session {
 	struct xarray			ksmbd_chann_list;
 	struct xarray			tree_conns;
 	struct ida			tree_conn_ida;
-	struct list_head		rpc_handle_list;
+	struct xarray			rpc_handle_list;
 
 	__u8				smb3encryptionkey[SMB3_ENC_DEC_KEY_SIZE];
 	__u8				smb3decryptionkey[SMB3_ENC_DEC_KEY_SIZE];
@@ -60,6 +63,7 @@ struct ksmbd_session {
 
 	struct ksmbd_file_table		file_table;
 	unsigned long			last_active;
+	rwlock_t			tree_conns_lock;
 };
 
 static inline int test_session_flag(struct ksmbd_session *sess, int bit)
@@ -77,6 +81,9 @@ static inline void clear_session_flag(struct ksmbd_session *sess, int bit)
 	sess->flags &= ~bit;
 }
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+struct ksmbd_session *ksmbd_smb1_session_create(void);
+#endif
 struct ksmbd_session *ksmbd_smb2_session_create(void);
 
 void ksmbd_session_destroy(struct ksmbd_session *sess);
diff --git a/fs/ksmbd/misc.c b/fs/ksmbd/misc.c
index 9e8afaa686e3..88b39e3b400e 100644
--- a/fs/ksmbd/misc.c
+++ b/fs/ksmbd/misc.c
@@ -5,6 +5,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/version.h>
 #include <linux/xattr.h>
 #include <linux/fs.h>
 #include <linux/unicode.h>
@@ -283,6 +284,7 @@ char *ksmbd_extract_sharename(struct unicode_map *um, const char *treename)
  *
  * Return:	converted name on success, otherwise NULL
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
 char *convert_to_unix_name(struct ksmbd_share_config *share, const char *name)
 {
 	int no_slash = 0, name_len, path_len;
@@ -308,6 +310,111 @@ char *convert_to_unix_name(struct ksmbd_share_config *share, const char *name)
 	new_name[path_len] = 0x00;
 	return new_name;
 }
+#else
+static char *normalize_path(const char *path)
+{
+	size_t path_len, remain_path_len, out_path_len;
+	char *out_path, *out_next;
+	int i, pre_dotdot_cnt = 0, slash_cnt = 0;
+	bool is_last;
+
+	path_len = strlen(path);
+	remain_path_len = path_len;
+
+	out_path = kzalloc(path_len + 2, GFP_KERNEL);
+	if (!out_path)
+		return ERR_PTR(-ENOMEM);
+	out_path_len = 0;
+	out_next = out_path;
+
+	do {
+		const char *name = path + path_len - remain_path_len;
+		char *next = strchrnul(name, '/');
+		size_t name_len = next - name;
+
+		is_last = !next[0];
+		if (name_len == 2 && name[0] == '.' && name[1] == '.') {
+			pre_dotdot_cnt++;
+			/* handle the case that path ends with "/.." */
+			if (is_last)
+				goto follow_dotdot;
+		} else {
+			if (pre_dotdot_cnt) {
+follow_dotdot:
+				slash_cnt = 0;
+				for (i = out_path_len - 1; i >= 0; i--) {
+					if (out_path[i] == '/' &&
+					    ++slash_cnt == pre_dotdot_cnt + 1)
+						break;
+				}
+
+				if (i < 0 &&
+				    slash_cnt != pre_dotdot_cnt) {
+					kfree(out_path);
+					return ERR_PTR(-EINVAL);
+				}
+
+				out_next = &out_path[i+1];
+				*out_next = '\0';
+				out_path_len = i + 1;
+
+			}
+
+			if (name_len != 0 &&
+			    !(name_len == 1 && name[0] == '.') &&
+			    !(name_len == 2 && name[0] == '.' && name[1] == '.')) {
+				next[0] = '\0';
+				sprintf(out_next, "%s/", name);
+				out_next += name_len + 1;
+				out_path_len += name_len + 1;
+				if (!is_last)
+					next[0] = '/';
+			}
+			pre_dotdot_cnt = 0;
+		}
+
+		remain_path_len -= name_len + 1;
+	} while (!is_last);
+
+	if (out_path_len > 0)
+		out_path[out_path_len-1] = '\0';
+	return out_path;
+}
+
+char *convert_to_unix_name(struct ksmbd_share_config *share, const char *name)
+{
+	int no_slash = 0, name_len, path_len;
+	char *new_name, *norm_name;
+
+	if (name[0] == '/')
+		name++;
+
+	norm_name = normalize_path(name);
+	if (IS_ERR(norm_name))
+		return norm_name;
+
+	path_len = share->path_sz;
+	name_len = strlen(norm_name);
+	new_name = kmalloc(path_len + name_len + 2, GFP_KERNEL);
+	if (!new_name) {
+		kfree(norm_name);
+		return new_name;
+	}
+
+	memcpy(new_name, share->path, path_len);
+	if (new_name[path_len - 1] != '/') {
+		new_name[path_len] = '/';
+		no_slash = 1;
+	}
+
+	memcpy(new_name + path_len + no_slash, norm_name, name_len);
+	path_len += name_len + no_slash;
+	new_name[path_len] = 0x00;
+	kfree(norm_name);
+
+	return new_name;
+}
+#endif
 
 char *ksmbd_convert_dir_info_name(struct ksmbd_dir_info *d_info,
 				  const struct nls_table *local_nls,
diff --git a/fs/ksmbd/ndr.c b/fs/ksmbd/ndr.c
index 4d9e0b54e3db..16303392a043 100644
--- a/fs/ksmbd/ndr.c
+++ b/fs/ksmbd/ndr.c
@@ -229,8 +229,7 @@ int ndr_encode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da)
 int ndr_decode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da)
 {
 	char hex_attr[12];
-	unsigned int version2;
-	int ret;
+	unsigned int version2, ret;
 
 	n->offset = 0;
 	ret = ndr_read_string(n, hex_attr, sizeof(hex_attr));
@@ -338,15 +337,21 @@ static int ndr_encode_posix_acl_entry(struct ndr *n, struct xattr_smb_acl *acl)
 }
 
 int ndr_encode_posix_acl(struct ndr *n,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			 struct mnt_idmap *idmap,
+#else
 			 struct user_namespace *user_ns,
+#endif
 			 struct inode *inode,
 			 struct xattr_smb_acl *acl,
 			 struct xattr_smb_acl *def_acl)
 {
 	unsigned int ref_id = 0x00020000;
 	int ret;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	vfsuid_t vfsuid;
 	vfsgid_t vfsgid;
+#endif
 
 	n->offset = 0;
 	n->length = 1024;
@@ -374,14 +379,41 @@ int ndr_encode_posix_acl(struct ndr *n,
 	if (ret)
 		return ret;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsuid = i_uid_into_vfsuid(idmap, inode);
+#else
 	vfsuid = i_uid_into_vfsuid(user_ns, inode);
+#endif
 	ret = ndr_write_int64(n, from_kuid(&init_user_ns, vfsuid_into_kuid(vfsuid)));
+#else
+	ret = ndr_write_int64(n, from_kuid(&init_user_ns, i_uid_into_mnt(user_ns, inode)));
+#endif
 	if (ret)
 		return ret;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsgid = i_gid_into_vfsgid(idmap, inode);
+#else
 	vfsgid = i_gid_into_vfsgid(user_ns, inode);
+#endif
 	ret = ndr_write_int64(n, from_kgid(&init_user_ns, vfsgid_into_kgid(vfsgid)));
+#else
+	ret = ndr_write_int64(n, from_kgid(&init_user_ns, i_gid_into_mnt(user_ns, inode)));
+#endif
+	if (ret)
+		return ret;
+#else
+	ret = ndr_write_int64(n, from_kuid(&init_user_ns, inode->i_uid));
+	if (ret)
+		return ret;
+
+	ret = ndr_write_int64(n, from_kgid(&init_user_ns, inode->i_gid));
 	if (ret)
 		return ret;
+#endif
 	ret = ndr_write_int32(n, inode->i_mode);
 	if (ret)
 		return ret;
diff --git a/fs/ksmbd/ndr.h b/fs/ksmbd/ndr.h
index 60ca265d1bb0..a300c0f6c814 100644
--- a/fs/ksmbd/ndr.h
+++ b/fs/ksmbd/ndr.h
@@ -14,7 +14,11 @@ struct ndr {
 
 int ndr_encode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da);
 int ndr_decode_dos_attr(struct ndr *n, struct xattr_dos_attrib *da);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ndr_encode_posix_acl(struct ndr *n, struct mnt_idmap *idmap,
+#else
 int ndr_encode_posix_acl(struct ndr *n, struct user_namespace *user_ns,
+#endif
 			 struct inode *inode, struct xattr_smb_acl *acl,
 			 struct xattr_smb_acl *def_acl);
 int ndr_encode_v4_ntacl(struct ndr *n, struct xattr_ntacl *acl);
diff --git a/fs/ksmbd/netmisc.c b/fs/ksmbd/netmisc.c
new file mode 100644
index 000000000000..155c15a94616
--- /dev/null
+++ b/fs/ksmbd/netmisc.c
@@ -0,0 +1,606 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *   Copyright (c) International Business Machines  Corp., 2002,2008
+ *   Author(s): Steve French (sfrench@us.ibm.com)
+ *
+ *   Error mapping routines from Samba libsmb/errormap.c
+ *   Copyright (C) Andrew Tridgell 2001
+ */
+
+#include "glob.h"
+#include "smberr.h"
+#include "nterr.h"
+#include "smb_common.h"
+
+/*****************************************************************************
+ * convert a NT status code to a dos class/code
+ *****************************************************************************/
+/* NT status -> dos error map */
+static const struct {
+	__u8 dos_class;
+	__u16 dos_code;
+	__u32 ntstatus;
+} ntstatus_to_dos_map[] = {
+	{
+	ERRDOS, ERRgeneral, NT_STATUS_UNSUCCESSFUL}, {
+	ERRDOS, ERRbadfunc, NT_STATUS_NOT_IMPLEMENTED}, {
+	ERRDOS, ERRinvlevel, NT_STATUS_INVALID_INFO_CLASS}, {
+	ERRDOS, 24, NT_STATUS_INFO_LENGTH_MISMATCH}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ACCESS_VIOLATION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_IN_PAGE_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PAGEFILE_QUOTA}, {
+	ERRDOS, ERRbadfid, NT_STATUS_INVALID_HANDLE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_INITIAL_STACK}, {
+	ERRDOS, 193, NT_STATUS_BAD_INITIAL_PC}, {
+	ERRDOS, 87, NT_STATUS_INVALID_CID}, {
+	ERRHRD, ERRgeneral, NT_STATUS_TIMER_NOT_CANCELED}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER}, {
+	ERRDOS, ERRbadfile, NT_STATUS_NO_SUCH_DEVICE}, {
+	ERRDOS, ERRbadfile, NT_STATUS_NO_SUCH_FILE}, {
+	ERRDOS, ERRbadfunc, NT_STATUS_INVALID_DEVICE_REQUEST}, {
+	ERRDOS, 38, NT_STATUS_END_OF_FILE}, {
+	ERRDOS, 34, NT_STATUS_WRONG_VOLUME}, {
+	ERRDOS, 21, NT_STATUS_NO_MEDIA_IN_DEVICE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNRECOGNIZED_MEDIA}, {
+	ERRDOS, 27, NT_STATUS_NONEXISTENT_SECTOR},
+/*	{ This NT error code was 'sqashed'
+ *	 from NT_STATUS_MORE_PROCESSING_REQUIRED to NT_STATUS_OK
+ *	 during the session setup }
+ */
+	{
+	ERRDOS, ERRnomem, NT_STATUS_NO_MEMORY}, {
+	ERRDOS, 487, NT_STATUS_CONFLICTING_ADDRESSES}, {
+	ERRDOS, 487, NT_STATUS_NOT_MAPPED_VIEW}, {
+	ERRDOS, 87, NT_STATUS_UNABLE_TO_FREE_VM}, {
+	ERRDOS, 87, NT_STATUS_UNABLE_TO_DELETE_SECTION}, {
+	ERRDOS, 2142, NT_STATUS_INVALID_SYSTEM_SERVICE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ILLEGAL_INSTRUCTION}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_INVALID_LOCK_SEQUENCE}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_INVALID_VIEW_SIZE}, {
+	ERRDOS, 193, NT_STATUS_INVALID_FILE_FOR_SECTION}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_ALREADY_COMMITTED},
+/*	{ This NT error code was 'sqashed'
+ *	 from NT_STATUS_ACCESS_DENIED to NT_STATUS_TRUSTED_RELATIONSHIP_FAILURE
+ *	 during the session setup }
+ */
+	{
+	ERRDOS, ERRnoaccess, NT_STATUS_ACCESS_DENIED}, {
+	ERRDOS, 111, NT_STATUS_BUFFER_TOO_SMALL}, {
+	ERRDOS, ERRbadfid, NT_STATUS_OBJECT_TYPE_MISMATCH}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NONCONTINUABLE_EXCEPTION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_DISPOSITION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNWIND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_STACK}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_UNWIND_TARGET}, {
+	ERRDOS, 158, NT_STATUS_NOT_LOCKED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PARITY_ERROR}, {
+	ERRDOS, 487, NT_STATUS_UNABLE_TO_DECOMMIT_VM}, {
+	ERRDOS, 487, NT_STATUS_NOT_COMMITTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_PORT_ATTRIBUTES}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PORT_MESSAGE_TOO_LONG}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_MIX}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_QUOTA_LOWER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DISK_CORRUPT_ERROR}, {
+	/* mapping changed since shell does lookup on * expects FileNotFound */
+	ERRDOS, ERRbadfile, NT_STATUS_OBJECT_NAME_INVALID}, {
+	ERRDOS, ERRbadfile, NT_STATUS_OBJECT_NAME_NOT_FOUND}, {
+	ERRDOS, ERRalreadyexists, NT_STATUS_OBJECT_NAME_COLLISION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_HANDLE_NOT_WAITABLE}, {
+	ERRDOS, ERRbadfid, NT_STATUS_PORT_DISCONNECTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DEVICE_ALREADY_ATTACHED}, {
+	ERRDOS, 161, NT_STATUS_OBJECT_PATH_INVALID}, {
+	ERRDOS, ERRbadpath, NT_STATUS_OBJECT_PATH_NOT_FOUND}, {
+	ERRDOS, 161, NT_STATUS_OBJECT_PATH_SYNTAX_BAD}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DATA_OVERRUN}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DATA_LATE_ERROR}, {
+	ERRDOS, 23, NT_STATUS_DATA_ERROR}, {
+	ERRDOS, 23, NT_STATUS_CRC_ERROR}, {
+	ERRDOS, ERRnomem, NT_STATUS_SECTION_TOO_BIG}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_PORT_CONNECTION_REFUSED}, {
+	ERRDOS, ERRbadfid, NT_STATUS_INVALID_PORT_HANDLE}, {
+	ERRDOS, ERRbadshare, NT_STATUS_SHARING_VIOLATION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_QUOTA_EXCEEDED}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PAGE_PROTECTION}, {
+	ERRDOS, 288, NT_STATUS_MUTANT_NOT_OWNED}, {
+	ERRDOS, 298, NT_STATUS_SEMAPHORE_LIMIT_EXCEEDED}, {
+	ERRDOS, 87, NT_STATUS_PORT_ALREADY_SET}, {
+	ERRDOS, 87, NT_STATUS_SECTION_NOT_IMAGE}, {
+	ERRDOS, 156, NT_STATUS_SUSPEND_COUNT_EXCEEDED}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_THREAD_IS_TERMINATING}, {
+	ERRDOS, 87, NT_STATUS_BAD_WORKING_SET_LIMIT}, {
+	ERRDOS, 87, NT_STATUS_INCOMPATIBLE_FILE_MAP}, {
+	ERRDOS, 87, NT_STATUS_SECTION_PROTECTION}, {
+	ERRDOS, ERReasnotsupported, NT_STATUS_EAS_NOT_SUPPORTED}, {
+	ERRDOS, 255, NT_STATUS_EA_TOO_LARGE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NONEXISTENT_EA_ENTRY}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_EAS_ON_FILE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_EA_CORRUPT_ERROR}, {
+	ERRDOS, ERRlock, NT_STATUS_FILE_LOCK_CONFLICT}, {
+	ERRDOS, ERRlock, NT_STATUS_LOCK_NOT_GRANTED}, {
+	ERRDOS, ERRbadfile, NT_STATUS_DELETE_PENDING}, {
+	ERRDOS, ERRunsup, NT_STATUS_CTL_FILE_NOT_SUPPORTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNKNOWN_REVISION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_REVISION_MISMATCH}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_OWNER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_PRIMARY_GROUP}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_IMPERSONATION_TOKEN}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CANT_DISABLE_MANDATORY}, {
+	ERRDOS, 2215, NT_STATUS_NO_LOGON_SERVERS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_SUCH_LOGON_SESSION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_SUCH_PRIVILEGE}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_PRIVILEGE_NOT_HELD}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_ACCOUNT_NAME}, {
+	ERRHRD, ERRgeneral, NT_STATUS_USER_EXISTS},
+/*	{ This NT error code was 'sqashed'
+ *	 from NT_STATUS_NO_SUCH_USER to NT_STATUS_LOGON_FAILURE
+ *	 during the session setup }
+ */
+	{
+	ERRDOS, ERRnoaccess, NT_STATUS_NO_SUCH_USER}, { /* could map to 2238 */
+	ERRHRD, ERRgeneral, NT_STATUS_GROUP_EXISTS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_SUCH_GROUP}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MEMBER_IN_GROUP}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MEMBER_NOT_IN_GROUP}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LAST_ADMIN},
+/*	{ This NT error code was 'sqashed'
+ *	 from NT_STATUS_WRONG_PASSWORD to NT_STATUS_LOGON_FAILURE
+ *	 during the session setup }
+ */
+	{
+	ERRSRV, ERRbadpw, NT_STATUS_WRONG_PASSWORD}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ILL_FORMED_PASSWORD}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PASSWORD_RESTRICTION}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_LOGON_FAILURE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ACCOUNT_RESTRICTION}, {
+	ERRSRV, ERRbadLogonTime, NT_STATUS_INVALID_LOGON_HOURS}, {
+	ERRSRV, ERRbadclient, NT_STATUS_INVALID_WORKSTATION}, {
+	ERRSRV, ERRpasswordExpired, NT_STATUS_PASSWORD_EXPIRED}, {
+	ERRSRV, ERRaccountexpired, NT_STATUS_ACCOUNT_DISABLED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NONE_MAPPED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_TOO_MANY_LUIDS_REQUESTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LUIDS_EXHAUSTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_SUB_AUTHORITY}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_ACL}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_SID}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_SECURITY_DESCR}, {
+	ERRDOS, 127, NT_STATUS_PROCEDURE_NOT_FOUND}, {
+	ERRDOS, 193, NT_STATUS_INVALID_IMAGE_FORMAT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_TOKEN}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_INHERITANCE_ACL}, {
+	ERRDOS, 158, NT_STATUS_RANGE_NOT_LOCKED}, {
+	ERRDOS, 112, NT_STATUS_DISK_FULL}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SERVER_DISABLED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SERVER_NOT_DISABLED}, {
+	ERRDOS, 68, NT_STATUS_TOO_MANY_GUIDS_REQUESTED}, {
+	ERRDOS, 259, NT_STATUS_GUIDS_EXHAUSTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_ID_AUTHORITY}, {
+	ERRDOS, 259, NT_STATUS_AGENTS_EXHAUSTED}, {
+	ERRDOS, 154, NT_STATUS_INVALID_VOLUME_LABEL}, {
+	ERRDOS, 14, NT_STATUS_SECTION_NOT_EXTENDED}, {
+	ERRDOS, 487, NT_STATUS_NOT_MAPPED_DATA}, {
+	ERRHRD, ERRgeneral, NT_STATUS_RESOURCE_DATA_NOT_FOUND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_RESOURCE_TYPE_NOT_FOUND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_RESOURCE_NAME_NOT_FOUND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ARRAY_BOUNDS_EXCEEDED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOAT_DENORMAL_OPERAND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOAT_DIVIDE_BY_ZERO}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOAT_INEXACT_RESULT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOAT_INVALID_OPERATION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOAT_OVERFLOW}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOAT_STACK_CHECK}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOAT_UNDERFLOW}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INTEGER_DIVIDE_BY_ZERO}, {
+	ERRDOS, 534, NT_STATUS_INTEGER_OVERFLOW}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PRIVILEGED_INSTRUCTION}, {
+	ERRDOS, ERRnomem, NT_STATUS_TOO_MANY_PAGING_FILES}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FILE_INVALID}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ALLOTTED_SPACE_EXCEEDED},
+/*	{ This NT error code was 'sqashed'
+ *	 from NT_STATUS_INSUFFICIENT_RESOURCES to
+ *	 NT_STATUS_INSUFF_SERVER_RESOURCES during the session setup }
+ */
+	{
+	ERRDOS, ERRnoresource, NT_STATUS_INSUFFICIENT_RESOURCES}, {
+	ERRDOS, ERRbadpath, NT_STATUS_DFS_EXIT_PATH_FOUND}, {
+	ERRDOS, 23, NT_STATUS_DEVICE_DATA_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DEVICE_NOT_CONNECTED}, {
+	ERRDOS, 21, NT_STATUS_DEVICE_POWER_FAILURE}, {
+	ERRDOS, 487, NT_STATUS_FREE_VM_NOT_AT_BASE}, {
+	ERRDOS, 487, NT_STATUS_MEMORY_NOT_ALLOCATED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_WORKING_SET_QUOTA}, {
+	ERRDOS, 19, NT_STATUS_MEDIA_WRITE_PROTECTED}, {
+	ERRDOS, 21, NT_STATUS_DEVICE_NOT_READY}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_GROUP_ATTRIBUTES}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_IMPERSONATION_LEVEL}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CANT_OPEN_ANONYMOUS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_VALIDATION_CLASS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_TOKEN_TYPE}, {
+	ERRDOS, 87, NT_STATUS_BAD_MASTER_BOOT_RECORD}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INSTRUCTION_MISALIGNMENT}, {
+	ERRDOS, ERRpipebusy, NT_STATUS_INSTANCE_NOT_AVAILABLE}, {
+	ERRDOS, ERRpipebusy, NT_STATUS_PIPE_NOT_AVAILABLE}, {
+	ERRDOS, ERRbadpipe, NT_STATUS_INVALID_PIPE_STATE}, {
+	ERRDOS, ERRpipebusy, NT_STATUS_PIPE_BUSY}, {
+	ERRDOS, ERRbadfunc, NT_STATUS_ILLEGAL_FUNCTION}, {
+	ERRDOS, ERRnotconnected, NT_STATUS_PIPE_DISCONNECTED}, {
+	ERRDOS, ERRpipeclosing, NT_STATUS_PIPE_CLOSING}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PIPE_CONNECTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PIPE_LISTENING}, {
+	ERRDOS, ERRbadpipe, NT_STATUS_INVALID_READ_MODE}, {
+	ERRDOS, 121, NT_STATUS_IO_TIMEOUT}, {
+	ERRDOS, 38, NT_STATUS_FILE_FORCED_CLOSED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PROFILING_NOT_STARTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PROFILING_NOT_STOPPED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_COULD_NOT_INTERPRET}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_FILE_IS_A_DIRECTORY}, {
+	ERRDOS, ERRunsup, NT_STATUS_NOT_SUPPORTED}, {
+	ERRDOS, 51, NT_STATUS_REMOTE_NOT_LISTENING}, {
+	ERRDOS, 52, NT_STATUS_DUPLICATE_NAME}, {
+	ERRDOS, 53, NT_STATUS_BAD_NETWORK_PATH}, {
+	ERRDOS, 54, NT_STATUS_NETWORK_BUSY}, {
+	ERRDOS, 55, NT_STATUS_DEVICE_DOES_NOT_EXIST}, {
+	ERRDOS, 56, NT_STATUS_TOO_MANY_COMMANDS}, {
+	ERRDOS, 57, NT_STATUS_ADAPTER_HARDWARE_ERROR}, {
+	ERRDOS, 58, NT_STATUS_INVALID_NETWORK_RESPONSE}, {
+	ERRDOS, 59, NT_STATUS_UNEXPECTED_NETWORK_ERROR}, {
+	ERRDOS, 60, NT_STATUS_BAD_REMOTE_ADAPTER}, {
+	ERRDOS, 61, NT_STATUS_PRINT_QUEUE_FULL}, {
+	ERRDOS, 62, NT_STATUS_NO_SPOOL_SPACE}, {
+	ERRDOS, 63, NT_STATUS_PRINT_CANCELLED}, {
+	ERRDOS, 64, NT_STATUS_NETWORK_NAME_DELETED}, {
+	ERRDOS, 65, NT_STATUS_NETWORK_ACCESS_DENIED}, {
+	ERRDOS, 66, NT_STATUS_BAD_DEVICE_TYPE}, {
+	ERRDOS, ERRnosuchshare, NT_STATUS_BAD_NETWORK_NAME}, {
+	ERRDOS, 68, NT_STATUS_TOO_MANY_NAMES}, {
+	ERRDOS, 69, NT_STATUS_TOO_MANY_SESSIONS}, {
+	ERRDOS, 70, NT_STATUS_SHARING_PAUSED}, {
+	ERRDOS, 71, NT_STATUS_REQUEST_NOT_ACCEPTED}, {
+	ERRDOS, 72, NT_STATUS_REDIRECTOR_PAUSED}, {
+	ERRDOS, 88, NT_STATUS_NET_WRITE_FAULT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PROFILING_AT_LIMIT}, {
+	ERRDOS, ERRdiffdevice, NT_STATUS_NOT_SAME_DEVICE}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_FILE_RENAMED}, {
+	ERRDOS, 240, NT_STATUS_VIRTUAL_CIRCUIT_CLOSED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_SECURITY_ON_OBJECT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CANT_WAIT}, {
+	ERRDOS, ERRpipeclosing, NT_STATUS_PIPE_EMPTY}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CANT_ACCESS_DOMAIN_INFO}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CANT_TERMINATE_SELF}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_SERVER_STATE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_DOMAIN_STATE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_DOMAIN_ROLE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_SUCH_DOMAIN}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DOMAIN_EXISTS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DOMAIN_LIMIT_EXCEEDED}, {
+	ERRDOS, 300, NT_STATUS_OPLOCK_NOT_GRANTED}, {
+	ERRDOS, 301, NT_STATUS_INVALID_OPLOCK_PROTOCOL}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INTERNAL_DB_CORRUPTION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INTERNAL_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_GENERIC_NOT_MAPPED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_DESCRIPTOR_FORMAT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_USER_BUFFER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNEXPECTED_IO_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNEXPECTED_MM_CREATE_ERR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNEXPECTED_MM_MAP_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNEXPECTED_MM_EXTEND_ERR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NOT_LOGON_PROCESS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LOGON_SESSION_EXISTS}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_1}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_2}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_3}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_4}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_5}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_6}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_7}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_8}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_9}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_10}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_11}, {
+	ERRDOS, 87, NT_STATUS_INVALID_PARAMETER_12}, {
+	ERRDOS, ERRbadpath, NT_STATUS_REDIRECTOR_NOT_STARTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_REDIRECTOR_STARTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_STACK_OVERFLOW}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_SUCH_PACKAGE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_FUNCTION_TABLE}, {
+	ERRDOS, 203, 0xc0000100}, {
+	ERRDOS, 145, NT_STATUS_DIRECTORY_NOT_EMPTY}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FILE_CORRUPT_ERROR}, {
+	ERRDOS, 267, NT_STATUS_NOT_A_DIRECTORY}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_LOGON_SESSION_STATE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LOGON_SESSION_COLLISION}, {
+	ERRDOS, 206, NT_STATUS_NAME_TOO_LONG}, {
+	ERRDOS, 2401, NT_STATUS_FILES_OPEN}, {
+	ERRDOS, 2404, NT_STATUS_CONNECTION_IN_USE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MESSAGE_NOT_FOUND}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_PROCESS_IS_TERMINATING}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_LOGON_TYPE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_GUID_TRANSLATION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CANNOT_IMPERSONATE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_IMAGE_ALREADY_LOADED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ABIOS_NOT_PRESENT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ABIOS_LID_NOT_EXIST}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ABIOS_LID_ALREADY_OWNED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ABIOS_NOT_LID_OWNER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ABIOS_INVALID_COMMAND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ABIOS_INVALID_LID}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ABIOS_SELECTOR_NOT_AVAILABLE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ABIOS_INVALID_SELECTOR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_LDT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_LDT_SIZE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_LDT_OFFSET}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_LDT_DESCRIPTOR}, {
+	ERRDOS, 193, NT_STATUS_INVALID_IMAGE_NE_FORMAT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_RXACT_INVALID_STATE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_RXACT_COMMIT_FAILURE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MAPPED_FILE_SIZE_ZERO}, {
+	ERRDOS, ERRnofids, NT_STATUS_TOO_MANY_OPENED_FILES}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CANCELLED}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_CANNOT_DELETE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_COMPUTER_NAME}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_FILE_DELETED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SPECIAL_ACCOUNT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SPECIAL_GROUP}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SPECIAL_USER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MEMBERS_PRIMARY_GROUP}, {
+	ERRDOS, ERRbadfid, NT_STATUS_FILE_CLOSED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_TOO_MANY_THREADS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_THREAD_NOT_IN_PROCESS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_TOKEN_ALREADY_IN_USE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PAGEFILE_QUOTA_EXCEEDED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_COMMITMENT_LIMIT}, {
+	ERRDOS, 193, NT_STATUS_INVALID_IMAGE_LE_FORMAT}, {
+	ERRDOS, 193, NT_STATUS_INVALID_IMAGE_NOT_MZ}, {
+	ERRDOS, 193, NT_STATUS_INVALID_IMAGE_PROTECT}, {
+	ERRDOS, 193, NT_STATUS_INVALID_IMAGE_WIN_16}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LOGON_SERVER_CONFLICT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_TIME_DIFFERENCE_AT_DC}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SYNCHRONIZATION_REQUIRED}, {
+	ERRDOS, 126, NT_STATUS_DLL_NOT_FOUND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_OPEN_FAILED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_IO_PRIVILEGE_FAILED}, {
+	ERRDOS, 182, NT_STATUS_ORDINAL_NOT_FOUND}, {
+	ERRDOS, 127, NT_STATUS_ENTRYPOINT_NOT_FOUND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CONTROL_C_EXIT}, {
+	ERRDOS, 64, NT_STATUS_LOCAL_DISCONNECT}, {
+	ERRDOS, 64, NT_STATUS_REMOTE_DISCONNECT}, {
+	ERRDOS, 51, NT_STATUS_REMOTE_RESOURCES}, {
+	ERRDOS, 59, NT_STATUS_LINK_FAILED}, {
+	ERRDOS, 59, NT_STATUS_LINK_TIMEOUT}, {
+	ERRDOS, 59, NT_STATUS_INVALID_CONNECTION}, {
+	ERRDOS, 59, NT_STATUS_INVALID_ADDRESS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DLL_INIT_FAILED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MISSING_SYSTEMFILE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNHANDLED_EXCEPTION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_APP_INIT_FAILURE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PAGEFILE_CREATE_FAILED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_PAGEFILE}, {
+	ERRDOS, 124, NT_STATUS_INVALID_LEVEL}, {
+	ERRDOS, 86, NT_STATUS_WRONG_PASSWORD_CORE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ILLEGAL_FLOAT_CONTEXT}, {
+	ERRDOS, 109, NT_STATUS_PIPE_BROKEN}, {
+	ERRHRD, ERRgeneral, NT_STATUS_REGISTRY_CORRUPT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_REGISTRY_IO_FAILED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_EVENT_PAIR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNRECOGNIZED_VOLUME}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SERIAL_NO_DEVICE_INITED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_SUCH_ALIAS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MEMBER_NOT_IN_ALIAS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MEMBER_IN_ALIAS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ALIAS_EXISTS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LOGON_NOT_GRANTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_TOO_MANY_SECRETS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SECRET_TOO_LONG}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INTERNAL_DB_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FULLSCREEN_MODE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_TOO_MANY_CONTEXT_IDS}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_LOGON_TYPE_NOT_GRANTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NOT_REGISTRY_FILE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NT_CROSS_ENCRYPTION_REQUIRED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DOMAIN_CTRLR_CONFIG_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FT_MISSING_MEMBER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ILL_FORMED_SERVICE_ENTRY}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ILLEGAL_CHARACTER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNMAPPABLE_CHARACTER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNDEFINED_CHARACTER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOPPY_VOLUME}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOPPY_ID_MARK_NOT_FOUND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOPPY_WRONG_CYLINDER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOPPY_UNKNOWN_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FLOPPY_BAD_REGISTERS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DISK_RECALIBRATE_FAILED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DISK_OPERATION_FAILED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DISK_RESET_FAILED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SHARED_IRQ_BUSY}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FT_ORPHANING}, {
+	ERRHRD, ERRgeneral, 0xc000016e}, {
+	ERRHRD, ERRgeneral, 0xc000016f}, {
+	ERRHRD, ERRgeneral, 0xc0000170}, {
+	ERRHRD, ERRgeneral, 0xc0000171}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PARTITION_FAILURE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_BLOCK_LENGTH}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DEVICE_NOT_PARTITIONED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNABLE_TO_LOCK_MEDIA}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNABLE_TO_UNLOAD_MEDIA}, {
+	ERRHRD, ERRgeneral, NT_STATUS_EOM_OVERFLOW}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_MEDIA}, {
+	ERRHRD, ERRgeneral, 0xc0000179}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_SUCH_MEMBER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_MEMBER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_KEY_DELETED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_LOG_SPACE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_TOO_MANY_SIDS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LM_CROSS_ENCRYPTION_REQUIRED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_KEY_HAS_CHILDREN}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CHILD_MUST_BE_VOLATILE}, {
+	ERRDOS, 87, NT_STATUS_DEVICE_CONFIGURATION_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DRIVER_INTERNAL_ERROR}, {
+	ERRDOS, 22, NT_STATUS_INVALID_DEVICE_STATE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_IO_DEVICE_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DEVICE_PROTOCOL_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BACKUP_CONTROLLER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LOG_FILE_FULL}, {
+	ERRDOS, 19, NT_STATUS_TOO_LATE}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_NO_TRUST_LSA_SECRET},
+/*	{ This NT error code was 'sqashed'
+ *	 from NT_STATUS_NO_TRUST_SAM_ACCOUNT to
+ *	 NT_STATUS_TRUSTED_RELATIONSHIP_FAILURE during the session setup }
+ */
+	{
+	ERRDOS, ERRnoaccess, NT_STATUS_NO_TRUST_SAM_ACCOUNT}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_TRUSTED_DOMAIN_FAILURE}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_TRUSTED_RELATIONSHIP_FAILURE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_EVENTLOG_FILE_CORRUPT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_EVENTLOG_CANT_START}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_TRUST_FAILURE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MUTANT_LIMIT_EXCEEDED}, {
+	ERRDOS, ERRnetlogonNotStarted, NT_STATUS_NETLOGON_NOT_STARTED}, {
+	ERRSRV, ERRaccountexpired, NT_STATUS_ACCOUNT_EXPIRED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_POSSIBLE_DEADLOCK}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NETWORK_CREDENTIAL_CONFLICT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_REMOTE_SESSION_LIMIT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_EVENTLOG_FILE_CHANGED}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_NOLOGON_SERVER_TRUST_ACCOUNT},
+/*	{ This NT error code was 'sqashed'
+ *	 from NT_STATUS_DOMAIN_TRUST_INCONSISTENT to NT_STATUS_LOGON_FAILURE
+ *	 during the session setup }
+ */
+	{
+	ERRDOS, ERRnoaccess, NT_STATUS_DOMAIN_TRUST_INCONSISTENT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FS_DRIVER_REQUIRED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_USER_SESSION_KEY}, {
+	ERRDOS, 59, NT_STATUS_USER_SESSION_DELETED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_RESOURCE_LANG_NOT_FOUND}, {
+	ERRDOS, ERRnoresource, NT_STATUS_INSUFF_SERVER_RESOURCES}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_BUFFER_SIZE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_ADDRESS_COMPONENT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_ADDRESS_WILDCARD}, {
+	ERRDOS, 68, NT_STATUS_TOO_MANY_ADDRESSES}, {
+	ERRDOS, 52, NT_STATUS_ADDRESS_ALREADY_EXISTS}, {
+	ERRDOS, 64, NT_STATUS_ADDRESS_CLOSED}, {
+	ERRDOS, 64, NT_STATUS_CONNECTION_DISCONNECTED}, {
+	ERRDOS, 64, NT_STATUS_CONNECTION_RESET}, {
+	ERRDOS, 68, NT_STATUS_TOO_MANY_NODES}, {
+	ERRDOS, 59, NT_STATUS_TRANSACTION_ABORTED}, {
+	ERRDOS, 59, NT_STATUS_TRANSACTION_TIMED_OUT}, {
+	ERRDOS, 59, NT_STATUS_TRANSACTION_NO_RELEASE}, {
+	ERRDOS, 59, NT_STATUS_TRANSACTION_NO_MATCH}, {
+	ERRDOS, 59, NT_STATUS_TRANSACTION_RESPONDED}, {
+	ERRDOS, 59, NT_STATUS_TRANSACTION_INVALID_ID}, {
+	ERRDOS, 59, NT_STATUS_TRANSACTION_INVALID_TYPE}, {
+	ERRDOS, ERRunsup, NT_STATUS_NOT_SERVER_SESSION}, {
+	ERRDOS, ERRunsup, NT_STATUS_NOT_CLIENT_SESSION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CANNOT_LOAD_REGISTRY_FILE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DEBUG_ATTACH_FAILED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_SYSTEM_PROCESS_TERMINATED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DATA_NOT_ACCEPTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_BROWSER_SERVERS_FOUND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_VDM_HARD_ERROR}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DRIVER_CANCEL_TIMEOUT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_REPLY_MESSAGE_MISMATCH}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MAPPED_ALIGNMENT}, {
+	ERRDOS, 193, NT_STATUS_IMAGE_CHECKSUM_MISMATCH}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LOST_WRITEBEHIND_DATA}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CLIENT_SERVER_PARAMETERS_INVALID}, {
+	ERRSRV, ERRpasswordExpired, NT_STATUS_PASSWORD_MUST_CHANGE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NOT_FOUND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NOT_TINY_STREAM}, {
+	ERRHRD, ERRgeneral, NT_STATUS_RECOVERY_FAILURE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_STACK_OVERFLOW_READ}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FAIL_CHECK}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DUPLICATE_OBJECTID}, {
+	ERRHRD, ERRgeneral, NT_STATUS_OBJECTID_EXISTS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CONVERT_TO_LARGE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_RETRY}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FOUND_OUT_OF_SCOPE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ALLOCATE_BUCKET}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PROPSET_NOT_FOUND}, {
+	ERRHRD, ERRgeneral, NT_STATUS_MARSHALL_OVERFLOW}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_VARIANT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_DOMAIN_CONTROLLER_NOT_FOUND}, {
+	ERRDOS, ERRnoaccess, NT_STATUS_ACCOUNT_LOCKED_OUT}, {
+	ERRDOS, ERRbadfid, NT_STATUS_HANDLE_NOT_CLOSABLE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CONNECTION_REFUSED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_GRACEFUL_DISCONNECT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ADDRESS_ALREADY_ASSOCIATED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_ADDRESS_NOT_ASSOCIATED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CONNECTION_INVALID}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CONNECTION_ACTIVE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NETWORK_UNREACHABLE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_HOST_UNREACHABLE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PROTOCOL_UNREACHABLE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PORT_UNREACHABLE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_REQUEST_ABORTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CONNECTION_ABORTED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_COMPRESSION_BUFFER}, {
+	ERRHRD, ERRgeneral, NT_STATUS_USER_MAPPED_FILE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_AUDIT_FAILED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_TIMER_RESOLUTION_NOT_SET}, {
+	ERRHRD, ERRgeneral, NT_STATUS_CONNECTION_COUNT_LIMIT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LOGIN_TIME_RESTRICTION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LOGIN_WKSTA_RESTRICTION}, {
+	ERRDOS, 193, NT_STATUS_IMAGE_MP_UP_MISMATCH}, {
+	ERRHRD, ERRgeneral, 0xc000024a}, {
+	ERRHRD, ERRgeneral, 0xc000024b}, {
+	ERRHRD, ERRgeneral, 0xc000024c}, {
+	ERRHRD, ERRgeneral, 0xc000024d}, {
+	ERRHRD, ERRgeneral, 0xc000024e}, {
+	ERRHRD, ERRgeneral, 0xc000024f}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INSUFFICIENT_LOGON_INFO}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_DLL_ENTRYPOINT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_BAD_SERVICE_ENTRYPOINT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LPC_REPLY_LOST}, {
+	ERRHRD, ERRgeneral, NT_STATUS_IP_ADDRESS_CONFLICT1}, {
+	ERRHRD, ERRgeneral, NT_STATUS_IP_ADDRESS_CONFLICT2}, {
+	ERRHRD, ERRgeneral, NT_STATUS_REGISTRY_QUOTA_LIMIT}, {
+	ERRSRV, 3, NT_STATUS_PATH_NOT_COVERED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_NO_CALLBACK_ACTIVE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_LICENSE_QUOTA_EXCEEDED}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PWD_TOO_SHORT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PWD_TOO_RECENT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PWD_HISTORY_CONFLICT}, {
+	ERRHRD, ERRgeneral, 0xc000025d}, {
+	ERRHRD, ERRgeneral, NT_STATUS_PLUGPLAY_NO_DEVICE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_UNSUPPORTED_COMPRESSION}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_HW_PROFILE}, {
+	ERRHRD, ERRgeneral, NT_STATUS_INVALID_PLUGPLAY_DEVICE_PATH}, {
+	ERRDOS, 182, NT_STATUS_DRIVER_ORDINAL_NOT_FOUND}, {
+	ERRDOS, 127, NT_STATUS_DRIVER_ENTRYPOINT_NOT_FOUND}, {
+	ERRDOS, 288, NT_STATUS_RESOURCE_NOT_OWNED}, {
+	ERRDOS, ErrTooManyLinks, NT_STATUS_TOO_MANY_LINKS}, {
+	ERRHRD, ERRgeneral, NT_STATUS_QUOTA_LIST_INCONSISTENT}, {
+	ERRHRD, ERRgeneral, NT_STATUS_FILE_IS_OFFLINE}, {
+	ERRDOS, 21, 0xc000026e}, {
+	ERRDOS, 161, 0xc0000281}, {
+	ERRDOS, ERRnoaccess, 0xc000028a}, {
+	ERRDOS, ERRnoaccess, 0xc000028b}, {
+	ERRHRD, ERRgeneral, 0xc000028c}, {
+	ERRDOS, ERRnoaccess, 0xc000028d}, {
+	ERRDOS, ERRnoaccess, 0xc000028e}, {
+	ERRDOS, ERRnoaccess, 0xc000028f}, {
+	ERRDOS, ERRnoaccess, 0xc0000290}, {
+	ERRDOS, ERRbadfunc, 0xc000029c}, {
+	ERRDOS, ERRsymlink, NT_STATUS_STOPPED_ON_SYMLINK}, {
+	ERRDOS, ERRinvlevel, 0x007c0001}, };
+
+void
+ntstatus_to_dos(__le32 ntstatus, __u8 *eclass, __le16 *ecode)
+{
+	int i;
+
+	if (ntstatus == 0) {
+		*eclass = 0;
+		*ecode = 0;
+		return;
+	}
+	for (i = 0; ntstatus_to_dos_map[i].ntstatus; i++) {
+		if (le32_to_cpu(ntstatus) == ntstatus_to_dos_map[i].ntstatus) {
+			*eclass = ntstatus_to_dos_map[i].dos_class;
+			*ecode = cpu_to_le16(ntstatus_to_dos_map[i].dos_code);
+			return;
+		}
+	}
+	*eclass = ERRHRD;
+	*ecode = cpu_to_le16(ERRgeneral);
+}
diff --git a/fs/ksmbd/ntlmssp.h b/fs/ksmbd/ntlmssp.h
index f13153c18b4e..adaf4c0cbe8f 100644
--- a/fs/ksmbd/ntlmssp.h
+++ b/fs/ksmbd/ntlmssp.h
@@ -95,7 +95,7 @@ struct security_buffer {
 struct target_info {
 	__le16 Type;
 	__le16 Length;
-	__u8 Content[];
+	__u8 Content[0];
 } __packed;
 
 struct negotiate_message {
@@ -108,7 +108,7 @@ struct negotiate_message {
 	 * struct security_buffer for version info not present since we
 	 * do not set the version is present flag
 	 */
-	char DomainString[];
+	char DomainString[0];
 	/* followed by WorkstationString */
 } __packed;
 
@@ -140,7 +140,7 @@ struct authenticate_message {
 	 * struct security_buffer for version info not present since we
 	 * do not set the version is present flag
 	 */
-	char UserString[];
+	char UserString[0];
 } __packed;
 
 struct ntlmv2_resp {
diff --git a/fs/ksmbd/oplock.c b/fs/ksmbd/oplock.c
index d7d47b82451d..61c83f00d8c3 100644
--- a/fs/ksmbd/oplock.c
+++ b/fs/ksmbd/oplock.c
@@ -10,6 +10,9 @@
 #include "oplock.h"
 
 #include "smb_common.h"
+#ifdef CONFIG_SMB_INSECURE_SERVER
+#include "smb1pdu.h"
+#endif
 #include "smbstatus.h"
 #include "connection.h"
 #include "mgmt/user_session.h"
@@ -45,6 +48,9 @@ static struct oplock_info *alloc_opinfo(struct ksmbd_work *work,
 	opinfo->pending_break = 0;
 	opinfo->fid = id;
 	opinfo->Tid = Tid;
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	opinfo->is_smb2 = IS_SMB2(conn);
+#endif
 	INIT_LIST_HEAD(&opinfo->op_entry);
 	INIT_LIST_HEAD(&opinfo->interim_list);
 	init_waitqueue_head(&opinfo->oplock_q);
@@ -102,9 +108,10 @@ static int alloc_lease(struct oplock_info *opinfo, struct lease_ctx_info *lctx)
 	lease->new_state = 0;
 	lease->flags = lctx->flags;
 	lease->duration = lctx->duration;
+	lease->is_dir = lctx->is_dir;
 	memcpy(lease->parent_lease_key, lctx->parent_lease_key, SMB2_LEASE_KEY_SIZE);
 	lease->version = lctx->version;
-	lease->epoch = 0;
+	lease->epoch = le16_to_cpu(lctx->epoch);
 	INIT_LIST_HEAD(&opinfo->lease_entry);
 	opinfo->o_lease = lease;
 
@@ -157,13 +164,42 @@ static struct oplock_info *opinfo_get_list(struct ksmbd_inode *ci)
 	rcu_read_lock();
 	opinfo = list_first_or_null_rcu(&ci->m_op_list, struct oplock_info,
 					op_entry);
-	if (opinfo && !atomic_inc_not_zero(&opinfo->refcount))
-		opinfo = NULL;
+	if (opinfo) {
+		if (!atomic_inc_not_zero(&opinfo->refcount))
+			opinfo = NULL;
+		else {
+			atomic_inc(&opinfo->conn->r_count);
+			if (ksmbd_conn_releasing(opinfo->conn)) {
+				atomic_dec(&opinfo->conn->r_count);
+				atomic_dec(&opinfo->refcount);
+				opinfo = NULL;
+			}
+		}
+	}
+
 	rcu_read_unlock();
 
 	return opinfo;
 }
 
+static void opinfo_conn_put(struct oplock_info *opinfo)
+{
+	struct ksmbd_conn *conn;
+
+	if (!opinfo)
+		return;
+
+	conn = opinfo->conn;
+	/*
+	 * Checking waitqueue to dropping pending requests on
+	 * disconnection. waitqueue_active is safe because it
+	 * uses atomic operation for condition.
+	 */
+	if (!atomic_dec_return(&conn->r_count) && waitqueue_active(&conn->r_count_q))
+		wake_up(&conn->r_count_q);
+	opinfo_put(opinfo);
+}
+
 void opinfo_put(struct oplock_info *opinfo)
 {
 	if (!atomic_dec_and_test(&opinfo->refcount))
@@ -229,6 +265,28 @@ int opinfo_write_to_read(struct oplock_info *opinfo)
 {
 	struct lease *lease = opinfo->o_lease;
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (opinfo->is_smb2) {
+		if (!(opinfo->level == SMB2_OPLOCK_LEVEL_BATCH ||
+		      opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE)) {
+			pr_err("bad oplock(0x%x)\n", opinfo->level);
+			if (opinfo->is_lease)
+				pr_err("lease state(0x%x)\n", lease->state);
+			return -EINVAL;
+		}
+		opinfo->level = SMB2_OPLOCK_LEVEL_II;
+
+		if (opinfo->is_lease)
+			lease->state = lease->new_state;
+	} else {
+		if (!(opinfo->level == OPLOCK_EXCLUSIVE ||
+		      opinfo->level == OPLOCK_BATCH)) {
+			pr_err("bad oplock(0x%x)\n", opinfo->level);
+			return -EINVAL;
+		}
+		opinfo->level = OPLOCK_READ;
+	}
+#else
 	if (!(opinfo->level == SMB2_OPLOCK_LEVEL_BATCH ||
 	      opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE)) {
 		pr_err("bad oplock(0x%x)\n", opinfo->level);
@@ -240,6 +298,7 @@ int opinfo_write_to_read(struct oplock_info *opinfo)
 
 	if (opinfo->is_lease)
 		lease->state = lease->new_state;
+#endif
 	return 0;
 }
 
@@ -268,6 +327,27 @@ int opinfo_write_to_none(struct oplock_info *opinfo)
 {
 	struct lease *lease = opinfo->o_lease;
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (opinfo->is_smb2) {
+		if (!(opinfo->level == SMB2_OPLOCK_LEVEL_BATCH ||
+		      opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE)) {
+			pr_err("bad oplock(0x%x)\n", opinfo->level);
+			if (opinfo->is_lease)
+				pr_err("lease state(0x%x)\n", lease->state);
+			return -EINVAL;
+		}
+		opinfo->level = SMB2_OPLOCK_LEVEL_NONE;
+		if (opinfo->is_lease)
+			lease->state = lease->new_state;
+	} else {
+		if (!(opinfo->level == OPLOCK_EXCLUSIVE ||
+		      opinfo->level == OPLOCK_BATCH)) {
+			pr_err("bad oplock(0x%x)\n", opinfo->level);
+			return -EINVAL;
+		}
+		opinfo->level = OPLOCK_NONE;
+	}
+#else
 	if (!(opinfo->level == SMB2_OPLOCK_LEVEL_BATCH ||
 	      opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE)) {
 		pr_err("bad oplock(0x%x)\n", opinfo->level);
@@ -278,6 +358,7 @@ int opinfo_write_to_none(struct oplock_info *opinfo)
 	opinfo->level = SMB2_OPLOCK_LEVEL_NONE;
 	if (opinfo->is_lease)
 		lease->state = lease->new_state;
+#endif
 	return 0;
 }
 
@@ -291,6 +372,25 @@ int opinfo_read_to_none(struct oplock_info *opinfo)
 {
 	struct lease *lease = opinfo->o_lease;
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (opinfo->is_smb2) {
+		if (opinfo->level != SMB2_OPLOCK_LEVEL_II) {
+			pr_err("bad oplock(0x%x)\n", opinfo->level);
+			if (opinfo->is_lease)
+				pr_err("lease state(0x%x)\n", lease->state);
+			return -EINVAL;
+		}
+		opinfo->level = SMB2_OPLOCK_LEVEL_NONE;
+		if (opinfo->is_lease)
+			lease->state = lease->new_state;
+	} else {
+		if (opinfo->level != OPLOCK_READ) {
+			pr_err("bad oplock(0x%x)\n", opinfo->level);
+			return -EINVAL;
+		}
+		opinfo->level = OPLOCK_NONE;
+	}
+#else
 	if (opinfo->level != SMB2_OPLOCK_LEVEL_II) {
 		pr_err("bad oplock(0x%x)\n", opinfo->level);
 		if (opinfo->is_lease)
@@ -300,6 +400,7 @@ int opinfo_read_to_none(struct oplock_info *opinfo)
 	opinfo->level = SMB2_OPLOCK_LEVEL_NONE;
 	if (opinfo->is_lease)
 		lease->state = lease->new_state;
+#endif
 	return 0;
 }
 
@@ -366,8 +467,8 @@ void close_id_del_oplock(struct ksmbd_file *fp)
 {
 	struct oplock_info *opinfo;
 
-	if (S_ISDIR(file_inode(fp->filp)->i_mode))
-		return;
+	if (fp->reserve_lease_break)
+		smb_lazy_parent_lease_break_close(fp);
 
 	opinfo = opinfo_get(fp);
 	if (!opinfo)
@@ -403,10 +504,24 @@ static void grant_write_oplock(struct oplock_info *opinfo_new, int req_oplock,
 {
 	struct lease *lease = opinfo_new->o_lease;
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (opinfo_new->is_smb2) {
+		if (req_oplock == SMB2_OPLOCK_LEVEL_BATCH)
+			opinfo_new->level = SMB2_OPLOCK_LEVEL_BATCH;
+		else
+			opinfo_new->level = SMB2_OPLOCK_LEVEL_EXCLUSIVE;
+	} else {
+		if (req_oplock == REQ_BATCHOPLOCK)
+			opinfo_new->level = OPLOCK_BATCH;
+		else
+			opinfo_new->level = OPLOCK_EXCLUSIVE;
+	}
+#else
 	if (req_oplock == SMB2_OPLOCK_LEVEL_BATCH)
 		opinfo_new->level = SMB2_OPLOCK_LEVEL_BATCH;
 	else
 		opinfo_new->level = SMB2_OPLOCK_LEVEL_EXCLUSIVE;
+#endif
 
 	if (lctx) {
 		lease->state = lctx->req_state;
@@ -426,7 +541,14 @@ static void grant_read_oplock(struct oplock_info *opinfo_new,
 {
 	struct lease *lease = opinfo_new->o_lease;
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (opinfo_new->is_smb2)
+		opinfo_new->level = SMB2_OPLOCK_LEVEL_II;
+	else
+		opinfo_new->level = OPLOCK_READ;
+#else
 	opinfo_new->level = SMB2_OPLOCK_LEVEL_II;
+#endif
 
 	if (lctx) {
 		lease->state = SMB2_LEASE_READ_CACHING_LE;
@@ -448,7 +570,14 @@ static void grant_none_oplock(struct oplock_info *opinfo_new,
 {
 	struct lease *lease = opinfo_new->o_lease;
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (opinfo_new->is_smb2)
+		opinfo_new->level = SMB2_OPLOCK_LEVEL_NONE;
+	else
+		opinfo_new->level = OPLOCK_NONE;
+#else
 	opinfo_new->level = SMB2_OPLOCK_LEVEL_NONE;
+#endif
 
 	if (lctx) {
 		lease->state = 0;
@@ -514,12 +643,13 @@ static struct oplock_info *same_client_has_lease(struct ksmbd_inode *ci,
 			/* upgrading lease */
 			if ((atomic_read(&ci->op_count) +
 			     atomic_read(&ci->sop_count)) == 1) {
-				if (lease->state ==
-				    (lctx->req_state & lease->state)) {
+				if (lease->state != SMB2_LEASE_NONE_LE &&
+				    lease->state == (lctx->req_state & lease->state)) {
 					lease->state |= lctx->req_state;
 					if (lctx->req_state &
 						SMB2_LEASE_WRITE_CACHING_LE)
 						lease_read_to_write(opinfo);
+
 				}
 			} else if ((atomic_read(&ci->op_count) +
 				    atomic_read(&ci->sop_count)) > 1) {
@@ -568,7 +698,7 @@ static void wake_up_oplock_break(struct oplock_info *opinfo)
 
 static int oplock_break_pending(struct oplock_info *opinfo, int req_op_level)
 {
-	while (test_and_set_bit(0, &opinfo->pending_break)) {
+	while  (test_and_set_bit(0, &opinfo->pending_break)) {
 		wait_on_bit(&opinfo->pending_break, 0, TASK_UNINTERRUPTIBLE);
 
 		/* Not immediately break to none. */
@@ -587,14 +717,108 @@ static int oplock_break_pending(struct oplock_info *opinfo, int req_op_level)
 	return 0;
 }
 
-static inline int allocate_oplock_break_buf(struct ksmbd_work *work)
+#ifdef CONFIG_SMB_INSECURE_SERVER
+/**
+ * smb1_oplock_break_noti() - send smb1 oplock break cmd from conn
+ * to client
+ * @work:     smb work object
+ *
+ * There are two ways this function can be called. 1- while file open we break
+ * from exclusive/batch lock to levelII oplock and 2- while file write/truncate
+ * we break from levelII oplock no oplock.
+ * work->request_buf contains oplock_info.
+ */
+static void __smb1_oplock_break_noti(struct work_struct *wk)
 {
-	work->response_buf = kzalloc(MAX_CIFS_SMALL_BUFFER_SIZE, GFP_KERNEL);
-	if (!work->response_buf)
+	struct ksmbd_work *work = container_of(wk, struct ksmbd_work, work);
+	struct ksmbd_conn *conn = work->conn;
+	struct smb_hdr *rsp_hdr;
+	struct smb_com_lock_req *req;
+	struct oplock_info *opinfo = work->request_buf;
+
+	if (allocate_interim_rsp_buf(work)) {
+		pr_err("smb_allocate_rsp_buf failed! ");
+		ksmbd_free_work_struct(work);
+		return;
+	}
+
+	/* Init response header */
+	rsp_hdr = work->response_buf;
+	/* wct is 8 for locking andx(18) */
+	memset(rsp_hdr, 0, sizeof(struct smb_hdr) + 18);
+	rsp_hdr->smb_buf_length =
+		cpu_to_be32(conn->vals->header_size - 4 + 18);
+	rsp_hdr->Protocol[0] = 0xFF;
+	rsp_hdr->Protocol[1] = 'S';
+	rsp_hdr->Protocol[2] = 'M';
+	rsp_hdr->Protocol[3] = 'B';
+
+	rsp_hdr->Command = SMB_COM_LOCKING_ANDX;
+	/* we know unicode, long file name and use nt error codes */
+	rsp_hdr->Flags2 = SMBFLG2_UNICODE | SMBFLG2_KNOWS_LONG_NAMES |
+		SMBFLG2_ERR_STATUS;
+	rsp_hdr->Uid = cpu_to_le16(work->sess->id);
+	rsp_hdr->Pid = cpu_to_le16(0xFFFF);
+	rsp_hdr->Mid = cpu_to_le16(0xFFFF);
+	rsp_hdr->Tid = cpu_to_le16(opinfo->Tid);
+	rsp_hdr->WordCount = 8;
+
+	/* Init locking request */
+	req = work->response_buf;
+
+	req->AndXCommand = 0xFF;
+	req->AndXReserved = 0;
+	req->AndXOffset = 0;
+	req->Fid = opinfo->fid;
+	req->LockType = LOCKING_ANDX_OPLOCK_RELEASE;
+	if (!opinfo->open_trunc &&
+	    (opinfo->level == OPLOCK_BATCH ||
+	     opinfo->level == OPLOCK_EXCLUSIVE))
+		req->OplockLevel = 1;
+	else
+		req->OplockLevel = 0;
+	req->Timeout = 0;
+	req->NumberOfUnlocks = 0;
+	req->ByteCount = 0;
+	ksmbd_debug(OPLOCK, "sending oplock break for fid %d lock level = %d\n",
+		    req->Fid, req->OplockLevel);
+
+	ksmbd_conn_write(work);
+	ksmbd_free_work_struct(work);
+}
+
+/**
+ * smb1_oplock_break() - send smb1 exclusive/batch to level2 oplock
+ *		break command from server to client
+ * @opinfo:		oplock info object
+ * @ack_required	if requiring ack
+ *
+ * Return:      0 on success, otherwise error
+ */
+static int smb1_oplock_break_noti(struct oplock_info *opinfo)
+{
+	struct ksmbd_conn *conn = opinfo->conn;
+	struct ksmbd_work *work = ksmbd_alloc_work_struct();
+
+	if (!work)
 		return -ENOMEM;
-	work->response_sz = MAX_CIFS_SMALL_BUFFER_SIZE;
+
+	work->request_buf = (char *)opinfo;
+	work->conn = conn;
+
+	if (opinfo->op_state == OPLOCK_ACK_WAIT) {
+		INIT_WORK(&work->work, __smb1_oplock_break_noti);
+		ksmbd_queue_work(work);
+
+		wait_for_break_ack(opinfo);
+	} else {
+		__smb1_oplock_break_noti(&work->work);
+		if (opinfo->level == OPLOCK_READ)
+			opinfo->level = OPLOCK_NONE;
+	}
 	return 0;
 }
+#endif
 
 /**
  * __smb2_oplock_break_noti() - send smb2 oplock break cmd from conn
@@ -610,7 +834,6 @@ static void __smb2_oplock_break_noti(struct work_struct *wk)
 {
 	struct smb2_oplock_break *rsp = NULL;
 	struct ksmbd_work *work = container_of(wk, struct ksmbd_work, work);
-	struct ksmbd_conn *conn = work->conn;
 	struct oplock_break_info *br_info = work->request_buf;
 	struct smb2_hdr *rsp_hdr;
 	struct ksmbd_file *fp;
@@ -619,7 +842,7 @@ static void __smb2_oplock_break_noti(struct work_struct *wk)
 	if (!fp)
 		goto out;
 
-	if (allocate_oplock_break_buf(work)) {
+	if (allocate_interim_rsp_buf(work)) {
 		pr_err("smb2_allocate_rsp_buf failed! ");
 		ksmbd_fd_put(work, fp);
 		goto out;
@@ -627,8 +850,6 @@ static void __smb2_oplock_break_noti(struct work_struct *wk)
 
 	rsp_hdr = smb2_get_msg(work->response_buf);
 	memset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);
-	*(__be32 *)work->response_buf =
-		cpu_to_be32(conn->vals->header_size);
 	rsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;
 	rsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;
 	rsp_hdr->CreditRequest = cpu_to_le16(0);
@@ -655,24 +876,19 @@ static void __smb2_oplock_break_noti(struct work_struct *wk)
 	rsp->PersistentFid = fp->persistent_id;
 	rsp->VolatileFid = fp->volatile_id;
 
-	inc_rfc1001_len(work->response_buf, 24);
+	ksmbd_fd_put(work, fp);
+	if (ksmbd_iov_pin_rsp(work, (void *)rsp,
+			      sizeof(struct smb2_oplock_break)))
+		goto out;
 
 	ksmbd_debug(OPLOCK,
 		    "sending oplock break v_id %llu p_id = %llu lock level = %d\n",
 		    rsp->VolatileFid, rsp->PersistentFid, rsp->OplockLevel);
 
-	ksmbd_fd_put(work, fp);
 	ksmbd_conn_write(work);
 
 out:
 	ksmbd_free_work_struct(work);
-	/*
-	 * Checking waitqueue to dropping pending requests on
-	 * disconnection. waitqueue_active is safe because it
-	 * uses atomic operation for condition.
-	 */
-	if (!atomic_dec_return(&conn->r_count) && waitqueue_active(&conn->r_count_q))
-		wake_up(&conn->r_count_q);
 }
 
 /**
@@ -706,7 +922,6 @@ static int smb2_oplock_break_noti(struct oplock_info *opinfo)
 	work->conn = conn;
 	work->sess = opinfo->sess;
 
-	atomic_inc(&conn->r_count);
 	if (opinfo->op_state == OPLOCK_ACK_WAIT) {
 		INIT_WORK(&work->work, __smb2_oplock_break_noti);
 		ksmbd_queue_work(work);
@@ -730,18 +945,15 @@ static void __smb2_lease_break_noti(struct work_struct *wk)
 	struct smb2_lease_break *rsp = NULL;
 	struct ksmbd_work *work = container_of(wk, struct ksmbd_work, work);
 	struct lease_break_info *br_info = work->request_buf;
-	struct ksmbd_conn *conn = work->conn;
 	struct smb2_hdr *rsp_hdr;
 
-	if (allocate_oplock_break_buf(work)) {
+	if (allocate_interim_rsp_buf(work)) {
 		ksmbd_debug(OPLOCK, "smb2_allocate_rsp_buf failed! ");
 		goto out;
 	}
 
 	rsp_hdr = smb2_get_msg(work->response_buf);
 	memset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);
-	*(__be32 *)work->response_buf =
-		cpu_to_be32(conn->vals->header_size);
 	rsp_hdr->ProtocolId = SMB2_PROTO_NUMBER;
 	rsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;
 	rsp_hdr->CreditRequest = cpu_to_le16(0);
@@ -770,19 +982,14 @@ static void __smb2_lease_break_noti(struct work_struct *wk)
 	rsp->AccessMaskHint = 0;
 	rsp->ShareMaskHint = 0;
 
-	inc_rfc1001_len(work->response_buf, 44);
+	if (ksmbd_iov_pin_rsp(work, (void *)rsp,
+			      sizeof(struct smb2_lease_break)))
+		goto out;
 
 	ksmbd_conn_write(work);
 
 out:
 	ksmbd_free_work_struct(work);
-	/*
-	 * Checking waitqueue to dropping pending requests on
-	 * disconnection. waitqueue_active is safe because it
-	 * uses atomic operation for condition.
-	 */
-	if (!atomic_dec_return(&conn->r_count) && waitqueue_active(&conn->r_count_q))
-		wake_up(&conn->r_count_q);
 }
 
 /**
@@ -822,7 +1029,6 @@ static int smb2_lease_break_noti(struct oplock_info *opinfo)
 	work->conn = conn;
 	work->sess = opinfo->sess;
 
-	atomic_inc(&conn->r_count);
 	if (opinfo->op_state == OPLOCK_ACK_WAIT) {
 		list_for_each_safe(tmp, t, &opinfo->interim_list) {
 			struct ksmbd_work *in_work;
@@ -831,7 +1037,8 @@ static int smb2_lease_break_noti(struct oplock_info *opinfo)
 					     interim_entry);
 			setup_async_work(in_work, NULL, NULL);
 			smb2_send_interim_resp(in_work, STATUS_PENDING);
-			list_del(&in_work->interim_entry);
+			list_del_init(&in_work->interim_entry);
+			release_async_work(in_work);
 		}
 		INIT_WORK(&work->work, __smb2_lease_break_noti);
 		ksmbd_queue_work(work);
@@ -897,7 +1104,8 @@ static int oplock_break(struct oplock_info *brk_opinfo, int req_op_level)
 					lease->new_state =
 						SMB2_LEASE_READ_CACHING_LE;
 			} else {
-				if (lease->state & SMB2_LEASE_HANDLE_CACHING_LE)
+				if (lease->state & SMB2_LEASE_HANDLE_CACHING_LE &&
+						!lease->is_dir)
 					lease->new_state =
 						SMB2_LEASE_READ_CACHING_LE;
 				else
@@ -920,10 +1128,20 @@ static int oplock_break(struct oplock_info *brk_opinfo, int req_op_level)
 			brk_opinfo->op_state = OPLOCK_ACK_WAIT;
 	}
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (brk_opinfo->is_smb2)
+		if (brk_opinfo->is_lease)
+			err = smb2_lease_break_noti(brk_opinfo);
+		else
+			err = smb2_oplock_break_noti(brk_opinfo);
+	else
+		err = smb1_oplock_break_noti(brk_opinfo);
+#else
 	if (brk_opinfo->is_lease)
 		err = smb2_lease_break_noti(brk_opinfo);
 	else
 		err = smb2_oplock_break_noti(brk_opinfo);
+#endif
 
 	ksmbd_debug(OPLOCK, "oplock granted = %d\n", brk_opinfo->level);
 	if (brk_opinfo->op_state == OPLOCK_CLOSING)
@@ -1029,6 +1247,7 @@ static void copy_lease(struct oplock_info *op1, struct oplock_info *op2)
 	       SMB2_LEASE_KEY_SIZE);
 	lease2->duration = lease1->duration;
 	lease2->flags = lease1->flags;
+	lease2->epoch = lease1->epoch++;
 }
 
 static int add_lease_global_list(struct oplock_info *opinfo)
@@ -1065,6 +1284,10 @@ static void set_oplock_level(struct oplock_info *opinfo, int level,
 			     struct lease_ctx_info *lctx)
 {
 	switch (level) {
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	case REQ_OPLOCK:
+	case REQ_BATCHOPLOCK:
+#endif
 	case SMB2_OPLOCK_LEVEL_BATCH:
 	case SMB2_OPLOCK_LEVEL_EXCLUSIVE:
 		grant_write_oplock(opinfo, level, lctx);
@@ -1078,6 +1301,89 @@ static void set_oplock_level(struct oplock_info *opinfo, int level,
 	}
 }
 
+void smb_send_parent_lease_break_noti(struct ksmbd_file *fp,
+				      struct lease_ctx_info *lctx)
+{
+	struct oplock_info *opinfo;
+	struct ksmbd_inode *p_ci = NULL;
+
+	if (lctx->version != 2)
+		return;
+
+	p_ci = ksmbd_inode_lookup_lock(fp->filp->f_path.dentry->d_parent);
+	if (!p_ci)
+		return;
+
+	read_lock(&p_ci->m_lock);
+	list_for_each_entry(opinfo, &p_ci->m_op_list, op_entry) {
+		if (!opinfo->is_lease)
+			continue;
+
+		if (opinfo->o_lease->state != SMB2_OPLOCK_LEVEL_NONE &&
+		    (!(lctx->flags & SMB2_LEASE_FLAG_PARENT_LEASE_KEY_SET_LE) ||
+		     !compare_guid_key(opinfo, fp->conn->ClientGUID,
+				      lctx->parent_lease_key))) {
+			if (!atomic_inc_not_zero(&opinfo->refcount))
+				continue;
+
+			atomic_inc(&opinfo->conn->r_count);
+			if (ksmbd_conn_releasing(opinfo->conn)) {
+				atomic_dec(&opinfo->conn->r_count);
+				continue;
+			}
+
+			read_unlock(&p_ci->m_lock);
+			oplock_break(opinfo, SMB2_OPLOCK_LEVEL_NONE);
+			opinfo_conn_put(opinfo);
+			read_lock(&p_ci->m_lock);
+		}
+	}
+	read_unlock(&p_ci->m_lock);
+
+	ksmbd_inode_put(p_ci);
+}
+
+void smb_lazy_parent_lease_break_close(struct ksmbd_file *fp)
+{
+	struct oplock_info *opinfo;
+	struct ksmbd_inode *p_ci = NULL;
+
+	rcu_read_lock();
+	opinfo = rcu_dereference(fp->f_opinfo);
+	rcu_read_unlock();
+
+	if (!opinfo->is_lease || opinfo->o_lease->version != 2)
+		return;
+
+	p_ci = ksmbd_inode_lookup_lock(fp->filp->f_path.dentry->d_parent);
+	if (!p_ci)
+		return;
+
+	read_lock(&p_ci->m_lock);
+	list_for_each_entry(opinfo, &p_ci->m_op_list, op_entry) {
+		if (!opinfo->is_lease)
+			continue;
+
+		if (opinfo->o_lease->state != SMB2_OPLOCK_LEVEL_NONE) {
+			if (!atomic_inc_not_zero(&opinfo->refcount))
+				continue;
+
+			atomic_inc(&opinfo->conn->r_count);
+			if (ksmbd_conn_releasing(opinfo->conn)) {
+				atomic_dec(&opinfo->conn->r_count);
+				continue;
+			}
+			read_unlock(&p_ci->m_lock);
+			oplock_break(opinfo, SMB2_OPLOCK_LEVEL_NONE);
+			opinfo_conn_put(opinfo);
+			read_lock(&p_ci->m_lock);
+		}
+	}
+	read_unlock(&p_ci->m_lock);
+
+	ksmbd_inode_put(p_ci);
+}
+
 /**
  * smb_grant_oplock() - handle oplock/lease request on file open
  * @work:		smb work
@@ -1101,10 +1407,6 @@ int smb_grant_oplock(struct ksmbd_work *work, int req_op_level, u64 pid,
 	bool prev_op_has_lease;
 	__le32 prev_op_state = 0;
 
-	/* not support directory lease */
-	if (S_ISDIR(file_inode(fp->filp)->i_mode))
-		return 0;
-
 	opinfo = alloc_opinfo(work, pid, tid);
 	if (!opinfo)
 		return -ENOMEM;
@@ -1144,8 +1446,10 @@ int smb_grant_oplock(struct ksmbd_work *work, int req_op_level, u64 pid,
 	}
 	prev_opinfo = opinfo_get_list(ci);
 	if (!prev_opinfo ||
-	    (prev_opinfo->level == SMB2_OPLOCK_LEVEL_NONE && lctx))
+	    (prev_opinfo->level == SMB2_OPLOCK_LEVEL_NONE && lctx)) {
+		opinfo_conn_put(prev_opinfo);
 		goto set_lev;
+	}
 	prev_op_has_lease = prev_opinfo->is_lease;
 	if (prev_op_has_lease)
 		prev_op_state = prev_opinfo->o_lease->state;
@@ -1153,19 +1457,19 @@ int smb_grant_oplock(struct ksmbd_work *work, int req_op_level, u64 pid,
 	if (share_ret < 0 &&
 	    prev_opinfo->level == SMB2_OPLOCK_LEVEL_EXCLUSIVE) {
 		err = share_ret;
-		opinfo_put(prev_opinfo);
+		opinfo_conn_put(prev_opinfo);
 		goto err_out;
 	}
 
 	if (prev_opinfo->level != SMB2_OPLOCK_LEVEL_BATCH &&
 	    prev_opinfo->level != SMB2_OPLOCK_LEVEL_EXCLUSIVE) {
-		opinfo_put(prev_opinfo);
+		opinfo_conn_put(prev_opinfo);
 		goto op_break_not_needed;
 	}
 
 	list_add(&work->interim_entry, &prev_opinfo->interim_list);
 	err = oplock_break(prev_opinfo, SMB2_OPLOCK_LEVEL_II);
-	opinfo_put(prev_opinfo);
+	opinfo_conn_put(prev_opinfo);
 	if (err == -ENOENT)
 		goto set_lev;
 	/* Check all oplock was freed by close */
@@ -1228,14 +1532,14 @@ static void smb_break_all_write_oplock(struct ksmbd_work *work,
 		return;
 	if (brk_opinfo->level != SMB2_OPLOCK_LEVEL_BATCH &&
 	    brk_opinfo->level != SMB2_OPLOCK_LEVEL_EXCLUSIVE) {
-		opinfo_put(brk_opinfo);
+		opinfo_conn_put(brk_opinfo);
 		return;
 	}
 
 	brk_opinfo->open_trunc = is_trunc;
 	list_add(&work->interim_entry, &brk_opinfo->interim_list);
 	oplock_break(brk_opinfo, SMB2_OPLOCK_LEVEL_II);
-	opinfo_put(brk_opinfo);
+	opinfo_conn_put(brk_opinfo);
 }
 
 /**
@@ -1263,15 +1567,52 @@ void smb_break_all_levII_oplock(struct ksmbd_work *work, struct ksmbd_file *fp,
 	list_for_each_entry_rcu(brk_op, &ci->m_op_list, op_entry) {
 		if (!atomic_inc_not_zero(&brk_op->refcount))
 			continue;
+
+		atomic_inc(&brk_op->conn->r_count);
+		if (ksmbd_conn_releasing(brk_op->conn)) {
+			atomic_dec(&brk_op->conn->r_count);
+			continue;
+		}
+
 		rcu_read_unlock();
-		if (brk_op->is_lease && (brk_op->o_lease->state &
-		    (~(SMB2_LEASE_READ_CACHING_LE |
-				SMB2_LEASE_HANDLE_CACHING_LE)))) {
+
+#ifdef CONFIG_SMB_INSECURE_SERVER
+		if (brk_op->is_smb2) {
+			if (brk_op->is_lease && (brk_op->o_lease->state &
+					(~(SMB2_LEASE_READ_CACHING_LE |
+					   SMB2_LEASE_HANDLE_CACHING_LE)))) {
+				ksmbd_debug(OPLOCK,
+					    "unexpected lease state(0x%x)\n",
+					    brk_op->o_lease->state);
+				goto next;
+			} else if (brk_op->level !=
+					SMB2_OPLOCK_LEVEL_II) {
+				ksmbd_debug(OPLOCK, "unexpected oplock(0x%x)\n",
+					    brk_op->level);
+				goto next;
+			}
+
+			/* Skip oplock being break to none */
+			if (brk_op->is_lease &&
+			    brk_op->o_lease->new_state == SMB2_LEASE_NONE_LE &&
+			    atomic_read(&brk_op->breaking_cnt))
+				goto next;
+		} else {
+			if (brk_op->level != OPLOCK_READ) {
+				ksmbd_debug(OPLOCK, "unexpected oplock(0x%x)\n",
+					    brk_op->level);
+				goto next;
+			}
+		}
+#else
+		if (brk_op->is_lease &&
+		    (brk_op->o_lease->state &
+		     (~(SMB2_LEASE_READ_CACHING_LE |
+			SMB2_LEASE_HANDLE_CACHING_LE)))) {
 			ksmbd_debug(OPLOCK, "unexpected lease state(0x%x)\n",
 				    brk_op->o_lease->state);
 			goto next;
-		} else if (brk_op->level !=
-				SMB2_OPLOCK_LEVEL_II) {
+		} else if (brk_op->level != SMB2_OPLOCK_LEVEL_II) {
 			ksmbd_debug(OPLOCK, "unexpected oplock(0x%x)\n",
 				    brk_op->level);
 			goto next;
@@ -1282,6 +1623,7 @@ void smb_break_all_levII_oplock(struct ksmbd_work *work, struct ksmbd_file *fp,
 		    brk_op->o_lease->new_state == SMB2_LEASE_NONE_LE &&
 		    atomic_read(&brk_op->breaking_cnt))
 			goto next;
+#endif
 
 		if (op && op->is_lease && brk_op->is_lease &&
 		    !memcmp(conn->ClientGUID, brk_op->conn->ClientGUID,
@@ -1292,7 +1634,7 @@ void smb_break_all_levII_oplock(struct ksmbd_work *work, struct ksmbd_file *fp,
 		brk_op->open_trunc = is_trunc;
 		oplock_break(brk_op, SMB2_OPLOCK_LEVEL_NONE);
 next:
-		opinfo_put(brk_op);
+		opinfo_conn_put(brk_op);
 		rcu_read_lock();
 	}
 	rcu_read_unlock();
@@ -1352,6 +1694,7 @@ void create_lease_buf(u8 *rbuf, struct lease *lease)
 		memcpy(buf->lcontext.LeaseKey, lease->lease_key,
 		       SMB2_LEASE_KEY_SIZE);
 		buf->lcontext.LeaseFlags = lease->flags;
+		buf->lcontext.Epoch = cpu_to_le16(++lease->epoch);
 		buf->lcontext.LeaseState = lease->state;
 		memcpy(buf->lcontext.ParentLeaseKey, lease->parent_lease_key,
 		       SMB2_LEASE_KEY_SIZE);
@@ -1388,72 +1731,62 @@ void create_lease_buf(u8 *rbuf, struct lease *lease)
 /**
  * parse_lease_state() - parse lease context containted in file open request
  * @open_req:	buffer containing smb2 file open(create) request
+ * @is_dir:	whether leasing file is directory
  *
  * Return:  oplock state, -ENOENT if create lease context not found
  */
-struct lease_ctx_info *parse_lease_state(void *open_req)
+struct lease_ctx_info *parse_lease_state(void *open_req, bool is_dir)
 {
-	char *data_offset;
 	struct create_context *cc;
-	unsigned int next = 0;
-	char *name;
-	bool found = false;
 	struct smb2_create_req *req = (struct smb2_create_req *)open_req;
-	struct lease_ctx_info *lreq = kzalloc(sizeof(struct lease_ctx_info),
-		GFP_KERNEL);
-	if (!lreq)
+	struct lease_ctx_info *lreq;
+
+	cc = smb2_find_context_vals(req, SMB2_CREATE_REQUEST_LEASE, 4);
+	if (IS_ERR_OR_NULL(cc))
 		return NULL;
 
-	data_offset = (char *)req + le32_to_cpu(req->CreateContextsOffset);
-	cc = (struct create_context *)data_offset;
-	do {
-		cc = (struct create_context *)((char *)cc + next);
-		name = le16_to_cpu(cc->NameOffset) + (char *)cc;
-		if (le16_to_cpu(cc->NameLength) != 4 ||
-		    strncmp(name, SMB2_CREATE_REQUEST_LEASE, 4)) {
-			next = le32_to_cpu(cc->Next);
-			continue;
-		}
-		found = true;
-		break;
-	} while (next != 0);
+	lreq = kzalloc(sizeof(struct lease_ctx_info), GFP_KERNEL);
+	if (!lreq)
+		return NULL;
 
-	if (found) {
-		if (sizeof(struct lease_context_v2) == le32_to_cpu(cc->DataLength)) {
-			struct create_lease_v2 *lc = (struct create_lease_v2 *)cc;
+	if (sizeof(struct lease_context_v2) == le32_to_cpu(cc->DataLength)) {
+		struct create_lease_v2 *lc = (struct create_lease_v2 *)cc;
 
-			memcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);
+		memcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);
+		if (is_dir) {
+			lreq->req_state = lc->lcontext.LeaseState &
+				~SMB2_LEASE_WRITE_CACHING_LE;
+			lreq->is_dir = true;
+		} else
 			lreq->req_state = lc->lcontext.LeaseState;
-			lreq->flags = lc->lcontext.LeaseFlags;
-			lreq->duration = lc->lcontext.LeaseDuration;
-			memcpy(lreq->parent_lease_key, lc->lcontext.ParentLeaseKey,
-			       SMB2_LEASE_KEY_SIZE);
-			lreq->version = 2;
-		} else {
-			struct create_lease *lc = (struct create_lease *)cc;
+		lreq->flags = lc->lcontext.LeaseFlags;
+		lreq->epoch = lc->lcontext.Epoch;
+		lreq->duration = lc->lcontext.LeaseDuration;
+		memcpy(lreq->parent_lease_key, lc->lcontext.ParentLeaseKey,
+				SMB2_LEASE_KEY_SIZE);
+		lreq->version = 2;
+	} else {
+		struct create_lease *lc = (struct create_lease *)cc;
 
-			memcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);
-			lreq->req_state = lc->lcontext.LeaseState;
-			lreq->flags = lc->lcontext.LeaseFlags;
-			lreq->duration = lc->lcontext.LeaseDuration;
-			lreq->version = 1;
-		}
-		return lreq;
+		memcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);
+		lreq->req_state = lc->lcontext.LeaseState;
+		lreq->flags = lc->lcontext.LeaseFlags;
+		lreq->duration = lc->lcontext.LeaseDuration;
+		lreq->version = 1;
 	}
-
-	kfree(lreq);
-	return NULL;
+	return lreq;
 }
 
 /**
  * smb2_find_context_vals() - find a particular context info in open request
  * @open_req:	buffer containing smb2 file open(create) request
  * @tag:	context name to search for
+ * @tag_len:	the length of tag
  *
  * Return:	pointer to requested context, NULL if @str context not found
  *		or error pointer if name length is invalid.
  */
-struct create_context *smb2_find_context_vals(void *open_req, const char *tag)
+struct create_context *smb2_find_context_vals(void *open_req, const char *tag, int tag_len)
 {
 	struct create_context *cc;
 	unsigned int next = 0;
@@ -1487,12 +1820,12 @@ struct create_context *smb2_find_context_vals(void *open_req, const char *tag)
 		    name_len < 4 ||
 		    name_off + name_len > cc_len ||
 		    (value_off & 0x7) != 0 ||
-		    (value_off && (value_off < name_off + name_len)) ||
+		    (value_len && value_off < name_off + (name_len < 8 ? 8 : name_len)) ||
 		    ((u64)value_off + value_len > cc_len))
 			return ERR_PTR(-EINVAL);
 
 		name = (char *)cc + name_off;
-		if (memcmp(name, tag, name_len) == 0)
+		if (name_len == tag_len && !memcmp(name, tag, name_len))
 			return cc;
 
 		remain_len -= next;
@@ -1608,9 +1941,19 @@ void create_posix_rsp_buf(char *cc, struct ksmbd_file *fp)
 {
 	struct create_posix_rsp *buf;
 	struct inode *inode = file_inode(fp->filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(fp->filp);
+	vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);
+	vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 	struct user_namespace *user_ns = file_mnt_user_ns(fp->filp);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	vfsuid_t vfsuid = i_uid_into_vfsuid(user_ns, inode);
 	vfsgid_t vfsgid = i_gid_into_vfsgid(user_ns, inode);
+#endif
+#endif
 
 	buf = (struct create_posix_rsp *)cc;
 	memset(buf, 0, sizeof(struct create_posix_rsp));
@@ -1648,13 +1991,31 @@ void create_posix_rsp_buf(char *cc, struct ksmbd_file *fp)
 	/*
 	 * SidBuffer(44) contain two sids(Domain sid(28), UNIX group sid(16)).
 	 * Domain sid(28) = revision(1) + num_subauth(1) + authority(6) +
-	 *		    sub_auth(4 * 4(num_subauth)) + RID(4).
+	 * 		    sub_auth(4 * 4(num_subauth)) + RID(4).
 	 * UNIX group id(16) = revision(1) + num_subauth(1) + authority(6) +
-	 *		       sub_auth(4 * 1(num_subauth)) + RID(4).
+	 * 		       sub_auth(4 * 1(num_subauth)) + RID(4).
 	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	id_to_sid(from_kuid_munged(&init_user_ns, vfsuid_into_kuid(vfsuid)),
+#else
+	id_to_sid(from_kuid_munged(&init_user_ns,
+				   i_uid_into_mnt(user_ns, inode)),
+#endif
+#else
+	id_to_sid(from_kuid_munged(&init_user_ns, inode->i_uid),
+#endif
 		  SIDOWNER, (struct smb_sid *)&buf->SidBuffer[0]);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	id_to_sid(from_kgid_munged(&init_user_ns, vfsgid_into_kgid(vfsgid)),
+#else
+	id_to_sid(from_kgid_munged(&init_user_ns,
+				   i_gid_into_mnt(user_ns, inode)),
+#endif
+#else
+	id_to_sid(from_kgid_munged(&init_user_ns, inode->i_gid),
+#endif
 		  SIDUNIX_GROUP, (struct smb_sid *)&buf->SidBuffer[28]);
 }
 
diff --git a/fs/ksmbd/oplock.h b/fs/ksmbd/oplock.h
index 09753448f779..19144100906e 100644
--- a/fs/ksmbd/oplock.h
+++ b/fs/ksmbd/oplock.h
@@ -11,6 +11,14 @@
 
 #define OPLOCK_WAIT_TIME	(35 * HZ)
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+/* SMB Oplock levels */
+#define OPLOCK_NONE      0
+#define OPLOCK_EXCLUSIVE 1
+#define OPLOCK_BATCH     2
+#define OPLOCK_READ      3  /* level 2 oplock */
+#endif
+
 /* SMB2 Oplock levels */
 #define SMB2_OPLOCK_LEVEL_NONE          0x00
 #define SMB2_OPLOCK_LEVEL_II            0x01
@@ -34,7 +42,9 @@ struct lease_ctx_info {
 	__le32			flags;
 	__le64			duration;
 	__u8			parent_lease_key[SMB2_LEASE_KEY_SIZE];
+	__le16			epoch;
 	int			version;
+	bool			is_dir;
 };
 
 struct lease_table {
@@ -53,6 +63,7 @@ struct lease {
 	__u8			parent_lease_key[SMB2_LEASE_KEY_SIZE];
 	int			version;
 	unsigned short		epoch;
+	bool			is_dir;
 	struct lease_table	*l_lb;
 };
 
@@ -69,6 +80,9 @@ struct oplock_info {
 	atomic_t		refcount;
 	__u16                   Tid;
 	bool			is_lease;
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	bool			is_smb2;
+#endif
 	bool			open_trunc;	/* truncate on open */
 	struct lease		*o_lease;
 	struct list_head        interim_list;
@@ -108,7 +122,7 @@ void opinfo_put(struct oplock_info *opinfo);
 
 /* Lease related functions */
 void create_lease_buf(u8 *rbuf, struct lease *lease);
-struct lease_ctx_info *parse_lease_state(void *open_req);
+struct lease_ctx_info *parse_lease_state(void *open_req, bool is_dir);
 __u8 smb2_map_lease_to_oplock(__le32 lease_state);
 int lease_read_to_write(struct oplock_info *opinfo);
 
@@ -118,10 +132,13 @@ void create_durable_v2_rsp_buf(char *cc, struct ksmbd_file *fp);
 void create_mxac_rsp_buf(char *cc, int maximal_access);
 void create_disk_id_rsp_buf(char *cc, __u64 file_id, __u64 vol_id);
 void create_posix_rsp_buf(char *cc, struct ksmbd_file *fp);
-struct create_context *smb2_find_context_vals(void *open_req, const char *str);
+struct create_context *smb2_find_context_vals(void *open_req, const char *tag, int tag_len);
 struct oplock_info *lookup_lease_in_table(struct ksmbd_conn *conn,
 					  char *lease_key);
 int find_same_lease_key(struct ksmbd_session *sess, struct ksmbd_inode *ci,
 			struct lease_ctx_info *lctx);
 void destroy_lease_table(struct ksmbd_conn *conn);
+void smb_send_parent_lease_break_noti(struct ksmbd_file *fp,
+				      struct lease_ctx_info *lctx);
+void smb_lazy_parent_lease_break_close(struct ksmbd_file *fp);
 #endif /* __KSMBD_OPLOCK_H */
diff --git a/fs/ksmbd/server.c b/fs/ksmbd/server.c
index dc76d7cf241f..36fc697005f6 100644
--- a/fs/ksmbd/server.c
+++ b/fs/ksmbd/server.c
@@ -115,8 +115,10 @@ static int __process_request(struct ksmbd_work *work, struct ksmbd_conn *conn,
 	if (check_conn_state(work))
 		return SERVER_HANDLER_CONTINUE;
 
-	if (ksmbd_verify_smb_message(work))
+	if (ksmbd_verify_smb_message(work)) {
+		conn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER);
 		return SERVER_HANDLER_ABORT;
+	}
 
 	command = conn->ops->get_cmd_val(work);
 	*cmd = command;
@@ -163,6 +165,7 @@ static void __handle_ksmbd_work(struct ksmbd_work *work,
 {
 	u16 command = 0;
 	int rc;
+	bool is_chained = false;
 
 	if (conn->ops->allocate_rsp_buf(work))
 		return;
@@ -185,24 +188,31 @@ static void __handle_ksmbd_work(struct ksmbd_work *work,
 		goto send;
 	}
 
-	if (conn->ops->check_user_session) {
-		rc = conn->ops->check_user_session(work);
-		if (rc < 0) {
-			command = conn->ops->get_cmd_val(work);
-			conn->ops->set_rsp_status(work,
-					STATUS_USER_SESSION_DELETED);
-			goto send;
-		} else if (rc > 0) {
-			rc = conn->ops->get_ksmbd_tcon(work);
+	do {
+		if (conn->ops->check_user_session) {
+			rc = conn->ops->check_user_session(work);
 			if (rc < 0) {
-				conn->ops->set_rsp_status(work,
-					STATUS_NETWORK_NAME_DELETED);
+				if (rc == -EINVAL)
+					conn->ops->set_rsp_status(work,
+						STATUS_INVALID_PARAMETER);
+				else
+					conn->ops->set_rsp_status(work,
+						STATUS_USER_SESSION_DELETED);
 				goto send;
+			} else if (rc > 0) {
+				rc = conn->ops->get_ksmbd_tcon(work);
+				if (rc < 0) {
+					if (rc == -EINVAL)
+						conn->ops->set_rsp_status(work,
+							STATUS_INVALID_PARAMETER);
+					else
+						conn->ops->set_rsp_status(work,
+							STATUS_NETWORK_NAME_DELETED);
+					goto send;
+				}
 			}
 		}
-	}
 
-	do {
 		rc = __process_request(work, conn, &command);
 		if (rc == SERVER_HANDLER_ABORT)
 			break;
@@ -222,16 +232,17 @@ static void __handle_ksmbd_work(struct ksmbd_work *work,
 			}
 		}
 
+		is_chained = is_chained_smb2_message(work);
+
 		if (work->sess &&
 		    (work->sess->sign || smb3_11_final_sess_setup_resp(work) ||
 		     conn->ops->is_sign_req(work, command)))
 			conn->ops->set_sign_rsp(work);
-	} while (is_chained_smb2_message(work));
-
-	if (work->send_no_response)
-		return;
+	} while (is_chained == true);
 
 send:
+	if (work->tcon)
+		ksmbd_tree_connect_put(work->tcon);
 	smb3_preauth_hash_rsp(work);
 	if (work->sess && work->sess->enc && work->encrypted &&
 	    conn->ops->encrypt_resp) {
@@ -279,6 +290,7 @@ static void handle_ksmbd_work(struct work_struct *wk)
 static int queue_ksmbd_work(struct ksmbd_conn *conn)
 {
 	struct ksmbd_work *work;
+	int err;
 
 	work = ksmbd_alloc_work_struct();
 	if (!work) {
@@ -290,7 +302,11 @@ static int queue_ksmbd_work(struct ksmbd_conn *conn)
 	work->request_buf = conn->request_buf;
 	conn->request_buf = NULL;
 
-	ksmbd_init_smb_server(work);
+	err = ksmbd_init_smb_server(work);
+	if (err) {
+		ksmbd_free_work_struct(work);
+		return 0;
+	}
 
 	ksmbd_conn_enqueue_request(work);
 	atomic_inc(&conn->r_count);
@@ -416,7 +432,11 @@ int server_queue_ctrl_reset_work(void)
 	return __queue_ctrl_work(SERVER_CTRL_TYPE_RESET);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static ssize_t stats_show(const struct class *class, const struct class_attribute *attr,
+#else
 static ssize_t stats_show(struct class *class, struct class_attribute *attr,
+#endif
 			  char *buf)
 {
 	/*
@@ -435,8 +455,13 @@ static ssize_t stats_show(struct class *class, struct class_attribute *attr,
 			  server_conf.ipc_last_active / HZ);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static ssize_t kill_server_store(const struct class *class,
+				 const struct class_attribute *attr, const char *buf,
+#else
 static ssize_t kill_server_store(struct class *class,
 				 struct class_attribute *attr, const char *buf,
+#endif
 				 size_t len)
 {
 	if (!sysfs_streq(buf, "hard"))
@@ -456,7 +481,11 @@ static const char * const debug_type_strings[] = {"smb", "auth", "vfs",
 						  "oplock", "ipc", "conn",
 						  "rdma"};
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static ssize_t debug_show(const struct class *class, const struct class_attribute *attr,
+#else
 static ssize_t debug_show(struct class *class, struct class_attribute *attr,
+#endif
 			  char *buf)
 {
 	ssize_t sz = 0;
@@ -474,7 +503,11 @@ static ssize_t debug_show(struct class *class, struct class_attribute *attr,
 	return sz;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static ssize_t debug_store(const struct class *class, const struct class_attribute *attr,
+#else
 static ssize_t debug_store(struct class *class, struct class_attribute *attr,
+#endif
 			   const char *buf, size_t len)
 {
 	int i;
@@ -514,7 +547,9 @@ ATTRIBUTE_GROUPS(ksmbd_control_class);
 
 static struct class ksmbd_control_class = {
 	.name		= "ksmbd-control",
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
 	.owner		= THIS_MODULE,
+#endif
 	.class_groups	= ksmbd_control_class_groups,
 };
 
@@ -578,9 +613,6 @@ static int __init ksmbd_server_init(void)
 	ret = ksmbd_workqueue_init();
 	if (ret)
 		goto err_crypto_destroy;
-
-	pr_warn_once("The ksmbd server is experimental\n");
-
 	return 0;
 
 err_crypto_destroy:
@@ -617,6 +649,7 @@ MODULE_DESCRIPTION("Linux kernel CIFS/SMB SERVER");
 MODULE_LICENSE("GPL");
 MODULE_SOFTDEP("pre: ecb");
 MODULE_SOFTDEP("pre: hmac");
+MODULE_SOFTDEP("pre: md4");
 MODULE_SOFTDEP("pre: md5");
 MODULE_SOFTDEP("pre: nls");
 MODULE_SOFTDEP("pre: aes");
diff --git a/fs/ksmbd/smb1misc.c b/fs/ksmbd/smb1misc.c
new file mode 100644
index 000000000000..bc86caa8feb1
--- /dev/null
+++ b/fs/ksmbd/smb1misc.c
@@ -0,0 +1,298 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>
+ *   Copyright (C) 2018 Samsung Electronics Co., Ltd.
+ */
+
+#include "glob.h"
+#include "asn1.h"
+#include "nterr.h"
+#include "ksmbd_work.h"
+#include "smb_common.h"
+#include "smb1pdu.h"
+#include "mgmt/user_session.h"
+
+/**
+ * check_smb_hdr() - check for valid smb request header
+ * @smb:        smb header to be checked
+ *
+ * check for valid smb signature and packet direction(request/response)
+ * TODO: properly check client authetication and tree authentication
+ *
+ * Return:      0 on success, otherwise 1
+ */
+static int check_smb1_hdr(struct smb_hdr *smb)
+{
+	/* does it have the right SMB "signature" ? */
+	if (*(__le32 *) smb->Protocol != SMB1_PROTO_NUMBER) {
+		ksmbd_debug(SMB, "Bad protocol string signature header 0x%x\n",
+				*(unsigned int *)smb->Protocol);
+		return 1;
+	}
+	ksmbd_debug(SMB, "got SMB\n");
+
+	/* if it's not a response then accept */
+	/* TODO : check for oplock break */
+	if (!(smb->Flags & SMBFLG_RESPONSE))
+		return 0;
+
+	ksmbd_debug(SMB, "Server sent request, not response\n");
+	return 1;
+}
+
+
+static int smb1_req_struct_size(struct smb_hdr *hdr)
+{
+	int wc = hdr->WordCount;
+
+	switch (hdr->Command) {
+	case SMB_COM_CREATE_DIRECTORY:
+	case SMB_COM_DELETE_DIRECTORY:
+	case SMB_COM_QUERY_INFORMATION:
+	case SMB_COM_TREE_DISCONNECT:
+	case SMB_COM_NEGOTIATE:
+	case SMB_COM_NT_CANCEL:
+	case SMB_COM_CHECK_DIRECTORY:
+	case SMB_COM_PROCESS_EXIT:
+	case SMB_COM_QUERY_INFORMATION_DISK:
+		if (wc != 0x0)
+			return -EINVAL;
+		break;
+	case SMB_COM_FLUSH:
+	case SMB_COM_DELETE:
+	case SMB_COM_RENAME:
+	case SMB_COM_ECHO:
+	case SMB_COM_FIND_CLOSE2:
+		if (wc != 0x1)
+			return -EINVAL;
+		break;
+	case SMB_COM_LOGOFF_ANDX:
+		if (wc != 0x2)
+			return -EINVAL;
+		break;
+	case SMB_COM_CLOSE:
+		if (wc != 0x3)
+			return -EINVAL;
+		break;
+	case SMB_COM_TREE_CONNECT_ANDX:
+	case SMB_COM_NT_RENAME:
+		if (wc != 0x4)
+			return -EINVAL;
+		break;
+	case SMB_COM_WRITE:
+		if (wc != 0x5)
+			return -EINVAL;
+		break;
+	case SMB_COM_SETATTR:
+	case SMB_COM_LOCKING_ANDX:
+		if (wc != 0x8)
+			return -EINVAL;
+		break;
+	case SMB_COM_TRANSACTION:
+		if (wc < 0xe)
+			return -EINVAL;
+		break;
+	case SMB_COM_SESSION_SETUP_ANDX:
+		if (wc != 0xc && wc != 0xd)
+			return -EINVAL;
+		break;
+	case SMB_COM_OPEN_ANDX:
+	case SMB_COM_TRANSACTION2:
+		if (wc != 0xf)
+			return -EINVAL;
+		break;
+	case SMB_COM_NT_CREATE_ANDX:
+		if (wc != 0x18)
+			return -EINVAL;
+		break;
+	case SMB_COM_READ_ANDX:
+		if (wc != 0xa && wc != 0xc)
+			return -EINVAL;
+		break;
+	case SMB_COM_WRITE_ANDX:
+		if (wc != 0xc && wc != 0xe)
+			return -EINVAL;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return wc;
+}
+
+static int smb1_get_byte_count(struct smb_hdr *hdr)
+{
+	int bc;
+
+	bc = le16_to_cpu(*(__le16 *)((char *)hdr +
+		sizeof(struct smb_hdr) + hdr->WordCount * 2));
+
+	switch (hdr->Command) {
+	case SMB_COM_CLOSE:
+	case SMB_COM_FLUSH:
+	case SMB_COM_READ_ANDX:
+	case SMB_COM_TREE_DISCONNECT:
+	case SMB_COM_LOGOFF_ANDX:
+	case SMB_COM_NT_CANCEL:
+	case SMB_COM_PROCESS_EXIT:
+	case SMB_COM_FIND_CLOSE2:
+		if (bc != 0x0)
+			return -EINVAL;
+		break;
+	case SMB_COM_LOCKING_ANDX:
+	case SMB_COM_TRANSACTION:
+	case SMB_COM_TRANSACTION2:
+	case SMB_COM_ECHO:
+	case SMB_COM_SESSION_SETUP_ANDX:
+		if (bc < 0x0)
+			return -EINVAL;
+		break;
+	case SMB_COM_WRITE_ANDX:
+		if (bc < 0x1)
+			return -EINVAL;
+		break;
+	case SMB_COM_CREATE_DIRECTORY:
+	case SMB_COM_DELETE_DIRECTORY:
+	case SMB_COM_DELETE:
+	case SMB_COM_RENAME:
+	case SMB_COM_QUERY_INFORMATION:
+	case SMB_COM_SETATTR:
+	case SMB_COM_OPEN_ANDX:
+	case SMB_COM_NEGOTIATE:
+	case SMB_COM_CHECK_DIRECTORY:
+		if (bc < 0x2)
+			return -EINVAL;
+		break;
+	case SMB_COM_TREE_CONNECT_ANDX:
+	case SMB_COM_WRITE:
+		if (bc < 0x3)
+			return -EINVAL;
+		break;
+	case SMB_COM_NT_RENAME:
+		if (bc < 0x4)
+			return -EINVAL;
+		break;
+	case SMB_COM_NT_CREATE_ANDX:
+		if (hdr->Flags2 & SMBFLG2_UNICODE) {
+			if (bc < 3)
+				return -EINVAL;
+		} else if (bc < 2)
+			return -EINVAL;
+		break;
+	}
+
+	return bc;
+}
+
+static unsigned int smb1_calc_size(struct smb_hdr *hdr)
+{
+	int len = sizeof(struct smb_hdr) - 4 + 2;
+	int bc, struct_size = hdr->WordCount * 2;
+
+	len += struct_size;
+	bc = smb1_get_byte_count(hdr);
+	if (bc < 0)
+		return bc;
+	ksmbd_debug(SMB, "SMB2 byte count %d, struct size : %d\n", bc,
+		struct_size);
+	len += bc;
+
+	ksmbd_debug(SMB, "SMB1 len %d\n", len);
+	return len;
+}
+
+static int smb1_get_data_len(struct smb_hdr *hdr)
+{
+	int data_len = 0;
+
+	/* data offset check */
+	switch (hdr->Command) {
+	case SMB_COM_WRITE_ANDX:
+	{
+		struct smb_com_write_req *req = (struct smb_com_write_req *)hdr;
+
+		data_len = le16_to_cpu(req->DataLengthLow);
+		data_len |= (le16_to_cpu(req->DataLengthHigh) << 16);
+		data_len += le16_to_cpu(req->DataOffset);
+		break;
+	}
+	case SMB_COM_TRANSACTION:
+	{
+		struct smb_com_trans_req *req = (struct smb_com_trans_req *)hdr;
+
+		data_len = le16_to_cpu(req->DataOffset) +
+			le16_to_cpu(req->DataCount);
+		break;
+	}
+	case SMB_COM_TRANSACTION2:
+	{
+		struct smb_com_trans2_req *req =
+				(struct smb_com_trans2_req *)hdr;
+
+		data_len = le16_to_cpu(req->DataOffset) +
+			le16_to_cpu(req->DataCount);
+		break;
+	}
+	}
+
+	return data_len;
+}
+
+int ksmbd_smb1_check_message(struct ksmbd_work *work)
+{
+	struct smb_hdr *hdr = (struct smb_hdr *)work->request_buf;
+	char *buf = work->request_buf;
+	int command = hdr->Command;
+	__u32 clc_len;  /* calculated length */
+	__u32 len = get_rfc1002_len(buf);
+	int wc, data_len;
+
+	if (check_smb1_hdr(hdr))
+		return 1;
+
+	wc = smb1_req_struct_size(hdr);
+	if (wc == -EOPNOTSUPP) {
+		ksmbd_debug(SMB, "Not support cmd %x\n", command);
+		return 1;
+	} else if (hdr->WordCount != wc) {
+		pr_err("Invalid word count, %d not %d. cmd %x\n",
+		       hdr->WordCount, wc, command);
+		return 1;
+	}
+
+	data_len = smb1_get_data_len(hdr);
+	if (len < data_len) {
+		pr_err("Invalid data area length %u not %u. cmd : %x\n",
+		       len, data_len, command);
+		return 1;
+	}
+
+	clc_len = smb1_calc_size(hdr);
+	if (len != clc_len) {
+		/*
+		 * smbclient may return wrong byte count in smb header.
+		 * But allow it to avoid write failure with smbclient.
+		 */
+		if (command == SMB_COM_WRITE_ANDX)
+			return 0;
+
+		if (len > clc_len) {
+			ksmbd_debug(SMB,
+				"cli req too long, len %d not %d. cmd:%x\n",
+				len, clc_len, command);
+			return 0;
+		}
+
+		pr_err("cli req too short, len %d not %d. cmd:%x\n",
+		       len, clc_len, command);
+
+		return 1;
+	}
+
+	return 0;
+}
+
+int smb_negotiate_request(struct ksmbd_work *work)
+{
+	return ksmbd_smb_negotiate_common(work, SMB_COM_NEGOTIATE);
+}
diff --git a/fs/ksmbd/smb1ops.c b/fs/ksmbd/smb1ops.c
new file mode 100644
index 000000000000..8a314bc99b5c
--- /dev/null
+++ b/fs/ksmbd/smb1ops.c
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>
+ *   Copyright (C) 2018 Samsung Electronics Co., Ltd.
+ */
+
+#include <linux/slab.h>
+
+#include "glob.h"
+#include "connection.h"
+#include "smb_common.h"
+#include "smb1pdu.h"
+
+static struct smb_version_values smb1_server_values = {
+	.version_string = SMB1_VERSION_STRING,
+	.protocol_id = SMB10_PROT_ID,
+	.capabilities = SMB1_SERVER_CAPS,
+	.max_read_size = CIFS_DEFAULT_IOSIZE,
+	.max_write_size = MAX_STREAM_PROT_LEN,
+	.max_trans_size = CIFS_DEFAULT_IOSIZE,
+	.large_lock_type = LOCKING_ANDX_LARGE_FILES,
+	.exclusive_lock_type = 0,
+	.shared_lock_type = LOCKING_ANDX_SHARED_LOCK,
+	.unlock_lock_type = 0,
+	.header_size = sizeof(struct smb_hdr),
+	.max_header_size = MAX_CIFS_HDR_SIZE,
+	.read_rsp_size = sizeof(struct smb_com_read_rsp),
+	.lock_cmd = cpu_to_le16(SMB_COM_LOCKING_ANDX),
+	.cap_unix = CAP_UNIX,
+	.cap_nt_find = CAP_NT_SMBS | CAP_NT_FIND,
+	.cap_large_files = CAP_LARGE_FILES,
+	.signing_enabled = SECMODE_SIGN_ENABLED,
+	.signing_required = SECMODE_SIGN_REQUIRED,
+};
+
+static struct smb_version_ops smb1_server_ops = {
+	.get_cmd_val = get_smb_cmd_val,
+	.init_rsp_hdr = init_smb_rsp_hdr,
+	.set_rsp_status = set_smb_rsp_status,
+	.allocate_rsp_buf = smb_allocate_rsp_buf,
+	.check_user_session = smb_check_user_session,
+	.is_sign_req = smb1_is_sign_req,
+	.check_sign_req = smb1_check_sign_req,
+	.set_sign_rsp = smb1_set_sign_rsp,
+	.get_ksmbd_tcon = smb_get_ksmbd_tcon,
+};
+
+static struct smb_version_cmds smb1_server_cmds[256] = {
+	[SMB_COM_CREATE_DIRECTORY]	= { .proc = smb_mkdir, },
+	[SMB_COM_DELETE_DIRECTORY]	= { .proc = smb_rmdir, },
+	[SMB_COM_CLOSE]			= { .proc = smb_close, },
+	[SMB_COM_FLUSH]			= { .proc = smb_flush, },
+	[SMB_COM_DELETE]		= { .proc = smb_unlink, },
+	[SMB_COM_RENAME]		= { .proc = smb_rename, },
+	[SMB_COM_QUERY_INFORMATION]	= { .proc = smb_query_info, },
+	[SMB_COM_SETATTR]		= { .proc = smb_setattr, },
+	[SMB_COM_LOCKING_ANDX]		= { .proc = smb_locking_andx, },
+	[SMB_COM_TRANSACTION]		= { .proc = smb_trans, },
+	[SMB_COM_ECHO]			= { .proc = smb_echo, },
+	[SMB_COM_OPEN_ANDX]		= { .proc = smb_open_andx, },
+	[SMB_COM_READ_ANDX]		= { .proc = smb_read_andx, },
+	[SMB_COM_WRITE_ANDX]		= { .proc = smb_write_andx, },
+	[SMB_COM_TRANSACTION2]		= { .proc = smb_trans2, },
+	[SMB_COM_FIND_CLOSE2]		= { .proc = smb_closedir, },
+	[SMB_COM_TREE_DISCONNECT]	= { .proc = smb_tree_disconnect, },
+	[SMB_COM_NEGOTIATE]		= { .proc = smb_negotiate_request, },
+	[SMB_COM_SESSION_SETUP_ANDX]	= { .proc = smb_session_setup_andx, },
+	[SMB_COM_LOGOFF_ANDX]           = { .proc = smb_session_disconnect, },
+	[SMB_COM_TREE_CONNECT_ANDX]	= { .proc = smb_tree_connect_andx, },
+	[SMB_COM_QUERY_INFORMATION_DISK] = { .proc = smb_query_information_disk, },
+	[SMB_COM_NT_CREATE_ANDX]	= { .proc = smb_nt_create_andx, },
+	[SMB_COM_NT_CANCEL]		= { .proc = smb_nt_cancel, },
+	[SMB_COM_NT_RENAME]		= { .proc = smb_nt_rename, },
+	[SMB_COM_WRITE]			= { .proc = smb_write, },
+	[SMB_COM_CHECK_DIRECTORY]	= { .proc = smb_checkdir, },
+	[SMB_COM_PROCESS_EXIT]		= { .proc = smb_process_exit, },
+};
+
+/**
+ * init_smb1_server() - initialize a smb server connection with smb1
+ *			command dispatcher
+ * @conn:	connection instance
+ */
+int init_smb1_server(struct ksmbd_conn *conn)
+{
+	conn->vals = &smb1_server_values;
+	conn->ops = &smb1_server_ops;
+	conn->cmds = smb1_server_cmds;
+	conn->max_cmds = ARRAY_SIZE(smb1_server_cmds);
+	return 0;
+}
diff --git a/fs/ksmbd/smb1pdu.c b/fs/ksmbd/smb1pdu.c
new file mode 100644
index 000000000000..7501a53777cb
--- /dev/null
+++ b/fs/ksmbd/smb1pdu.c
@@ -0,0 +1,8881 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>
+ *   Copyright (C) 2018 Samsung Electronics Co., Ltd.
+ */
+#include <linux/math64.h>
+#include <linux/fs.h>
+#include <linux/posix_acl_xattr.h>
+#include <linux/namei.h>
+#include <linux/statfs.h>
+#include <linux/vmalloc.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#include <linux/filelock.h>
+#endif
+
+#include "compat.h"
+#include "glob.h"
+#include "oplock.h"
+#include "connection.h"
+#include "transport_ipc.h"
+#include "vfs.h"
+#include "misc.h"
+
+#include "auth.h"
+#include "asn1.h"
+#include "server.h"
+#include "smb_common.h"
+#include "smb1pdu.h"
+#include "smbstatus.h"
+#include "mgmt/user_config.h"
+#include "mgmt/share_config.h"
+#include "mgmt/tree_connect.h"
+#include "mgmt/user_session.h"
+#include "ndr.h"
+#include "smberr.h"
+#include "unicode.h"
+
+static const char *const smb_cmd_str[] = {
+	[SMB_COM_CREATE_DIRECTORY] = "SMB_COM_CREATE_DIRECTORY",
+	[SMB_COM_DELETE_DIRECTORY] = "SMB_COM_DELETE_DIRECTORY",
+	[SMB_COM_CLOSE] = "SMB_COM_CLOSE",
+	[SMB_COM_FLUSH] = "SMB_COM_FLUSH",
+	[SMB_COM_DELETE] = "SMB_COM_DELETE",
+	[SMB_COM_RENAME] = "SMB_COM_RENAME",
+	[SMB_COM_QUERY_INFORMATION] = "SMB_COM_QUERY_INFORMATION",
+	[SMB_COM_SETATTR] = "SMB_COM_SETATTR",
+	[SMB_COM_WRITE] = "SMB_COM_WRITE",
+	[SMB_COM_CHECK_DIRECTORY] = "SMB_COM_CHECK_DIRECTORY",
+	[SMB_COM_PROCESS_EXIT] = "SMB_COM_PROCESS_EXIT",
+	[SMB_COM_LOCKING_ANDX] = "SMB_COM_LOCKING_ANDX",
+	[SMB_COM_TRANSACTION] = "SMB_COM_TRANSACTION",
+	[SMB_COM_COPY] = "SMB_COM_COPY",
+	[SMB_COM_ECHO] = "SMB_COM_ECHO",
+	[SMB_COM_OPEN_ANDX] = "SMB_COM_OPEN_ANDX",
+	[SMB_COM_READ_ANDX] = "SMB_COM_READ_ANDX",
+	[SMB_COM_WRITE_ANDX] = "SMB_COM_WRITE_ANDX",
+	[SMB_COM_TRANSACTION2] = "SMB_COM_TRANSACTION2",
+	[SMB_COM_TRANSACTION2_SECONDARY] = "SMB_COM_TRANSACTION2_SECONDARY",
+	[SMB_COM_FIND_CLOSE2] = "SMB_COM_FIND_CLOSE2",
+	[SMB_COM_TREE_DISCONNECT] = "SMB_COM_TREE_DISCONNECT",
+	[SMB_COM_NEGOTIATE] = "SMB_COM_NEGOTIATE",
+	[SMB_COM_SESSION_SETUP_ANDX] = "SMB_COM_SESSION_SETUP_ANDX",
+	[SMB_COM_LOGOFF_ANDX] = "SMB_COM_LOGOFF_ANDX",
+	[SMB_COM_TREE_CONNECT_ANDX] = "SMB_COM_TREE_CONNECT_ANDX",
+	[SMB_COM_QUERY_INFORMATION_DISK] = "SMB_COM_QUERY_INFORMATION_DISK",
+	[SMB_COM_NT_TRANSACT] = "SMB_COM_NT_TRANSACT",
+	[SMB_COM_NT_TRANSACT_SECONDARY] = "SMB_COM_NT_TRANSACT_SECONDARY",
+	[SMB_COM_NT_CREATE_ANDX] = "SMB_COM_NT_CREATE_ANDX",
+	[SMB_COM_NT_CANCEL] = "SMB_COM_NT_CANCEL",
+	[SMB_COM_NT_RENAME] = "SMB_COM_NT_RENAME",
+};
+
+static const char *smb_cmd_to_str(u16 cmd)
+{
+	if (cmd < ARRAY_SIZE(smb_cmd_str))
+		return smb_cmd_str[cmd];
+
+	return "unknown_cmd";
+}
+
+static const char *const smb_trans2_cmd_str[] = {
+	[TRANS2_OPEN] = "TRANS2_OPEN",
+	[TRANS2_FIND_FIRST] = "TRANS2_FIND_FIRST",
+	[TRANS2_FIND_NEXT] = "TRANS2_FIND_NEXT",
+	[TRANS2_QUERY_FS_INFORMATION] = "TRANS2_QUERY_FS_INFORMATION",
+	[TRANS2_SET_FS_INFORMATION] = "TRANS2_SET_FS_INFORMATION",
+	[TRANS2_QUERY_PATH_INFORMATION] = "TRANS2_QUERY_PATH_INFORMATION",
+	[TRANS2_SET_PATH_INFORMATION] = "TRANS2_SET_PATH_INFORMATION",
+	[TRANS2_QUERY_FILE_INFORMATION] = "TRANS2_QUERY_FILE_INFORMATION",
+	[TRANS2_SET_FILE_INFORMATION] = "TRANS2_SET_FILE_INFORMATION",
+	[TRANS2_CREATE_DIRECTORY] = "TRANS2_CREATE_DIRECTORY",
+	[TRANS2_GET_DFS_REFERRAL] = "TRANS2_GET_DFS_REFERRAL",
+	[TRANS2_REPORT_DFS_INCOSISTENCY] = "TRANS2_REPORT_DFS_INCOSISTENCY",
+};
+
+static const char *smb_trans2_cmd_to_str(u16 cmd)
+{
+	if (cmd < ARRAY_SIZE(smb_trans2_cmd_str))
+		return smb_trans2_cmd_str[cmd];
+
+	return "unknown_trans2_cmd";
+}
+
+static int smb1_oplock_enable = false;
+
+/* Default: allocation roundup size = 1048576 */
+static unsigned int alloc_roundup_size = 1048576;
+
+struct ksmbd_dirent {
+	unsigned long long	ino;
+	unsigned long long	offset;
+	unsigned int		namelen;
+	unsigned int		d_type;
+	char			name[];
+};
+
+/**
+ * smb_NTtimeToUnix() - convert NTFS time to unix style time format
+ * @ntutc:	NTFS style time
+ *
+ * Convert the NT UTC (based 1601-01-01, in hundred nanosecond units)
+ * into Unix UTC (based 1970-01-01, in seconds).
+ *
+ * Return:      timespec containing unix style time
+ */
+static struct timespec64 smb_NTtimeToUnix(__le64 ntutc)
+{
+	struct timespec64 ts;
+
+	/* BB what about the timezone? BB */
+
+	/* Subtract the NTFS time offset, then convert to 1s intervals. */
+	/* this has been taken from cifs, ntfs code */
+	u64 t;
+
+	t = le64_to_cpu(ntutc) - NTFS_TIME_OFFSET;
+	ts.tv_nsec = do_div(t, 10000000) * 100;
+	ts.tv_sec = t;
+	return ts;
+}
+
+/**
+ * get_smb_cmd_val() - get smb command value from smb header
+ * @work:	smb work containing smb header
+ *
+ * Return:      smb command value
+ */
+u16 get_smb_cmd_val(struct ksmbd_work *work)
+{
+	struct smb_hdr *rcv_hdr = (struct smb_hdr *)work->request_buf;
+
+	return (u16)rcv_hdr->Command;
+}
+
+/**
+ * is_smbreq_unicode() - check if the smb command is request is unicode or not
+ * @hdr:	pointer to smb_hdr in the the request part
+ *
+ * Return: check flags and return true if request is unicode, else false
+ */
+static inline int is_smbreq_unicode(struct smb_hdr *hdr)
+{
+	return hdr->Flags2 & SMBFLG2_UNICODE ? 1 : 0;
+}
+
+/**
+ * set_smb_rsp_status() - set error type in smb response header
+ * @work:	smb work containing smb response header
+ * @err:	error code to set in response
+ */
+void set_smb_rsp_status(struct ksmbd_work *work, __le32 err)
+{
+	struct smb_hdr *rsp_hdr = (struct smb_hdr *) work->response_buf;
+
+	rsp_hdr->Status.CifsError = err;
+}
+
+/**
+ * init_smb_rsp_hdr() - initialize smb response header
+ * @work:	smb work containing smb request
+ *
+ * Return:      0 on success, otherwise -EINVAL
+ */
+int init_smb_rsp_hdr(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+	struct smb_hdr *rsp_hdr;
+	struct smb_hdr *rcv_hdr = (struct smb_hdr *)work->request_buf;
+
+	rsp_hdr = (struct smb_hdr *) work->response_buf;
+	memset(rsp_hdr, 0, sizeof(struct smb_hdr) + 2);
+
+	/* remove 4 byte direct TCP header, add 1 byte wc and 2 byte bcc */
+	rsp_hdr->smb_buf_length = cpu_to_be32(conn->vals->header_size - 4 + 2);
+	memcpy(rsp_hdr->Protocol, rcv_hdr->Protocol, 4);
+	rsp_hdr->Command = rcv_hdr->Command;
+
+	/*
+	 * Message is response. Other bits are obsolete.
+	 */
+	rsp_hdr->Flags = (SMBFLG_RESPONSE);
+
+	/*
+	 * Lets assume error code are NTLM. True for CIFS and windows 7
+	 */
+	rsp_hdr->Flags2 = rcv_hdr->Flags2;
+	rsp_hdr->PidHigh = rcv_hdr->PidHigh;
+	rsp_hdr->Pid = rcv_hdr->Pid;
+	rsp_hdr->Mid = rcv_hdr->Mid;
+	rsp_hdr->WordCount = 0;
+
+	/* We can do the above test because we have set maxVCN as 1 */
+	rsp_hdr->Uid = rcv_hdr->Uid;
+	rsp_hdr->Tid = rcv_hdr->Tid;
+	return 0;
+}
+
+/**
+ * smb_allocate_rsp_buf() - allocate response buffer for a command
+ * @work:	smb work containing smb request
+ *
+ * Return:      0 on success, otherwise -ENOMEM
+ */
+int smb_allocate_rsp_buf(struct ksmbd_work *work)
+{
+	struct smb_hdr *hdr = (struct smb_hdr *)work->request_buf;
+	unsigned char cmd = hdr->Command;
+	size_t large_sz = work->conn->vals->max_read_size + MAX_CIFS_HDR_SIZE;
+	size_t sz = MAX_CIFS_SMALL_BUFFER_SIZE;
+
+	if (cmd == SMB_COM_TRANSACTION2) {
+		struct smb_com_trans2_qpi_req *req = work->request_buf;
+		u16 sub_cmd = le16_to_cpu(req->SubCommand);
+		u16 infolevel = le16_to_cpu(req->InformationLevel);
+
+		if ((sub_cmd == TRANS2_FIND_FIRST) ||
+		    (sub_cmd == TRANS2_FIND_NEXT) ||
+		    (sub_cmd == TRANS2_QUERY_PATH_INFORMATION &&
+		     (infolevel == SMB_QUERY_FILE_UNIX_LINK ||
+		      infolevel == SMB_QUERY_POSIX_ACL ||
+		      infolevel == SMB_INFO_QUERY_ALL_EAS)))
+			sz = large_sz;
+	}
+
+	if (cmd == SMB_COM_TRANSACTION)
+		sz = large_sz;
+
+	if (cmd == SMB_COM_ECHO) {
+		int resp_size;
+		struct smb_com_echo_req *req = work->request_buf;
+
+		/*
+		 * size of struct smb_com_echo_rsp + Bytecount - Size of Data
+		 * in struct smb_com_echo_rsp
+		 */
+		resp_size = sizeof(struct smb_com_echo_rsp) +
+			    le16_to_cpu(req->ByteCount) - 1;
+		if (resp_size > MAX_CIFS_SMALL_BUFFER_SIZE)
+			sz = large_sz;
+	}
+
+	work->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);
+	work->response_sz = sz;
+
+	if (!work->response_buf) {
+		pr_err("Failed to allocate %zu bytes buffer\n", sz);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/**
+ * andx_request_buffer() - return pointer to matching andx command
+ * @work:	buffer containing smb request
+ * @command:	match next command with this command
+ *
+ * Return:      pointer to matching command buffer on success, otherwise NULL
+ */
+static char *andx_request_buffer(char *buf, int command)
+{
+	struct andx_block *andx_ptr =
+		(struct andx_block *)(buf + sizeof(struct smb_hdr) - 1);
+	struct andx_block *next;
+
+	while (andx_ptr->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		next = (struct andx_block *)(buf + 4 +
+					     le16_to_cpu(andx_ptr->AndXOffset));
+		if (andx_ptr->AndXCommand == command)
+			return (char *)next;
+		andx_ptr = next;
+	}
+	return NULL;
+}
+
+/**
+ * andx_response_buffer() - return pointer to andx response buffer
+ * @buf:	buffer containing smb request
+ *
+ * Return:      pointer to andx command response on success, otherwise NULL
+ */
+static char *andx_response_buffer(char *buf)
+{
+	int pdu_length = get_rfc1002_len(buf);
+
+	return buf + 4 + pdu_length;
+}
+
+/**
+ * smb_check_user_session() - check for valid session for a user
+ * @work:	smb work containing smb request buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+int smb_check_user_session(struct ksmbd_work *work)
+{
+	struct smb_hdr *req_hdr = (struct smb_hdr *)work->request_buf;
+	struct ksmbd_conn *conn = work->conn;
+	unsigned int cmd = conn->ops->get_cmd_val(work);
+
+	ksmbd_debug(SMB, "received SMB command: %s\n",
+		    smb_cmd_to_str(req_hdr->Command));
+
+	work->sess = NULL;
+	if (cmd == SMB_COM_NEGOTIATE || cmd == SMB_COM_SESSION_SETUP_ANDX ||
+	    cmd == SMB_COM_ECHO)
+		return 0;
+
+	if (!ksmbd_conn_good(conn))
+		return -EINVAL;
+
+	if (xa_empty(&conn->sessions)) {
+		ksmbd_debug(SMB, "NO sessions registered\n");
+		return -EINVAL;
+	}
+
+	work->sess = ksmbd_session_lookup(conn, le16_to_cpu(req_hdr->Uid));
+	if (work->sess)
+		return 1;
+	ksmbd_debug(SMB, "Invalid user session, Uid %u\n",
+		    le16_to_cpu(req_hdr->Uid));
+	return -EINVAL;
+}
+
+/**
+ * smb_get_ksmbd_tcon() - get tree connection information for a tree id
+ * @sess:	session containing tree list
+ * @tid:	match tree connection with tree id
+ *
+ * Return:      matching tree connection on success, otherwise error
+ */
+int smb_get_ksmbd_tcon(struct ksmbd_work *work)
+{
+	struct smb_hdr *req_hdr = (struct smb_hdr *)work->request_buf;
+	u8 cmd = req_hdr->Command;
+	int tree_id;
+
+	work->tcon = NULL;
+	if (cmd == SMB_COM_TREE_CONNECT_ANDX ||
+	    cmd == SMB_COM_NT_CANCEL ||
+	    cmd == SMB_COM_PROCESS_EXIT ||
+	    cmd == SMB_COM_LOGOFF_ANDX) {
+		ksmbd_debug(SMB, "skip to check tree connect request\n");
+		return 0;
+	}
+
+	if (xa_empty(&work->sess->tree_conns)) {
+		ksmbd_debug(SMB, "NO tree connected\n");
+		return -ENOENT;
+	}
+
+	tree_id = le16_to_cpu(req_hdr->Tid);
+	work->tcon = ksmbd_tree_conn_lookup(work->sess, tree_id);
+	if (!work->tcon) {
+		pr_err("Invalid tid %d\n", tree_id);
+		return -EINVAL;
+	}
+
+	return 1;
+}
+
+/**
+ * smb_session_disconnect() - LOGOFF request handler
+ * @work:	smb work containing log off request buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+int smb_session_disconnect(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+	struct ksmbd_session *sess = work->sess;
+
+	/* setting CifsExiting here may race with start_tcp_sess */
+	ksmbd_conn_set_need_reconnect(conn);
+
+	ksmbd_conn_wait_idle(conn, sess->id);
+
+	ksmbd_tree_conn_session_logoff(sess);
+
+	/* let start_tcp_sess free conn info now */
+	ksmbd_conn_set_exiting(conn);
+	return 0;
+}
+
+/**
+ * smb_tree_disconnect() - tree disconnect request handler
+ * @work:	smb work containing tree disconnect request buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+int smb_tree_disconnect(struct ksmbd_work *work)
+{
+	struct smb_hdr *req_hdr = (struct smb_hdr *)work->request_buf;
+	struct smb_hdr *rsp_hdr = (struct smb_hdr *)work->response_buf;
+	struct ksmbd_tree_connect *tcon = work->tcon;
+	struct ksmbd_session *sess = work->sess;
+	int err;
+
+	if (!tcon) {
+		pr_err("Invalid tid %d\n", req_hdr->Tid);
+		rsp_hdr->Status.CifsError = STATUS_NO_SUCH_USER;
+		return -EINVAL;
+	}
+
+	ksmbd_close_tree_conn_fds(work);
+
+	write_lock(&sess->tree_conns_lock);
+	if (tcon->t_state == TREE_DISCONNECTED) {
+		write_unlock(&sess->tree_conns_lock);
+		rsp_hdr->Status.CifsError = STATUS_NETWORK_NAME_DELETED;
+		return -ENOENT;
+	}
+
+	WARN_ON_ONCE(atomic_dec_and_test(&tcon->refcount));
+	tcon->t_state = TREE_DISCONNECTED;
+	write_unlock(&sess->tree_conns_lock);
+
+	err = ksmbd_tree_conn_disconnect(sess, tcon);
+	if (err) {
+		rsp_hdr->Status.CifsError = STATUS_NETWORK_NAME_DELETED;
+		return -ENOENT;
+	}
+
+	work->tcon = NULL;
+
+	return 0;
+}
+
+static void set_service_type(struct ksmbd_conn *conn,
+			     struct ksmbd_share_config *share,
+			     struct smb_com_tconx_rsp_ext *rsp)
+{
+	int length;
+	char *buf = rsp->Service;
+
+	if (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {
+		length = strlen(SERVICE_IPC_SHARE);
+		memcpy(buf, SERVICE_IPC_SHARE, length);
+		rsp->ByteCount = cpu_to_le16(length + 1);
+		buf += length;
+		*buf = '\0';
+	} else {
+		int uni_len = 0;
+
+		length = strlen(SERVICE_DISK_SHARE);
+		memcpy(buf, SERVICE_DISK_SHARE, length);
+		buf[length] = '\0';
+		length += 1;
+		uni_len = smbConvertToUTF16((__le16 *)(buf + length),
+					    NATIVE_FILE_SYSTEM, PATH_MAX,
+					    conn->local_nls, 0);
+		uni_len++;
+		uni_len *= 2;
+		length += uni_len;
+		rsp->ByteCount = cpu_to_le16(length);
+	}
+}
+
+/**
+ * smb_tree_connect_andx() - tree connect request handler
+ * @work:	smb work containing tree connect request buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+int smb_tree_connect_andx(struct ksmbd_work *work)
+{
+	struct smb_hdr *req_hdr = (struct smb_hdr *)work->request_buf;
+	struct smb_hdr *rsp_hdr = (struct smb_hdr *)work->response_buf;
+	struct ksmbd_conn *conn = work->conn;
+	struct smb_com_tconx_req *req;
+	struct smb_com_tconx_rsp_ext *rsp;
+	int extra_byte = 0;
+	char *treename = NULL, *name = NULL, *dev_type = NULL;
+	struct ksmbd_share_config *share;
+	struct ksmbd_session *sess = work->sess;
+	int dev_flags = 0;
+	struct ksmbd_tree_conn_status status;
+
+	/* Is this an ANDX command ? */
+	if (req_hdr->Command != SMB_COM_TREE_CONNECT_ANDX) {
+		ksmbd_debug(SMB, "SMB_COM_TREE_CONNECT_ANDX is part of ANDX");
+		req = (struct smb_com_tconx_req *)
+			andx_request_buffer(work->request_buf,
+				SMB_COM_TREE_CONNECT_ANDX);
+		rsp = (struct smb_com_tconx_rsp_ext *)
+			andx_response_buffer(work->response_buf);
+		extra_byte = 3;
+		if (!req) {
+			status.ret = -EINVAL;
+			goto out_err;
+		}
+	} else {
+		req = (struct smb_com_tconx_req *)(&req_hdr->WordCount);
+		rsp = (struct smb_com_tconx_rsp_ext *)(&rsp_hdr->WordCount);
+	}
+
+	/* check if valid tree name is present in request or not */
+	if (!req->PasswordLength) {
+		treename = smb_strndup_from_utf16(req->Password + 1,
+						  256, true, conn->local_nls);
+		dev_type = smb_strndup_from_utf16(req->Password + 1 +
+			((strlen(treename) + 1) * 2), 256, false,
+			conn->local_nls);
+	} else {
+		treename = smb_strndup_from_utf16(req->Password +
+				le16_to_cpu(req->PasswordLength), 256, true,
+				conn->local_nls);
+		dev_type = smb_strndup_from_utf16(req->Password +
+			le16_to_cpu(req->PasswordLength) +
+				((strlen(treename) + 1) * 2),
+			256, false, conn->local_nls);
+	}
+
+	if (IS_ERR(treename) || IS_ERR(dev_type)) {
+		pr_err("Unable to strdup() treename or devtype uid %d\n",
+		       rsp_hdr->Uid);
+		status.ret = KSMBD_TREE_CONN_STATUS_ERROR;
+		goto out_err;
+	}
+	name = ksmbd_extract_sharename(conn->um, treename);
+	if (IS_ERR(name)) {
+		status.ret = KSMBD_TREE_CONN_STATUS_ERROR;
+		goto out_err;
+	}
+
+	ksmbd_debug(SMB, "tree connect request for tree %s, dev_type : %s\n",
+		    name, dev_type);
+
+	if (!strcmp(dev_type, "A:"))
+		dev_flags = 1;
+	else if (!strncmp(dev_type, "LPT", 3))
+		dev_flags = 2;
+	else if (!strcmp(dev_type, "IPC"))
+		dev_flags = 3;
+	else if (!strcmp(dev_type, "COMM"))
+		dev_flags = 4;
+	else if (!strcmp(dev_type, "?????"))
+		dev_flags = 5;
+
+	if (!strcmp(name, "IPC$")) {
+		if (dev_flags < 3) {
+			status.ret = -ENODEV;
+			goto out_err;
+		}
+	} else if (!dev_flags || (dev_flags > 1 && dev_flags < 5)) {
+		status.ret = -ENODEV;
+		goto out_err;
+	}
+
+	status = ksmbd_tree_conn_connect(conn, sess, name);
+	if (status.ret == KSMBD_TREE_CONN_STATUS_OK)
+		rsp_hdr->Tid = cpu_to_le16(status.tree_conn->id);
+	else
+		goto out_err;
+
+	status.ret = 0;
+	share = status.tree_conn->share_conf;
+	rsp->WordCount = 7;
+	rsp->OptionalSupport = cpu_to_le16(SMB_SUPPORT_SEARCH_BITS |
+					   SMB_CSC_NO_CACHING |
+					   SMB_UNIQUE_FILE_NAME);
+
+	rsp->MaximalShareAccessRights = cpu_to_le32(FILE_READ_RIGHTS |
+						    FILE_EXEC_RIGHTS);
+	if (test_tree_conn_flag(status.tree_conn,
+				KSMBD_TREE_CONN_FLAG_WRITABLE))
+		rsp->MaximalShareAccessRights |= cpu_to_le32(FILE_WRITE_RIGHTS);
+	rsp->GuestMaximalShareAccessRights = 0;
+
+	set_service_type(conn, share, rsp);
+
+	/* For each extra andx response, we have to add 1 byte,
+	 * for wc and 2 bytes for byte count
+	 */
+	inc_rfc1001_len(rsp_hdr,
+			7 * 2 + le16_to_cpu(rsp->ByteCount) + extra_byte);
+
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(rsp_hdr));
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		/* More processing required */
+		status.ret = rsp->AndXCommand;
+	} else {
+		rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+	}
+
+	kfree(treename);
+	kfree(dev_type);
+	kfree(name);
+
+	write_lock(&sess->tree_conns_lock);
+	status.tree_conn->t_state = TREE_CONNECTED;
+	write_unlock(&sess->tree_conns_lock);
+
+	return status.ret;
+
+out_err:
+	if (!IS_ERR(treename))
+		kfree(treename);
+	if (!IS_ERR(dev_type))
+		kfree(dev_type);
+	if (!IS_ERR(name))
+		kfree(name);
+
+	rsp->WordCount = 7;
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(rsp_hdr));
+	rsp->OptionalSupport = 0;
+	rsp->MaximalShareAccessRights = 0;
+	rsp->GuestMaximalShareAccessRights = 0;
+	rsp->ByteCount = 0;
+	ksmbd_debug(SMB, "error while tree connect\n");
+	switch (status.ret) {
+	case KSMBD_TREE_CONN_STATUS_NO_SHARE:
+		rsp_hdr->Status.CifsError = STATUS_BAD_NETWORK_PATH;
+		break;
+	case -ENOMEM:
+	case KSMBD_TREE_CONN_STATUS_NOMEM:
+		rsp_hdr->Status.CifsError = STATUS_NO_MEMORY;
+		break;
+	case KSMBD_TREE_CONN_STATUS_TOO_MANY_CONNS:
+	case KSMBD_TREE_CONN_STATUS_TOO_MANY_SESSIONS:
+		rsp_hdr->Status.CifsError = STATUS_ACCESS_DENIED;
+		break;
+	case -ENODEV:
+		rsp_hdr->Status.CifsError = STATUS_BAD_DEVICE_TYPE;
+		break;
+	case KSMBD_TREE_CONN_STATUS_ERROR:
+		rsp_hdr->Status.CifsError = STATUS_BAD_NETWORK_NAME;
+		break;
+	case -EINVAL:
+		rsp_hdr->Status.CifsError = STATUS_INVALID_PARAMETER;
+		break;
+	default:
+		rsp_hdr->Status.CifsError = STATUS_ACCESS_DENIED;
+	}
+
+	inc_rfc1001_len(rsp_hdr,
+			(7 * 2 + le16_to_cpu(rsp->ByteCount) + extra_byte));
+	return -EINVAL;
+}
+
+/**
+ * smb_get_name() - convert filename on smb packet to char string
+ * @src:	source filename, mostly in unicode format
+ * @maxlen:	maxlen of src string to be used for parsing
+ * @work:	smb work containing smb header flag
+ * @converted:	src string already converted to local characterset
+ *
+ * Return:	pointer to filename string on success, otherwise error ptr
+ */
+static char *smb_get_name(struct ksmbd_share_config *share, const char *src,
+			  const int maxlen, struct ksmbd_work *work,
+			  bool converted)
+{
+	struct smb_hdr *req_hdr = (struct smb_hdr *)work->request_buf;
+	bool is_unicode = is_smbreq_unicode(req_hdr);
+	char *name, *wild_card_pos;
+
+	if (converted)
+		name = (char *)src;
+	else {
+		name = smb_strndup_from_utf16(src, maxlen, is_unicode,
+					      work->conn->local_nls);
+		if (IS_ERR(name)) {
+			ksmbd_debug(SMB, "failed to get name %ld\n",
+				    PTR_ERR(name));
+			return name;
+		}
+	}
+
+	ksmbd_conv_path_to_unix(name);
+	ksmbd_strip_last_slash(name);
+
+	/*Handling of dir path in FIND_FIRST2 having '*' at end of path*/
+	wild_card_pos = strrchr(name, '*');
+
+	if (wild_card_pos != NULL)
+		*wild_card_pos = '\0';
+
+
+	if (ksmbd_validate_filename(name) < 0) {
+		if (!converted)
+			kfree(name);
+		return ERR_PTR(-ENOENT);
+	}
+
+	if (ksmbd_share_veto_filename(share, name)) {
+		ksmbd_debug(SMB,
+			"file(%s) open is not allowed by setting as veto file\n",
+			name);
+		if (!converted)
+			kfree(name);
+		return ERR_PTR(-ENOENT);
+	}
+
+	ksmbd_debug(SMB, "file name = %s\n", name);
+
+	return name;
+}
+
+/**
+ * smb_get_dir_name() - convert directory name on smb packet to char string
+ * @src:	source dir name, mostly in unicode format
+ * @maxlen:	maxlen of src string to be used for parsing
+ * @work:	smb work containing smb header flag
+ * @srch_ptr:	update search pointer in dir for searching dir entries
+ *
+ * Return:	pointer to dir name string on success, otherwise error ptr
+ */
+static char *smb_get_dir_name(struct ksmbd_share_config *share,
+			      const char *src, const int maxlen,
+			      struct ksmbd_work *work, char **srch_ptr)
+{
+	struct smb_hdr *req_hdr = (struct smb_hdr *)work->request_buf;
+	struct smb_hdr *rsp_hdr = (struct smb_hdr *)work->response_buf;
+	bool is_unicode = is_smbreq_unicode(req_hdr);
+	char *name, *pattern_pos, *pattern = NULL;
+	int pattern_len, rc;
+
+	name = smb_strndup_from_utf16(src, maxlen, is_unicode,
+				      work->conn->local_nls);
+	if (IS_ERR(name)) {
+		pr_err("failed to allocate memory\n");
+		rsp_hdr->Status.CifsError = STATUS_NO_MEMORY;
+		return name;
+	}
+
+	ksmbd_conv_path_to_unix(name);
+	ksmbd_strip_last_slash(name);
+
+	pattern_pos = strrchr(name, '/');
+
+	if (!pattern_pos)
+		pattern_pos = name;
+	else
+		pattern_pos += 1;
+
+	pattern_len = strlen(pattern_pos);
+	if (pattern_len == 0) {
+		rc = -EINVAL;
+		goto err_name;
+	}
+	ksmbd_debug(SMB, "pattern searched = %s pattern_len = %d\n",
+		    pattern_pos, pattern_len);
+	pattern = kmalloc(pattern_len + 1, GFP_KERNEL);
+	if (!pattern) {
+		rc = -ENOMEM;
+		goto err_name;
+	}
+	memcpy(pattern, pattern_pos, pattern_len);
+	*(pattern + pattern_len) = '\0';
+	*pattern_pos = '\0';
+	*srch_ptr = pattern;
+
+	if (ksmbd_validate_filename(name) < 0) {
+		rc = -ENOENT;
+		goto err_pattern;
+	}
+
+	if (ksmbd_share_veto_filename(share, name)) {
+		ksmbd_debug(SMB,
+			"file(%s) open is not allowed by setting as veto file\n",
+			name);
+		rc = -ENOENT;
+		goto err_pattern;
+	}
+
+	ksmbd_debug(SMB, "dir name = %s\n", name);
+	return name;
+
+err_pattern:
+	kfree(pattern);
+	*srch_ptr = NULL;
+err_name:
+	kfree(name);
+
+	if (rc == -EINVAL)
+		rsp_hdr->Status.CifsError = STATUS_INVALID_PARAMETER;
+	else if (rc == -ENOMEM)
+		rsp_hdr->Status.CifsError = STATUS_NO_MEMORY;
+	else if (rc == -ENOENT)
+		rsp_hdr->Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+
+	return ERR_PTR(rc);
+}
+
+/**
+ * smb_rename() - rename request handler
+ * @work:	smb work containing rename request buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+int smb_rename(struct ksmbd_work *work)
+{
+	struct smb_com_rename_req *req = work->request_buf;
+	struct smb_com_rename_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	bool is_unicode = is_smbreq_unicode(&req->hdr);
+	char *oldname, *newname;
+	struct ksmbd_file *fp = NULL;
+	int oldname_len;
+	struct path path;
+	bool file_present = true;
+	int rc = 0;
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		ksmbd_debug(SMB,
+			"returning as user does not have permission to write\n");
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		return -EACCES;
+	}
+
+	oldname = smb_get_name(share, req->OldFileName, PATH_MAX, work, false);
+	if (IS_ERR(oldname)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(oldname);
+	}
+
+	if (is_unicode)
+		oldname_len = smb1_utf16_name_length((__le16 *)req->OldFileName,
+						     PATH_MAX);
+	else {
+		oldname_len = strlen(oldname);
+		oldname_len++;
+	}
+
+	newname = smb_get_name(share, &req->OldFileName[oldname_len + 2],
+			       PATH_MAX, work, false);
+	if (IS_ERR(newname)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		rc = PTR_ERR(newname);
+		newname = NULL;
+		goto out;
+	}
+
+	rc = ksmbd_vfs_kern_path(work, newname, LOOKUP_NO_SYMLINKS, &path, 1);
+	if (rc)
+		file_present = false;
+	else
+		path_put(&path);
+
+	if (file_present && strncmp(oldname, newname, strlen(oldname))) {
+		rc = -EEXIST;
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_COLLISION;
+		ksmbd_debug(SMB, "cannot rename already existing file\n");
+		goto out;
+	}
+
+	ksmbd_debug(SMB, "rename %s -> %s\n", oldname, newname);
+	rc = ksmbd_vfs_kern_path(work, oldname, LOOKUP_NO_SYMLINKS, &path, 1);
+	if (rc)
+		goto out;
+
+	fp = ksmbd_vfs_dentry_open(work, &path, O_RDONLY, 0, false);
+	if (IS_ERR(fp)) {
+		fp = NULL;
+		path_put(&path);
+		goto out;
+	}
+
+	rc = ksmbd_vfs_fp_rename(work, fp, newname);
+	if (rc) {
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		path_put(&path);
+		goto out;
+	}
+	path_put(&path);
+	rsp->hdr.WordCount = 0;
+	rsp->ByteCount = 0;
+out:
+	if (fp)
+		ksmbd_close_fd(work, fp->volatile_id);
+	kfree(oldname);
+	kfree(newname);
+	return rc;
+}
+
+/**
+ * smb_handle_negotiate() - negotiate request handler
+ * @work:	smb work containing negotiate request buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+int smb_handle_negotiate(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+	struct smb_negotiate_rsp *neg_rsp = work->response_buf;
+	__u64 time;
+	int rc = 0;
+
+	WARN_ON(ksmbd_conn_good(conn));
+
+	if (conn->dialect == BAD_PROT_ID) {
+		neg_rsp->hdr.Status.CifsError = STATUS_INVALID_LOGON_TYPE;
+		rc = -EINVAL;
+		goto err_out;
+	}
+
+	conn->connection_type = 0;
+
+	/* wct 17 for NTLM */
+	neg_rsp->hdr.WordCount = 17;
+	neg_rsp->DialectIndex = cpu_to_le16(conn->dialect);
+
+	neg_rsp->SecurityMode = SMB1_SERVER_SECU;
+	if (server_conf.signing == KSMBD_CONFIG_OPT_AUTO ||
+	    server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY) {
+		conn->sign = true;
+		neg_rsp->SecurityMode |= SECMODE_SIGN_ENABLED;
+		if (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY)
+			neg_rsp->SecurityMode |= SECMODE_SIGN_REQUIRED;
+	}
+	neg_rsp->MaxMpxCount = cpu_to_le16(SMB1_MAX_MPX_COUNT);
+	neg_rsp->MaxNumberVcs = cpu_to_le16(SMB1_MAX_VCS);
+	neg_rsp->MaxBufferSize = cpu_to_le32(conn->vals->max_read_size);
+	neg_rsp->MaxRawSize = cpu_to_le32(SMB1_MAX_RAW_SIZE);
+	neg_rsp->SessionKey = 0;
+	neg_rsp->Capabilities = cpu_to_le32(SMB1_SERVER_CAPS);
+
+	time = ksmbd_systime();
+	neg_rsp->SystemTimeLow = cpu_to_le32(time & 0x00000000FFFFFFFF);
+	neg_rsp->SystemTimeHigh =
+		cpu_to_le32((time & 0xFFFFFFFF00000000) >> 32);
+	neg_rsp->ServerTimeZone = 0;
+
+	if (((struct smb_hdr *)work->request_buf)->Flags2 & SMBFLG2_EXT_SEC)
+		conn->use_spnego = true;
+
+	ksmbd_debug(SMB, "spnego is %s\n", conn->use_spnego ? "on" : "off");
+
+	if (conn->use_spnego == false) {
+		neg_rsp->EncryptionKeyLength = CIFS_CRYPTO_KEY_SIZE;
+		neg_rsp->Capabilities &= ~cpu_to_le32(CAP_EXTENDED_SECURITY);
+		neg_rsp->ByteCount = cpu_to_le16(CIFS_CRYPTO_KEY_SIZE);
+		/* initialize random server challenge */
+		get_random_bytes(conn->ntlmssp.cryptkey, sizeof(__u64));
+		memcpy((neg_rsp->u.EncryptionKey), conn->ntlmssp.cryptkey,
+		       CIFS_CRYPTO_KEY_SIZE);
+		/* Adjust pdu length, 17 words and 8 bytes added */
+		inc_rfc1001_len(neg_rsp, (17 * 2 + 8));
+	} else {
+		neg_rsp->EncryptionKeyLength = 0;
+		neg_rsp->ByteCount = cpu_to_le16(SMB1_CLIENT_GUID_SIZE +
+			AUTH_GSS_LENGTH);
+		get_random_bytes(neg_rsp->u.extended_response.GUID,
+				 SMB1_CLIENT_GUID_SIZE);
+		ksmbd_copy_gss_neg_header(
+				neg_rsp->u.extended_response.SecurityBlob);
+		inc_rfc1001_len(neg_rsp, (17 * 2 + 16 + AUTH_GSS_LENGTH));
+	}
+
+	/* Null terminated domain name in unicode */
+
+	ksmbd_conn_set_need_negotiate(conn);
+	/* Domain name and PC name are ignored by clients, so no need to send.
+	 * We can try sending them later
+	 */
+err_out:
+	return rc;
+}
+
+static int build_sess_rsp_noextsec(struct ksmbd_conn *conn,
+				   struct ksmbd_session *sess,
+				   struct smb_com_session_setup_req_no_secext *req,
+				   struct smb_com_session_setup_old_resp *rsp)
+{
+	int offset, err = 0, len;
+	char *name;
+	__le16 str[32];
+
+	/* Build response. We don't use extended security (yet), so wct is 3 */
+	rsp->hdr.WordCount = 3;
+	rsp->Action = 0;
+	/* The names should be unicode */
+	rsp->ByteCount = 0;
+	/* adjust pdu length. data added 6 bytes */
+	inc_rfc1001_len(&rsp->hdr, 6);
+
+	/* check if valid user name is present in request or not */
+	offset = le16_to_cpu(req->CaseInsensitivePasswordLength) +
+		le16_to_cpu(req->CaseSensitivePasswordLength);
+
+	/* 1 byte for padding */
+	name = smb_strndup_from_utf16((req->CaseInsensitivePassword + offset +
+				1), 256, true, conn->local_nls);
+	if (IS_ERR(name)) {
+		pr_err("cannot allocate memory\n");
+		err = PTR_ERR(name);
+		goto out_err;
+	}
+
+	WARN_ON(sess->user);
+
+	ksmbd_debug(SMB, "session setup request for user %s\n", name);
+	sess->user = ksmbd_login_user(name);
+	kfree(name);
+	if (!sess->user) {
+		pr_err("user not present in database\n");
+		err = -EINVAL;
+		goto out_err;
+	}
+
+	if (user_guest(sess->user)) {
+		rsp->Action = cpu_to_le16(GUEST_LOGIN);
+		goto no_password_check;
+	}
+
+	if (le16_to_cpu(req->CaseSensitivePasswordLength) ==
+			CIFS_AUTH_RESP_SIZE) {
+		err = ksmbd_auth_ntlm(sess, req->CaseInsensitivePassword +
+			le16_to_cpu(req->CaseInsensitivePasswordLength),
+			conn->ntlmssp.cryptkey);
+		if (err) {
+			pr_err("ntlm authentication failed for user %s\n",
+			       user_name(sess->user));
+			goto out_err;
+		}
+	} else {
+		char *ntdomain;
+
+		offset = le16_to_cpu(req->CaseInsensitivePasswordLength) +
+			le16_to_cpu(req->CaseSensitivePasswordLength) +
+			((strlen(user_name(sess->user)) + 1) * 2);
+
+		ntdomain = smb_strndup_from_utf16(
+				req->CaseInsensitivePassword +
+				offset + 1, 256, true, conn->local_nls);
+		if (IS_ERR(ntdomain)) {
+			pr_err("cannot allocate memory\n");
+			err = PTR_ERR(ntdomain);
+			goto out_err;
+		}
+
+		err = ksmbd_auth_ntlmv2(conn, sess,
+			(struct ntlmv2_resp *) ((char *)
+			req->CaseInsensitivePassword +
+			le16_to_cpu(req->CaseInsensitivePasswordLength)),
+			le16_to_cpu(req->CaseSensitivePasswordLength) -
+				CIFS_ENCPWD_SIZE, ntdomain,
+				conn->ntlmssp.cryptkey);
+		kfree(ntdomain);
+		if (err) {
+			pr_err("authentication failed for user %s\n",
+			       user_name(sess->user));
+			goto out_err;
+		}
+	}
+
+no_password_check:
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(&rsp->hdr));
+
+	/* 1 byte padding for word alignment */
+	offset = 1;
+
+	memset(str, 0, sizeof(str));
+
+	len = smb_strtoUTF16(str, "Unix", 4, conn->local_nls);
+	len = UNICODE_LEN(len + 1);
+	memcpy(rsp->NativeOS + offset, str, len);
+	offset += len;
+
+	len = smb_strtoUTF16(str, "ksmbd", 5, conn->local_nls);
+	len = UNICODE_LEN(len + 1);
+	memcpy(rsp->NativeOS + offset, str, len);
+	offset += len;
+
+	len = smb_strtoUTF16(str, "WORKGROUP", 9, conn->local_nls);
+	len = UNICODE_LEN(len + 1);
+	memcpy(rsp->NativeOS + offset, str, len);
+	offset += len;
+
+	rsp->ByteCount = cpu_to_le16(offset);
+	inc_rfc1001_len(&rsp->hdr, offset);
+
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		return rsp->AndXCommand; /* More processing required */
+	}
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+
+out_err:
+	return err;
+}
+
+static int build_sess_rsp_extsec(struct ksmbd_conn *conn,
+				 struct ksmbd_session *sess,
+				 struct smb_com_session_setup_req *req,
+				 struct smb_com_session_setup_resp *rsp)
+{
+	struct negotiate_message *negblob;
+	char *neg_blob;
+	int err = 0, neg_blob_len;
+	unsigned char *spnego_blob;
+	u16 spnego_blob_len;
+	int sz;
+
+	rsp->hdr.WordCount = 4;
+	rsp->Action = 0;
+
+	/* The names should be unicode */
+	rsp->ByteCount = 0;
+	/* adjust pdu length. data added 6 bytes */
+	inc_rfc1001_len(&rsp->hdr, 8);
+
+	negblob = (struct negotiate_message *)req->SecurityBlob;
+	sz = le16_to_cpu(req->SecurityBlobLength);
+
+	if (ksmbd_decode_negTokenInit((char *)negblob, sz, conn)) {
+		if (ksmbd_decode_negTokenTarg((char *)negblob, sz, conn)) {
+			conn->use_spnego = false;
+		}
+	}
+
+	if (conn->mechToken)
+		negblob = (struct negotiate_message *)conn->mechToken;
+
+	if (negblob->MessageType == NtLmNegotiate) {
+		struct challenge_message *chgblob;
+
+		ksmbd_debug(SMB, "negotiate phase\n");
+		err = ksmbd_decode_ntlmssp_neg_blob(negblob,
+				le16_to_cpu(req->SecurityBlobLength),
+				conn);
+		if (err)
+			goto out_err;
+
+		chgblob = (struct challenge_message *)rsp->SecurityBlob;
+		memset(chgblob, 0, sizeof(struct challenge_message));
+
+		if (conn->use_spnego) {
+			int sz;
+
+			sz = sizeof(struct negotiate_message) +
+				(strlen(ksmbd_netbios_name()) * 2 + 1 + 4) * 6;
+			neg_blob = kmalloc(sz, GFP_KERNEL);
+			if (!neg_blob) {
+				err = -ENOMEM;
+				goto out_err;
+			}
+			chgblob = (struct challenge_message *)neg_blob;
+			neg_blob_len = ksmbd_build_ntlmssp_challenge_blob(
+					chgblob,
+					conn);
+			if (neg_blob_len < 0) {
+				kfree(neg_blob);
+				err = -ENOMEM;
+				goto out_err;
+			}
+
+			if (build_spnego_ntlmssp_neg_blob(&spnego_blob,
+							  &spnego_blob_len,
+							  neg_blob,
+							  neg_blob_len)) {
+				kfree(neg_blob);
+				err = -ENOMEM;
+				goto out_err;
+			}
+
+			memcpy((char *)rsp->SecurityBlob, spnego_blob,
+			       spnego_blob_len);
+			rsp->SecurityBlobLength = cpu_to_le16(spnego_blob_len);
+			kfree(spnego_blob);
+			kfree(neg_blob);
+		} else {
+			neg_blob_len = ksmbd_build_ntlmssp_challenge_blob(
+					chgblob,
+					conn);
+			if (neg_blob_len < 0) {
+				err = -ENOMEM;
+				goto out_err;
+			}
+
+			rsp->SecurityBlobLength = cpu_to_le16(neg_blob_len);
+		}
+
+		rsp->hdr.Status.CifsError = STATUS_MORE_PROCESSING_REQUIRED;
+		/*
+		 * Note: here total size -1 is done as an adjustment
+		 * for 0 size blob.
+		 */
+		inc_rfc1001_len(rsp, le16_to_cpu(rsp->SecurityBlobLength));
+		rsp->ByteCount = rsp->SecurityBlobLength;
+	} else if (negblob->MessageType == NtLmAuthenticate) {
+		struct authenticate_message *authblob;
+		char *username;
+
+		ksmbd_debug(SMB, "authenticate phase\n");
+		if (conn->use_spnego && conn->mechToken)
+			authblob =
+				(struct authenticate_message *)conn->mechToken;
+		else
+			authblob = (struct authenticate_message *)
+						req->SecurityBlob;
+
+		username = smb_strndup_from_utf16((const char *)authblob +
+				le32_to_cpu(authblob->UserName.BufferOffset),
+				le16_to_cpu(authblob->UserName.Length), true,
+				conn->local_nls);
+
+		if (IS_ERR(username)) {
+			pr_err("cannot allocate memory\n");
+			err = PTR_ERR(username);
+			goto out_err;
+		}
+
+		ksmbd_debug(SMB, "session setup request for user %s\n",
+			    username);
+		sess->user = ksmbd_login_user(username);
+		kfree(username);
+
+		if (!sess->user) {
+			ksmbd_debug(SMB, "Unknown user name or an error\n");
+			err = -EINVAL;
+			goto out_err;
+		}
+
+		if (user_guest(sess->user)) {
+			rsp->Action = cpu_to_le16(GUEST_LOGIN);
+			goto no_password_check;
+		}
+
+		err = ksmbd_decode_ntlmssp_auth_blob(authblob,
+				le16_to_cpu(req->SecurityBlobLength),
+				conn, sess);
+		if (err) {
+			ksmbd_debug(SMB, "authentication failed\n");
+			err = -EINVAL;
+			goto out_err;
+		}
+
+no_password_check:
+		if (conn->use_spnego) {
+			if (build_spnego_ntlmssp_auth_blob(&spnego_blob,
+						&spnego_blob_len, 0)) {
+				err = -ENOMEM;
+				goto out_err;
+			}
+
+			memcpy((char *)rsp->SecurityBlob, spnego_blob,
+			       spnego_blob_len);
+			rsp->SecurityBlobLength = cpu_to_le16(spnego_blob_len);
+			kfree(spnego_blob);
+			inc_rfc1001_len(rsp, spnego_blob_len);
+			rsp->ByteCount = rsp->SecurityBlobLength;
+		}
+	} else {
+		pr_err("Invalid phase\n");
+		err = -EINVAL;
+	}
+
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(&rsp->hdr));
+
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		return rsp->AndXCommand; /* More processing required */
+	}
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+
+out_err:
+	if (conn->use_spnego && conn->mechToken) {
+		kfree(conn->mechToken);
+		conn->mechToken = NULL;
+	}
+
+	return err;
+}
+
+/**
+ * smb_session_setup_andx() - session setup request handler
+ * @work:   smb work containing session setup request buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+int smb_session_setup_andx(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+	struct ksmbd_session *sess = NULL;
+	int rc = 0, cap;
+	unsigned short uid;
+
+	union smb_com_session_setup_andx *pSMB = work->request_buf;
+	union smb_com_session_setup_andx *rsp = work->response_buf;
+
+	if (pSMB->req.hdr.WordCount == 12)
+		cap = le32_to_cpu(pSMB->req.Capabilities);
+	else if (pSMB->req.hdr.WordCount == 13)
+		cap = le32_to_cpu(pSMB->req_no_secext.Capabilities);
+	else {
+		pr_err("malformed packet\n");
+		work->send_no_response = 1;
+		return 0;
+	}
+
+	ksmbd_conn_lock(conn);
+	uid = le16_to_cpu(pSMB->req.hdr.Uid);
+	if (uid != 0) {
+		sess = ksmbd_session_lookup(conn, uid);
+		if (!sess) {
+			rc = -ENOENT;
+			goto out_err;
+		}
+		ksmbd_debug(SMB, "Reuse session ID: %llu, Uid: %u\n",
+			    sess->id, uid);
+	} else {
+		sess = ksmbd_smb1_session_create();
+		if (!sess) {
+			rc = -ENOMEM;
+			goto out_err;
+		}
+
+		rc = ksmbd_session_register(conn, sess);
+		if (rc)
+			goto out_err;
+		rsp->resp.hdr.Uid = cpu_to_le16(sess->id);
+		ksmbd_debug(SMB, "New session ID: %llu, Uid: %u\n", sess->id,
+			    uid);
+	}
+
+	if (cap & CAP_EXTENDED_SECURITY) {
+		ksmbd_debug(SMB, "build response with extend_security\n");
+		rc = build_sess_rsp_extsec(conn, sess, &pSMB->req, &rsp->resp);
+
+	} else {
+		ksmbd_debug(SMB, "build response without extend_security\n");
+		rc = build_sess_rsp_noextsec(conn, sess, &pSMB->req_no_secext,
+					     &rsp->old_resp);
+	}
+	if (rc < 0)
+		goto out_err;
+
+	work->sess = sess;
+	ksmbd_conn_set_good(conn);
+	ksmbd_conn_unlock(conn);
+	return 0;
+
+out_err:
+	rsp->resp.hdr.Status.CifsError = STATUS_LOGON_FAILURE;
+	rsp->resp.hdr.WordCount = 0;
+	rsp->resp.ByteCount = 0;
+	if (rc < 0 && sess) {
+		xa_erase(&conn->sessions, sess->id);
+		ksmbd_session_destroy(sess);
+		work->sess = NULL;
+	}
+	ksmbd_conn_unlock(conn);
+	return rc;
+}
+
+/**
+ * file_create_dispostion_flags() - convert disposition flags to
+ *				file open flags
+ * @dispostion:		file disposition contained in open request
+ * @file_present:	file already present or not
+ *
+ * Return:      file open flags after conversion from disposition
+ */
+static int file_create_dispostion_flags(int dispostion, bool file_present)
+{
+	int disp_flags = 0;
+
+	switch (dispostion) {
+	/*
+	 * If the file already exists, it SHOULD be superseded (overwritten).
+	 * If it does not already exist, then it SHOULD be created.
+	 */
+	case FILE_SUPERSEDE:
+		if (file_present)
+			disp_flags |= O_TRUNC;
+		else
+			disp_flags |= O_CREAT;
+		break;
+	/*
+	 * If the file already exists, it SHOULD be opened rather than created.
+	 * If the file does not already exist, the operation MUST fail.
+	 */
+	case FILE_OPEN:
+		if (!file_present)
+			return -ENOENT;
+		break;
+	/*
+	 * If the file already exists, the operation MUST fail.
+	 * If the file does not already exist, it SHOULD be created.
+	 */
+	case FILE_CREATE:
+		if (file_present)
+			return -EEXIST;
+		disp_flags |= O_CREAT;
+		break;
+	/*
+	 * If the file already exists, it SHOULD be opened. If the file
+	 * does not already exist, then it SHOULD be created.
+	 */
+	case FILE_OPEN_IF:
+		if (!file_present)
+			disp_flags |= O_CREAT;
+		break;
+	/*
+	 * If the file already exists, it SHOULD be opened and truncated.
+	 * If the file does not already exist, the operation MUST fail.
+	 */
+	case FILE_OVERWRITE:
+		if (!file_present)
+			return -ENOENT;
+		disp_flags |= O_TRUNC;
+		break;
+	/*
+	 * If the file already exists, it SHOULD be opened and truncated.
+	 * If the file does not already exist, it SHOULD be created.
+	 */
+	case FILE_OVERWRITE_IF:
+		if (file_present)
+			disp_flags |= O_TRUNC;
+		else
+			disp_flags |= O_CREAT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return disp_flags;
+}
+
+static inline int ksmbd_openflags_to_mayflags(int open_flags)
+{
+	int mask = open_flags & O_ACCMODE;
+
+	if (mask == O_WRONLY)
+		return MAY_OPEN | MAY_WRITE;
+	else if (mask == O_RDWR)
+		return MAY_OPEN | MAY_READ | MAY_WRITE;
+	else
+		return MAY_OPEN | MAY_READ;
+}
+
+/**
+ * convert_generic_access_flags() - convert access flags to
+ *				file open flags
+ * @access_flag:	file access flags contained in open request
+ * @open_flag:		file open flags are updated as per access flags
+ * @may_flags:		file may flags are updated with @open_flags
+ * @attrib:		attribute flag indicating posix symantics or not
+ *
+ * Return:		access flags
+ */
+static int convert_generic_access_flags(int access_flag, int *open_flags,
+					int *may_flags, int attrib)
+{
+	int aflags = access_flag;
+	int oflags = *open_flags;
+
+	if (aflags & GENERIC_READ) {
+		aflags &= ~GENERIC_READ;
+		aflags |= GENERIC_READ_FLAGS;
+	}
+
+	if (aflags & GENERIC_WRITE) {
+		aflags &= ~GENERIC_WRITE;
+		aflags |= GENERIC_WRITE_FLAGS;
+	}
+
+	if (aflags & GENERIC_EXECUTE) {
+		aflags &= ~GENERIC_EXECUTE;
+		aflags |= GENERIC_EXECUTE_FLAGS;
+	}
+
+	if (aflags & GENERIC_ALL) {
+		aflags &= ~GENERIC_ALL;
+		aflags |= GENERIC_ALL_FLAGS;
+	}
+
+	if (oflags & O_TRUNC)
+		aflags |= FILE_WRITE_DATA;
+
+	if (aflags & (FILE_WRITE_DATA | FILE_APPEND_DATA)) {
+		if (aflags & (FILE_READ_ATTRIBUTES | FILE_READ_DATA |
+			      FILE_READ_EA | FILE_EXECUTE)) {
+			*open_flags |= O_RDWR;
+
+		} else {
+			*open_flags |= O_WRONLY;
+		}
+	} else {
+		*open_flags |= O_RDONLY;
+	}
+
+	if ((attrib & ATTR_POSIX_SEMANTICS) && (aflags & FILE_APPEND_DATA))
+		*open_flags |= O_APPEND;
+
+	*may_flags = ksmbd_openflags_to_mayflags(*open_flags);
+
+	return aflags;
+}
+
+/**
+ * smb_get_dos_attr() - convert unix style stat info to dos attr
+ * @stat:	stat to be converted to dos attr
+ *
+ * Return:	dos style attribute
+ */
+static __u32 smb_get_dos_attr(struct kstat *stat)
+{
+	__u32 attr = 0;
+
+	/* check whether file has attributes ATTR_READONLY, ATTR_HIDDEN,
+	 * ATTR_SYSTEM, ATTR_VOLUME, ATTR_DIRECTORY, ATTR_ARCHIVE,
+	 * ATTR_DEVICE, ATTR_NORMAL, ATTR_TEMPORARY, ATTR_SPARSE,
+	 * ATTR_REPARSE, ATTR_COMPRESSED, ATTR_OFFLINE
+	 */
+
+	if (stat->mode & S_ISVTX) /* hidden */
+		attr |= (ATTR_HIDDEN | ATTR_SYSTEM);
+
+	if (!(stat->mode & 0222)) /* read-only */
+		attr |= ATTR_READONLY;
+
+	if (S_ISDIR(stat->mode))
+		attr |= ATTR_DIRECTORY;
+
+	if (stat->size > (stat->blksize * stat->blocks))
+		attr |= ATTR_SPARSE;
+
+	if (!attr)
+		attr |= ATTR_NORMAL;
+
+	return attr;
+}
+
+static int lock_oplock_release(struct ksmbd_file *fp, int type,
+			       int oplock_level)
+{
+	struct oplock_info *opinfo;
+	int ret;
+
+	ksmbd_debug(SMB, "got oplock brk for level OplockLevel = %d\n",
+		    oplock_level);
+
+	opinfo = fp->f_opinfo;
+	if (opinfo->op_state == OPLOCK_STATE_NONE) {
+		pr_err("unexpected oplock state 0x%x\n", opinfo->op_state);
+		return -EINVAL;
+	}
+
+	if (oplock_level == OPLOCK_EXCLUSIVE || oplock_level == OPLOCK_BATCH) {
+		if (opinfo_write_to_none(opinfo) < 0) {
+			opinfo->op_state = OPLOCK_STATE_NONE;
+			return -EINVAL;
+		}
+	} else if (((opinfo->level == OPLOCK_EXCLUSIVE) ||
+		    (opinfo->level == OPLOCK_BATCH)) &&
+		   (oplock_level == OPLOCK_READ)) {
+		ret = opinfo_write_to_read(opinfo);
+		if (ret) {
+			opinfo->op_state = OPLOCK_STATE_NONE;
+			return -EINVAL;
+		}
+	} else if ((opinfo->level == OPLOCK_READ) &&
+		   (oplock_level == OPLOCK_NONE)) {
+		ret = opinfo_read_to_none(opinfo);
+		if (ret) {
+			opinfo->op_state = OPLOCK_STATE_NONE;
+			return -EINVAL;
+		}
+	}
+
+	opinfo->op_state = OPLOCK_STATE_NONE;
+	wake_up_interruptible(&opinfo->oplock_q);
+
+	return 0;
+}
+
+static struct ksmbd_lock *smb_lock_init(struct file_lock *flock,
+					unsigned int cmd, int mode,
+					unsigned long long offset,
+					unsigned long long length,
+					struct list_head *lock_list)
+{
+	struct ksmbd_lock *lock;
+
+	lock = kzalloc(sizeof(struct ksmbd_lock), GFP_KERNEL);
+	if (!lock)
+		return NULL;
+
+	lock->cmd = cmd;
+	lock->fl = flock;
+	lock->start = offset;
+	lock->end = offset + length;
+	lock->flags = mode;
+	if (lock->start == lock->end)
+		lock->zero_len = 1;
+	INIT_LIST_HEAD(&lock->llist);
+	INIT_LIST_HEAD(&lock->clist);
+	INIT_LIST_HEAD(&lock->flist);
+	list_add_tail(&lock->llist, lock_list);
+
+	return lock;
+}
+
+/**
+ * smb_locking_andx() - received oplock break response from client
+ * @work:	smb work containing oplock break command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_locking_andx(struct ksmbd_work *work)
+{
+	struct smb_com_lock_req *req = work->request_buf;
+	struct smb_com_lock_rsp *rsp = work->response_buf;
+	struct ksmbd_file *fp;
+	int err = 0;
+	struct locking_andx_range32 *lock_ele32 = NULL, *unlock_ele32 = NULL;
+	struct locking_andx_range64 *lock_ele64 = NULL, *unlock_ele64 = NULL;
+	struct file *filp = NULL;
+	struct ksmbd_lock *smb_lock = NULL, *cmp_lock, *tmp, *tmp2;
+	int i, lock_count, unlock_count;
+	unsigned long long offset, length;
+	struct file_lock *flock = NULL;
+	unsigned int cmd = 0;
+	LIST_HEAD(lock_list);
+	LIST_HEAD(rollback_list);
+	int locked, timeout;
+	const unsigned long long loff_max = ~0;
+	struct ksmbd_conn *conn;
+
+	timeout = le32_to_cpu(req->Timeout);
+	ksmbd_debug(SMB, "got oplock brk for fid %d lock type = 0x%x, timeout: %d\n",
+		    req->Fid, req->LockType, timeout);
+
+	/* find fid */
+	fp = ksmbd_lookup_fd_fast(work, req->Fid);
+	if (!fp) {
+		pr_err("cannot obtain fid for %d\n", req->Fid);
+		return -EINVAL;
+	}
+
+	if (req->LockType & LOCKING_ANDX_OPLOCK_RELEASE) {
+		pr_err("lock type is oplock release\n");
+		err = lock_oplock_release(fp, req->LockType, req->OplockLevel);
+	}
+
+	filp = fp->filp;
+	lock_count = le16_to_cpu(req->NumberOfLocks);
+	unlock_count = le16_to_cpu(req->NumberOfUnlocks);
+
+	ksmbd_debug(SMB, "lock count is %d, unlock_count : %d\n", lock_count,
+		    unlock_count);
+
+	if (req->LockType & LOCKING_ANDX_LARGE_FILES)
+		lock_ele64 = (struct locking_andx_range64 *)req->Locks;
+	else
+		lock_ele32 = (struct locking_andx_range32 *)req->Locks;
+
+	if (req->LockType & LOCKING_ANDX_CHANGE_LOCKTYPE) {
+		pr_err("lock type: LOCKING_ANDX_CHANGE_LOCKTYPE\n");
+		rsp->hdr.Status.DosError.ErrorClass = ERRDOS;
+		rsp->hdr.Status.DosError.Error = cpu_to_le16(ERRnoatomiclocks);
+		rsp->hdr.Flags2 &= ~SMBFLG2_ERR_STATUS;
+		goto out;
+	}
+
+	if (req->LockType & LOCKING_ANDX_CANCEL_LOCK)
+		pr_err("lock type: LOCKING_ANDX_CANCEL_LOCK\n");
+
+	for (i = 0; i < lock_count; i++) {
+		flock = smb_flock_init(filp);
+		if (!flock)
+			goto out;
+
+		if (req->LockType & LOCKING_ANDX_SHARED_LOCK) {
+			pr_err("received shared request\n");
+			if (!(filp->f_mode & FMODE_READ)) {
+				rsp->hdr.Status.CifsError =
+					STATUS_ACCESS_DENIED;
+				locks_free_lock(flock);
+				goto out;
+			}
+			cmd = F_SETLKW;
+			flock->fl_type = F_RDLCK;
+		} else {
+			pr_err("received exclusive request\n");
+			if (!(filp->f_mode & FMODE_WRITE)) {
+				rsp->hdr.Status.CifsError =
+					STATUS_ACCESS_DENIED;
+				locks_free_lock(flock);
+				goto out;
+			}
+			cmd = F_SETLKW;
+			flock->fl_type = F_WRLCK;
+			flock->fl_flags |= FL_SLEEP;
+		}
+
+		if (req->LockType & LOCKING_ANDX_LARGE_FILES) {
+			offset = (unsigned long long)le32_to_cpu(
+					lock_ele64[i].OffsetLow);
+			length = (unsigned long long)le32_to_cpu(
+					lock_ele64[i].LengthLow);
+			offset |= (unsigned long long)le32_to_cpu(
+					lock_ele64[i].OffsetHigh) << 32;
+			length |= (unsigned long long)le32_to_cpu(
+					lock_ele64[i].LengthHigh) << 32;
+		} else {
+			offset = (unsigned long long)le32_to_cpu(
+				lock_ele32[i].Offset);
+			length = (unsigned long long)le32_to_cpu(
+				lock_ele32[i].Length);
+		}
+
+		if (offset > loff_max) {
+			pr_err("Invalid lock range requested\n");
+			rsp->hdr.Status.CifsError = STATUS_INVALID_LOCK_RANGE;
+			locks_free_lock(flock);
+			goto out;
+		}
+
+		if (offset > 0 && length > (loff_max - offset) + 1) {
+			pr_err("Invalid lock range requested\n");
+			rsp->hdr.Status.CifsError = STATUS_INVALID_LOCK_RANGE;
+			locks_free_lock(flock);
+			goto out;
+		}
+
+		ksmbd_debug(SMB, "locking offset : %llx, length : %llu\n",
+			    offset, length);
+
+		if (offset > OFFSET_MAX)
+			flock->fl_start = OFFSET_MAX;
+		else
+			flock->fl_start = offset;
+		if (offset + length > OFFSET_MAX)
+			flock->fl_end = OFFSET_MAX;
+		else
+			flock->fl_end = offset + length;
+
+		smb_lock = smb_lock_init(flock, cmd, req->LockType, offset,
+					 length, &lock_list);
+		if (!smb_lock) {
+			locks_free_lock(flock);
+			goto out;
+		}
+	}
+
+	list_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {
+		int same_zero_lock = 0;
+
+		list_del(&smb_lock->llist);
+		/* check locks in connections */
+		down_read(&conn_list_lock);
+		list_for_each_entry(conn, &conn_list, conns_list) {
+			spin_lock(&conn->llist_lock);
+			list_for_each_entry_safe(cmp_lock, tmp2, &conn->lock_list, clist) {
+				if (file_inode(cmp_lock->fl->fl_file) !=
+					file_inode(smb_lock->fl->fl_file))
+					continue;
+
+				if (smb_lock->zero_len &&
+					cmp_lock->start == smb_lock->start &&
+					cmp_lock->end == smb_lock->end) {
+					same_zero_lock = 1;
+					spin_unlock(&conn->llist_lock);
+					up_read(&conn_list_lock);
+					goto out_check_cl;
+				}
+
+				/* check zero byte lock range */
+				if (cmp_lock->zero_len && !smb_lock->zero_len &&
+						cmp_lock->start > smb_lock->start &&
+						cmp_lock->start < smb_lock->end) {
+					pr_err("previous lock conflict with zero byte lock range\n");
+					err = -EPERM;
+				} else if (smb_lock->zero_len && !cmp_lock->zero_len &&
+					smb_lock->start > cmp_lock->start &&
+					smb_lock->start < cmp_lock->end) {
+					pr_err("current lock conflict with zero byte lock range\n");
+					err = -EPERM;
+				} else if (((cmp_lock->start <= smb_lock->start &&
+					cmp_lock->end > smb_lock->start) ||
+					(cmp_lock->start < smb_lock->end &&
+					 cmp_lock->end >= smb_lock->end)) &&
+					!cmp_lock->zero_len && !smb_lock->zero_len) {
+					pr_err("Not allow lock operation on exclusive lock range\n");
+					err = -EPERM;
+				}
+
+				if (err) {
+					/* Clean error cache */
+					if ((smb_lock->zero_len &&
+							fp->cflock_cnt > 1) ||
+						(timeout && (fp->llock_fstart ==
+								smb_lock->start))) {
+						ksmbd_debug(SMB, "clean error cache\n");
+						fp->cflock_cnt = 0;
+					}
+
+					if (timeout > 0 ||
+						(fp->cflock_cnt > 0 &&
+						fp->llock_fstart == smb_lock->start) ||
+						((smb_lock->start >> 63) == 0 &&
+						smb_lock->start >= 0xEF000000)) {
+						if (timeout) {
+							spin_unlock(&conn->llist_lock);
+							up_read(&conn_list_lock);
+							ksmbd_debug(SMB, "waiting error response for timeout : %d\n",
+								timeout);
+							msleep(timeout);
+						}
+						rsp->hdr.Status.CifsError =
+							STATUS_FILE_LOCK_CONFLICT;
+					} else
+						rsp->hdr.Status.CifsError =
+							STATUS_LOCK_NOT_GRANTED;
+					fp->cflock_cnt++;
+					fp->llock_fstart = smb_lock->start;
+
+					if (timeout <= 0) {
+						spin_unlock(&conn->llist_lock);
+						up_read(&conn_list_lock);
+					}
+					goto out;
+				}
+			}
+			spin_unlock(&conn->llist_lock);
+		}
+		up_read(&conn_list_lock);
+
+out_check_cl:
+		if (same_zero_lock)
+			continue;
+		if (smb_lock->zero_len) {
+			err = 0;
+			goto skip;
+		}
+
+		flock = smb_lock->fl;
+retry:
+		err = vfs_lock_file(filp, smb_lock->cmd, flock, NULL);
+		if (err == FILE_LOCK_DEFERRED) {
+			pr_err("would have to wait for getting lock\n");
+			spin_lock(&work->conn->llist_lock);
+			list_add_tail(&smb_lock->clist, &work->conn->lock_list);
+			spin_unlock(&work->conn->llist_lock);
+			list_add(&smb_lock->llist, &rollback_list);
+wait:
+			err = ksmbd_vfs_posix_lock_wait_timeout(flock,
+							msecs_to_jiffies(10));
+			if (err) {
+				list_del(&smb_lock->llist);
+				spin_lock(&work->conn->llist_lock);
+				list_del(&smb_lock->clist);
+				spin_unlock(&work->conn->llist_lock);
+				goto retry;
+			} else
+				goto wait;
+		} else if (!err) {
+skip:
+			spin_lock(&work->conn->llist_lock);
+			list_add_tail(&smb_lock->clist, &work->conn->lock_list);
+			list_add_tail(&smb_lock->flist, &fp->lock_list);
+			spin_unlock(&work->conn->llist_lock);
+			list_add(&smb_lock->llist, &rollback_list);
+			pr_err("successful in taking lock\n");
+		} else if (err < 0) {
+			rsp->hdr.Status.CifsError = STATUS_LOCK_NOT_GRANTED;
+			goto out;
+		}
+	}
+
+	if (req->LockType & LOCKING_ANDX_LARGE_FILES)
+		unlock_ele64 = (struct locking_andx_range64 *)(req->Locks +
+				(sizeof(struct locking_andx_range64) *
+				 lock_count));
+	else
+		unlock_ele32 = (struct locking_andx_range32 *)(req->Locks +
+				(sizeof(struct locking_andx_range32) *
+				 lock_count));
+
+	for (i = 0; i < unlock_count; i++) {
+		flock = smb_flock_init(filp);
+		if (!flock)
+			goto out;
+
+		flock->fl_type = F_UNLCK;
+		cmd = 0;
+
+		if (req->LockType & LOCKING_ANDX_LARGE_FILES) {
+			offset = (unsigned long long)le32_to_cpu(
+					unlock_ele64[i].OffsetLow);
+			length = (unsigned long long)le32_to_cpu(
+					unlock_ele64[i].LengthLow);
+			offset |= (unsigned long long)le32_to_cpu(
+					unlock_ele64[i].OffsetHigh) << 32;
+			length |= (unsigned long long)le32_to_cpu(
+					unlock_ele64[i].LengthHigh) << 32;
+		} else {
+			offset = (unsigned long long)le32_to_cpu(
+				unlock_ele32[i].Offset);
+			length = (unsigned long long)le32_to_cpu(
+				unlock_ele32[i].Length);
+		}
+
+		ksmbd_debug(SMB, "unlock offset : %llx, length : %llu\n",
+			    offset, length);
+
+		if (offset > OFFSET_MAX)
+			flock->fl_start = OFFSET_MAX;
+		else
+			flock->fl_start = offset;
+		if (offset + length > OFFSET_MAX)
+			flock->fl_end = OFFSET_MAX;
+		else
+			flock->fl_end = offset + length;
+
+		locked = 0;
+		up_read(&conn_list_lock);
+		list_for_each_entry(conn, &conn_list, conns_list) {
+			spin_lock(&conn->llist_lock);
+			list_for_each_entry(cmp_lock, &conn->lock_list, clist) {
+				if (file_inode(cmp_lock->fl->fl_file) !=
+					file_inode(flock->fl_file))
+					continue;
+
+				if ((cmp_lock->start == offset &&
+					 cmp_lock->end == offset + length)) {
+					locked = 1;
+					spin_unlock(&conn->llist_lock);
+					up_read(&conn_list_lock);
+					goto out_check_cl_unlck;
+				}
+			}
+			spin_unlock(&conn->llist_lock);
+		}
+		up_read(&conn_list_lock);
+
+out_check_cl_unlck:
+		if (!locked) {
+			locks_free_lock(flock);
+			rsp->hdr.Status.CifsError = STATUS_RANGE_NOT_LOCKED;
+			goto out;
+		}
+
+		err = vfs_lock_file(filp, cmd, flock, NULL);
+		if (!err) {
+			ksmbd_debug(SMB, "File unlocked\n");
+			spin_lock(&conn->llist_lock);
+			if (!list_empty(&cmp_lock->flist))
+				list_del(&cmp_lock->flist);
+			list_del(&cmp_lock->clist);
+			spin_unlock(&conn->llist_lock);
+
+			locks_free_lock(cmp_lock->fl);
+			kfree(cmp_lock);
+			fp->cflock_cnt = 0;
+		} else if (err == -ENOENT) {
+			rsp->hdr.Status.CifsError = STATUS_RANGE_NOT_LOCKED;
+			locks_free_lock(flock);
+			goto out;
+		}
+		locks_free_lock(flock);
+	}
+
+	rsp->hdr.WordCount = 2;
+	rsp->ByteCount = 0;
+	inc_rfc1001_len(&rsp->hdr, (rsp->hdr.WordCount * 2));
+
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(&rsp->hdr));
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		return rsp->AndXCommand; /* More processing required */
+	}
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+	ksmbd_fd_put(work, fp);
+	return err;
+
+out:
+	list_for_each_entry_safe(smb_lock, tmp, &lock_list, llist) {
+		locks_free_lock(smb_lock->fl);
+		list_del(&smb_lock->llist);
+		kfree(smb_lock);
+	}
+
+	list_for_each_entry_safe(smb_lock, tmp, &rollback_list, llist) {
+		struct file_lock *rlock = NULL;
+
+		rlock = smb_flock_init(filp);
+		rlock->fl_type = F_UNLCK;
+		rlock->fl_start = smb_lock->start;
+		rlock->fl_end = smb_lock->end;
+
+		err = vfs_lock_file(filp, 0, rlock, NULL);
+		if (err)
+			pr_err("rollback unlock fail : %d\n", err);
+
+		list_del(&smb_lock->llist);
+		spin_lock(&work->conn->llist_lock);
+		if (!list_empty(&smb_lock->flist))
+			list_del(&smb_lock->flist);
+		list_del(&smb_lock->clist);
+		spin_unlock(&work->conn->llist_lock);
+
+		locks_free_lock(smb_lock->fl);
+		locks_free_lock(rlock);
+		kfree(smb_lock);
+	}
+
+	ksmbd_fd_put(work, fp);
+	pr_err("failed in taking lock\n");
+	return err;
+}
+
+/**
+ * smb_trans() - trans2 command dispatcher
+ * @work:	smb work containing trans2 command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_trans(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+	struct smb_com_trans_req *req = work->request_buf;
+	struct smb_com_trans_rsp *rsp = work->response_buf;
+	struct smb_com_trans_pipe_req *pipe_req = work->request_buf;
+	struct ksmbd_rpc_command *rpc_resp;
+	__u16 subcommand;
+	char *name, *pipe;
+	char *pipedata;
+	int setup_bytes_count = 0;
+	int pipe_name_offset = 0;
+	int str_len_uni;
+	int ret = 0, nbytes = 0;
+	int param_len = 0;
+	int id;
+	int padding;
+
+	if (req->SetupCount)
+		setup_bytes_count = 2 * req->SetupCount;
+
+	subcommand = le16_to_cpu(req->SubCommand);
+	name = smb_strndup_from_utf16(req->Data + setup_bytes_count, 256, 1,
+				      conn->local_nls);
+
+	if (IS_ERR(name)) {
+		pr_err("failed to allocate memory\n");
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		return PTR_ERR(name);
+	}
+
+	ksmbd_debug(SMB, "Obtained string name = %s setupcount = %d\n",
+			name, setup_bytes_count);
+
+	pipe_name_offset = strlen("\\PIPE");
+	if (strncmp("\\PIPE", name, pipe_name_offset) != 0) {
+		ksmbd_debug(SMB, "Not Pipe request\n");
+		rsp->hdr.Status.CifsError = STATUS_NOT_SUPPORTED;
+		kfree(name);
+		return 0;
+	}
+
+	if (name[pipe_name_offset] == '\\')
+		pipe_name_offset++;
+
+	pipe = name + pipe_name_offset;
+
+	if (*pipe != '\0' && strncmp(pipe, "LANMAN", sizeof("LANMAN")) != 0) {
+		ksmbd_debug(SMB, "Pipe %s not supported request\n", pipe);
+		rsp->hdr.Status.CifsError = STATUS_NOT_SUPPORTED;
+		kfree(name);
+		return 0;
+	}
+
+	/* Incoming pipe name unicode len */
+	str_len_uni = 2 * (strlen(name) + 1);
+
+	ksmbd_debug(SMB, "Pipe name unicode len = %d\n", str_len_uni);
+
+	/* Some clients like Windows may have additional padding. */
+	padding = le16_to_cpu(req->ParameterOffset) -
+		offsetof(struct smb_com_trans_req, Data)
+		- str_len_uni;
+	pipedata = req->Data + str_len_uni + setup_bytes_count + padding;
+
+	if (!strncmp(pipe, "LANMAN", sizeof("LANMAN"))) {
+		rpc_resp = ksmbd_rpc_rap(work->sess, pipedata,
+					 le16_to_cpu(req->TotalParameterCount));
+
+		if (rpc_resp) {
+			if (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {
+				rsp->hdr.Status.CifsError =
+					STATUS_NOT_SUPPORTED;
+				kvfree(rpc_resp);
+				goto out;
+			} else if (rpc_resp->flags != KSMBD_RPC_OK) {
+				rsp->hdr.Status.CifsError =
+					STATUS_INVALID_PARAMETER;
+				kvfree(rpc_resp);
+				goto out;
+			}
+
+			nbytes = rpc_resp->payload_sz;
+			memcpy((char *)rsp + sizeof(struct smb_com_trans_rsp),
+			       rpc_resp->payload, nbytes);
+
+			kvfree(rpc_resp);
+			ret = 0;
+			goto resp_out;
+		} else {
+			ret = -EINVAL;
+			goto out;
+		}
+	}
+
+	id = pipe_req->fid;
+	switch (subcommand) {
+	case TRANSACT_DCERPCCMD:
+
+		ksmbd_debug(SMB, "GOT TRANSACT_DCERPCCMD\n");
+		ret = -EINVAL;
+		rpc_resp = ksmbd_rpc_ioctl(work->sess, id, pipedata,
+					   le16_to_cpu(req->DataCount));
+		if (rpc_resp) {
+			if (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {
+				rsp->hdr.Status.CifsError =
+					STATUS_NOT_SUPPORTED;
+				kvfree(rpc_resp);
+				goto out;
+			} else if (rpc_resp->flags != KSMBD_RPC_OK) {
+				rsp->hdr.Status.CifsError =
+					STATUS_INVALID_PARAMETER;
+				kvfree(rpc_resp);
+				goto out;
+			}
+
+			nbytes = rpc_resp->payload_sz;
+			memcpy((char *)rsp + sizeof(struct smb_com_trans_rsp),
+			       rpc_resp->payload, nbytes);
+			kvfree(rpc_resp);
+			ret = 0;
+		}
+		break;
+
+	default:
+		ksmbd_debug(SMB, "SMB TRANS subcommand not supported %u\n",
+			    subcommand);
+		ret = -EOPNOTSUPP;
+		rsp->hdr.Status.CifsError = STATUS_NOT_SUPPORTED;
+		goto out;
+	}
+
+resp_out:
+
+	rsp->hdr.WordCount = 10;
+	rsp->TotalParameterCount = cpu_to_le16(param_len);
+	rsp->TotalDataCount = cpu_to_le16(nbytes);
+	rsp->Reserved = 0;
+	rsp->ParameterCount = cpu_to_le16(param_len);
+	rsp->ParameterOffset = cpu_to_le16(56);
+	rsp->ParameterDisplacement = 0;
+	rsp->DataCount = cpu_to_le16(nbytes);
+	rsp->DataOffset = cpu_to_le16(56 + param_len);
+	rsp->DataDisplacement = 0;
+	rsp->SetupCount = 0;
+	rsp->Reserved1 = 0;
+	/* Adding 1 for Pad */
+	rsp->ByteCount = cpu_to_le16(nbytes + 1 + param_len);
+	rsp->Pad = 0;
+	inc_rfc1001_len(&rsp->hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+
+out:
+	kfree(name);
+	return ret;
+}
+
+/**
+ * create_andx_pipe() - create ipc pipe request handler
+ * @work:	smb work containing create command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int create_andx_pipe(struct ksmbd_work *work)
+{
+	struct smb_com_open_req *req = work->request_buf;
+	struct smb_com_open_ext_rsp *rsp = work->response_buf;
+	char *name;
+	int rc = 0;
+	__u16 fid;
+
+	/* one byte pad before unicode file name start */
+	if (is_smbreq_unicode(&req->hdr))
+		name = smb_strndup_from_utf16(req->fileName + 1, 256, 1,
+					      work->conn->local_nls);
+	else
+		name = smb_strndup_from_utf16(req->fileName, 256, 1,
+					      work->conn->local_nls);
+
+	if (IS_ERR(name)) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	rc = ksmbd_session_rpc_open(work->sess, name);
+	if (rc < 0)
+		goto out;
+	fid = rc;
+
+	rsp->hdr.WordCount = 42;
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+	rsp->AndXReserved = 0;
+	rsp->OplockLevel = 0;
+	rsp->Fid = fid;
+	rsp->CreateAction = cpu_to_le32(1);
+	rsp->CreationTime = 0;
+	rsp->LastAccessTime = 0;
+	rsp->LastWriteTime = 0;
+	rsp->ChangeTime = 0;
+	rsp->FileAttributes = cpu_to_le32(ATTR_NORMAL);
+	rsp->AllocationSize = cpu_to_le64(0);
+	rsp->EndOfFile = 0;
+	rsp->FileType = cpu_to_le16(2);
+	rsp->DeviceState = cpu_to_le16(0x05ff);
+	rsp->DirectoryFlag = 0;
+	rsp->fid = 0;
+	rsp->MaxAccess = cpu_to_le32(FILE_GENERIC_ALL);
+	rsp->GuestAccess = cpu_to_le32(FILE_GENERIC_READ);
+	rsp->ByteCount = 0;
+	inc_rfc1001_len(&rsp->hdr, 100);
+
+out:
+	switch (rc) {
+	case 0:
+		rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+		break;
+	case -EINVAL:
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		break;
+	case -ENOSPC:
+	case -ENOMEM:
+	default:
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		break;
+	}
+
+	kfree(name);
+	return rc;
+}
+
+/*
+ * helper to create a file/directory with a given mode
+ */
+static int smb_common_create(struct ksmbd_work *work, struct path *parent_path,
+			     struct path *path, char *name, int open_flags,
+			     umode_t posix_mode, bool is_dir)
+{
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	umode_t mode;
+	int err;
+
+	if (!(open_flags & O_CREAT))
+		return -EBADF;
+
+	if (is_dir) {
+		mode = share_config_directory_mode(share, posix_mode);
+		ksmbd_debug(SMB, "creating directory (mode=%04o)\n", mode);
+		err = ksmbd_vfs_mkdir(work, name, mode);
+		if (err)
+			return err;
+	} else {
+		mode = share_config_create_mode(share, posix_mode);
+		ksmbd_debug(SMB, "creating regular file (mode=%04o)\n", mode);
+		err = ksmbd_vfs_create(work, name, mode);
+		if (err)
+			return err;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	err = ksmbd_vfs_kern_path_locked(work, name, 0, parent_path, path, 0);
+	if (err) {
+		pr_err("cannot get linux path (%s), err = %d\n", name, err);
+		return err;
+	}
+
+#else
+	err = ksmbd_vfs_kern_path(work, name, 0, path, 0);
+	if (err) {
+		pr_err("cannot get linux path (%s), err = %d\n", name, err);
+		return err;
+	}
+#endif
+
+	return 0;
+}
+
+/**
+ * smb_nt_create_andx() - file open request handler
+ * @work:	smb work containing nt open command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_nt_create_andx(struct ksmbd_work *work)
+{
+	struct smb_com_open_req *req = work->request_buf;
+	struct smb_com_open_rsp *rsp = work->response_buf;
+	struct smb_com_open_ext_rsp *ext_rsp = work->response_buf;
+	struct ksmbd_conn *conn = work->conn;
+	struct ksmbd_tree_connect *tcon = work->tcon;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct path path, parent_path;
+	struct kstat stat;
+	int oplock_flags, file_info, open_flags, may_flags, access_flags;
+	char *name;
+	char *conv_name = NULL;
+	bool file_present = true, extended_reply;
+	__u64 alloc_size = 0, time;
+	umode_t mode = 0;
+	int err = 0;
+	int create_directory = 0;
+	char *src;
+	char *root = NULL;
+	bool is_unicode;
+	bool is_relative_root = false;
+	struct ksmbd_file *fp = NULL;
+	int oplock_rsp = OPLOCK_NONE;
+	int share_ret;
+
+	rsp->hdr.Status.CifsError = STATUS_UNSUCCESSFUL;
+	if (test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_PIPE)) {
+		ksmbd_debug(SMB, "create pipe on IPC\n");
+		return create_andx_pipe(work);
+	}
+
+	if (req->CreateOptions & FILE_OPEN_BY_FILE_ID_LE) {
+		ksmbd_debug(SMB, "file open with FID is not supported\n");
+		rsp->hdr.Status.CifsError = STATUS_NOT_SUPPORTED;
+		return -EINVAL;
+	}
+
+	if (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE) {
+		if (req->DesiredAccess &&
+		    !(le32_to_cpu(req->DesiredAccess) & DELETE)) {
+			rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+			return -EPERM;
+		}
+
+		if (le32_to_cpu(req->FileAttributes) & ATTR_READONLY) {
+			rsp->hdr.Status.CifsError = STATUS_CANNOT_DELETE;
+			return -EPERM;
+		}
+	}
+
+	if (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {
+		ksmbd_debug(SMB, "GOT Create Directory via CREATE ANDX\n");
+		create_directory = 1;
+	}
+
+	/*
+	 * Filename is relative to this root directory FID, instead of
+	 * tree connect point. Find root dir name from this FID and
+	 * prepend root dir name in filename.
+	 */
+	if (req->RootDirectoryFid) {
+		ksmbd_debug(SMB, "path lookup relative to RootDirectoryFid\n");
+
+		is_relative_root = true;
+		fp = ksmbd_lookup_fd_fast(work, req->RootDirectoryFid);
+		if (fp)
+			root = (char *)fp->filp->f_path.dentry->d_name.name;
+		else {
+			rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+			memset(&rsp->hdr.WordCount, 0, 3);
+			return -EINVAL;
+		}
+		ksmbd_fd_put(work, fp);
+	}
+
+	/* here allocated +2 (UNI '\0') length for both ASCII & UNI
+	 * to avoid unnecessary if/else check
+	 */
+	src = kzalloc(le16_to_cpu(req->NameLength) + 2, GFP_KERNEL);
+	if (!src) {
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+
+		return -ENOMEM;
+	}
+
+	if (is_smbreq_unicode(&req->hdr)) {
+		memcpy(src, req->fileName + 1, le16_to_cpu(req->NameLength));
+		is_unicode = true;
+	} else {
+		memcpy(src, req->fileName, le16_to_cpu(req->NameLength));
+		is_unicode = false;
+	}
+
+	name = smb_strndup_from_utf16(src, PATH_MAX, is_unicode,
+				      conn->local_nls);
+	kfree(src);
+
+	if (IS_ERR(name)) {
+		if (PTR_ERR(name) == -ENOMEM) {
+			pr_err("failed to allocate memory\n");
+			rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		} else
+			rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+
+		return PTR_ERR(name);
+	}
+
+	if (is_relative_root) {
+		char *full_name;
+
+		full_name = kasprintf(GFP_KERNEL, "\\%s\\%s", root, name);
+		if (!full_name) {
+			kfree(name);
+			rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+			return -ENOMEM;
+		}
+
+		kfree(name);
+		name = full_name;
+	}
+
+	root = strrchr(name, '\\');
+	if (root) {
+		root++;
+		if ((root[0] == '*' || root[0] == '/') && (root[1] == '\0')) {
+			rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+			kfree(name);
+			return -EINVAL;
+		}
+	}
+
+	conv_name = smb_get_name(share, name, PATH_MAX, work, true);
+	if (IS_ERR(conv_name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		kfree(name);
+		return PTR_ERR(conv_name);
+	}
+
+	if (ksmbd_override_fsids(work)) {
+		err = -ENOMEM;
+		goto out1;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	err = ksmbd_vfs_kern_path_locked(work, conv_name, LOOKUP_NO_SYMLINKS,
+					 &parent_path, &path,
+					 (req->hdr.Flags & SMBFLG_CASELESS) &&
+						!create_directory);
+#else
+	err = ksmbd_vfs_kern_path(work, conv_name, LOOKUP_NO_SYMLINKS, &path,
+			(req->hdr.Flags & SMBFLG_CASELESS) &&
+			!create_directory);
+#endif
+	if (err) {
+		if (err == -EACCES || err == -EXDEV)
+			goto out;
+		file_present = false;
+		ksmbd_debug(SMB, "can not get linux path for %s, err = %d\n",
+			    conv_name, err);
+	} else {
+		if (d_is_symlink(path.dentry)) {
+			err = -EACCES;
+			goto free_path;
+		}
+
+		err = vfs_getattr(&path, &stat, STATX_BASIC_STATS,
+				  AT_STATX_SYNC_AS_STAT);
+		if (err) {
+			pr_err("can not stat %s, err = %d\n", conv_name, err);
+			goto free_path;
+		}
+	}
+
+	if (file_present &&
+	    (req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE) &&
+	    S_ISDIR(stat.mode)) {
+		ksmbd_debug(SMB, "Can't open dir %s, request is to open file\n",
+			    conv_name);
+		if (!(((struct smb_hdr *)work->request_buf)->Flags2 &
+					SMBFLG2_ERR_STATUS)) {
+			rsp->hdr.Status.DosError.ErrorClass = ERRDOS;
+			rsp->hdr.Status.DosError.Error =
+				cpu_to_le16(ERRfilexists);
+		} else
+			rsp->hdr.Status.CifsError =
+				STATUS_OBJECT_NAME_COLLISION;
+
+		memset(&rsp->hdr.WordCount, 0, 3);
+
+		goto free_path;
+	}
+
+	if (file_present && create_directory && !S_ISDIR(stat.mode)) {
+		ksmbd_debug(SMB, "Can't open file %s, request is to open dir\n",
+			    conv_name);
+		if (!(((struct smb_hdr *)work->request_buf)->Flags2 &
+					SMBFLG2_ERR_STATUS)) {
+			ntstatus_to_dos(STATUS_NOT_A_DIRECTORY,
+					&rsp->hdr.Status.DosError.ErrorClass,
+					&rsp->hdr.Status.DosError.Error);
+		} else
+			rsp->hdr.Status.CifsError = STATUS_NOT_A_DIRECTORY;
+
+		memset(&rsp->hdr.WordCount, 0, 3);
+
+		goto free_path;
+	}
+
+	oplock_flags = le32_to_cpu(req->OpenFlags) &
+		(REQ_OPLOCK | REQ_BATCHOPLOCK);
+	extended_reply = le32_to_cpu(req->OpenFlags) & REQ_EXTENDED_INFO;
+	open_flags = file_create_dispostion_flags(
+			le32_to_cpu(req->CreateDisposition), file_present);
+
+	if (open_flags < 0) {
+		ksmbd_debug(SMB, "create_dispostion returned %d\n", open_flags);
+		if (file_present) {
+			if (!(((struct smb_hdr *)work->request_buf)->Flags2 &
+						SMBFLG2_ERR_STATUS)) {
+				rsp->hdr.Status.DosError.ErrorClass = ERRDOS;
+				rsp->hdr.Status.DosError.Error =
+					cpu_to_le16(ERRfilexists);
+			} else if (open_flags == -EINVAL)
+				rsp->hdr.Status.CifsError =
+					STATUS_INVALID_PARAMETER;
+			else
+				rsp->hdr.Status.CifsError =
+					STATUS_OBJECT_NAME_COLLISION;
+			memset(&rsp->hdr.WordCount, 0, 3);
+			goto free_path;
+		} else {
+			err = -ENOENT;
+			goto out;
+		}
+	} else {
+		if (file_present) {
+			if (S_ISFIFO(stat.mode))
+				open_flags |= O_NONBLOCK;
+		}
+
+		if (req->CreateOptions & FILE_WRITE_THROUGH_LE)
+			open_flags |= O_SYNC;
+	}
+
+	access_flags =
+		convert_generic_access_flags(le32_to_cpu(req->DesiredAccess),
+					     &open_flags, &may_flags,
+					     le32_to_cpu(req->FileAttributes));
+
+	mode |= 0777;
+	if (le32_to_cpu(req->FileAttributes) & ATTR_READONLY)
+		mode &= ~0222;
+
+	/* TODO:
+	 * - check req->ShareAccess for sharing file among different process
+	 * - check req->FileAttributes for special/readonly file attrib
+	 * - check req->SecurityFlags for client security context tracking
+	 * - check req->ImpersonationLevel
+	 */
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		if (open_flags & O_CREAT) {
+			ksmbd_debug(SMB,
+				"returning as user does not have permission to write\n");
+			err = -EACCES;
+			if (file_present)
+				goto free_path;
+			else
+				goto out;
+		}
+	}
+
+	ksmbd_debug(SMB, "filename : %s, open_flags = 0x%x\n", conv_name,
+		    open_flags);
+	if (!file_present && (open_flags & O_CREAT)) {
+		if (!create_directory)
+			mode |= S_IFREG;
+
+		err = smb_common_create(work, &parent_path, &path, conv_name,
+					open_flags, mode, create_directory);
+		if (err) {
+			ksmbd_debug(SMB, "smb_common_create err: %d\n", err);
+			goto out;
+		}
+	} else {
+		err = compat_inode_permission(&path, d_inode(path.dentry),
+					      may_flags);
+		if (err)
+			goto free_path;
+	}
+
+	err = ksmbd_query_inode_status(path.dentry->d_parent);
+	if (err == KSMBD_INODE_STATUS_PENDING_DELETE) {
+		err = -EBUSY;
+		goto free_path;
+	}
+
+	err = 0;
+	/* open file and get FID */
+	fp = ksmbd_vfs_dentry_open(work,
+				   &path,
+				   open_flags,
+				   req->CreateOptions,
+				   file_present);
+	if (IS_ERR(fp)) {
+		err = PTR_ERR(fp);
+		fp = NULL;
+		goto free_path;
+	}
+	fp->daccess = req->DesiredAccess;
+	fp->saccess = req->ShareAccess;
+	fp->pid = le16_to_cpu(req->hdr.Pid);
+
+	write_lock(&fp->f_ci->m_lock);
+	list_add(&fp->node, &fp->f_ci->m_fp_list);
+	write_unlock(&fp->f_ci->m_lock);
+
+	share_ret = ksmbd_smb_check_shared_mode(fp->filp, fp);
+	if (smb1_oplock_enable &&
+	    test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_OPLOCKS) &&
+	    !S_ISDIR(file_inode(fp->filp)->i_mode) && oplock_flags) {
+		/* Client cannot request levelII oplock directly */
+		err = smb_grant_oplock(work, oplock_flags, fp->volatile_id, fp,
+				       le16_to_cpu(req->hdr.Tid), NULL,
+				       share_ret);
+		if (err)
+			goto free_path;
+	} else {
+		if (ksmbd_inode_pending_delete(fp)) {
+			err = -EBUSY;
+			goto free_path;
+		}
+
+		if (share_ret < 0) {
+			err = -EPERM;
+			goto free_path;
+		}
+	}
+
+	oplock_rsp = fp->f_opinfo != NULL ? fp->f_opinfo->level : 0;
+
+	if (file_present) {
+		if (!(open_flags & O_TRUNC))
+			file_info = F_OPENED;
+		else
+			file_info = F_OVERWRITTEN;
+	} else
+		file_info = F_CREATED;
+
+	if (le32_to_cpu(req->DesiredAccess) & (DELETE | GENERIC_ALL))
+		fp->is_nt_open = 1;
+	if ((le32_to_cpu(req->DesiredAccess) & DELETE) &&
+			(req->CreateOptions & FILE_DELETE_ON_CLOSE_LE))
+		ksmbd_fd_set_delete_on_close(fp, file_info);
+
+	/* open success, send back response */
+	err = vfs_getattr(&path, &stat, STATX_BASIC_STATS,
+			  AT_STATX_SYNC_AS_STAT);
+	if (err) {
+		pr_err("cannot get stat information\n");
+		goto free_path;
+	}
+
+	alloc_size = le64_to_cpu(req->AllocationSize);
+	if (alloc_size &&
+	    (file_info == F_CREATED || file_info == F_OVERWRITTEN)) {
+		if (alloc_size > stat.size) {
+			err = ksmbd_vfs_truncate(work, fp, alloc_size);
+			if (err) {
+				pr_err("failed to expand file, err = %d\n",
+				       err);
+				goto free_path;
+			}
+		}
+	}
+
+	/* prepare response buffer */
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+
+	rsp->OplockLevel = oplock_rsp;
+	rsp->Fid = fp->volatile_id;
+
+	if ((le32_to_cpu(req->CreateDisposition) == FILE_SUPERSEDE) &&
+	    (file_info == F_OVERWRITTEN))
+		rsp->CreateAction = cpu_to_le32(F_SUPERSEDED);
+	else
+		rsp->CreateAction = cpu_to_le32(file_info);
+
+	if (stat.result_mask & STATX_BTIME)
+		fp->create_time = ksmbd_UnixTimeToNT(stat.btime);
+	else
+		fp->create_time = ksmbd_UnixTimeToNT(stat.ctime);
+	if (file_present) {
+		if (test_share_config_flag(tcon->share_conf,
+					   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
+			struct xattr_dos_attrib da;
+
+			err = compat_ksmbd_vfs_get_dos_attrib_xattr(&path,
+								    path.dentry,
+								    &da);
+			if (err > 0)
+				fp->create_time = da.create_time;
+			err = 0;
+		}
+	} else {
+		if (test_share_config_flag(tcon->share_conf,
+					   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
+			struct xattr_dos_attrib da = {0};
+
+			da.version = 4;
+			da.attr = smb_get_dos_attr(&stat);
+			da.create_time = fp->create_time;
+
+			err = compat_ksmbd_vfs_set_dos_attrib_xattr(&path,
+								    &da, false);
+			if (err)
+				ksmbd_debug(SMB, "failed to store creation time in xattr\n");
+			err = 0;
+		}
+	}
+
+	rsp->CreationTime = cpu_to_le64(fp->create_time);
+	time = ksmbd_UnixTimeToNT(stat.atime);
+	rsp->LastAccessTime = cpu_to_le64(time);
+	time = ksmbd_UnixTimeToNT(stat.mtime);
+	rsp->LastWriteTime = cpu_to_le64(time);
+	time = ksmbd_UnixTimeToNT(stat.ctime);
+	rsp->ChangeTime = cpu_to_le64(time);
+
+	rsp->FileAttributes = cpu_to_le32(smb_get_dos_attr(&stat));
+	rsp->AllocationSize = cpu_to_le64(stat.blocks << 9);
+	rsp->EndOfFile = cpu_to_le64(stat.size);
+	/* TODO: is it normal file, named pipe, printer, modem etc*/
+	rsp->FileType = 0;
+	/* status of named pipe*/
+	rsp->DeviceState = 0;
+	rsp->DirectoryFlag = S_ISDIR(stat.mode) ? 1 : 0;
+	if (extended_reply) {
+		struct inode *inode;
+
+		rsp->hdr.WordCount = 50;
+		memset(&ext_rsp->VolId, 0, 16);
+		if (fp) {
+			inode = file_inode(fp->filp);
+			ext_rsp->fid = inode->i_ino;
+			if (S_ISDIR(inode->i_mode) ||
+			    (fp->filp->f_mode & FMODE_WRITE))
+				ext_rsp->MaxAccess = FILE_GENERIC_ALL_LE;
+			else
+				ext_rsp->MaxAccess = FILE_GENERIC_READ_LE |
+						     FILE_EXECUTE_LE;
+		} else {
+			ext_rsp->MaxAccess = FILE_GENERIC_ALL_LE;
+			ext_rsp->fid = 0;
+		}
+
+		ext_rsp->ByteCount = 0;
+
+	} else {
+		rsp->hdr.WordCount = 34;
+		rsp->ByteCount = 0;
+	}
+	inc_rfc1001_len(&rsp->hdr, (rsp->hdr.WordCount * 2 + 0));
+
+free_path:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	path_put(&path);
+#endif
+out:
+	ksmbd_revert_fsids(work);
+out1:
+	switch (err) {
+	case 0:
+		ksmbd_update_fstate(&work->sess->file_table, fp, FP_INITED);
+		break;
+	case -ENOSPC:
+		rsp->hdr.Status.CifsError = STATUS_DISK_FULL;
+		break;
+	case -EMFILE:
+		rsp->hdr.Status.CifsError = STATUS_TOO_MANY_OPENED_FILES;
+		break;
+	case -EINVAL:
+		rsp->hdr.Status.CifsError = STATUS_NO_SUCH_USER;
+		break;
+	case -EACCES:
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		break;
+	case -EPERM:
+		rsp->hdr.Status.CifsError = STATUS_SHARING_VIOLATION;
+		break;
+	case -ENOENT:
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_NOT_FOUND;
+		break;
+	case -EBUSY:
+		rsp->hdr.Status.CifsError = STATUS_DELETE_PENDING;
+		break;
+	case -EOPNOTSUPP:
+		rsp->hdr.Status.CifsError = STATUS_NOT_SUPPORTED;
+		break;
+	case -ENOMEM:
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		break;
+	default:
+		rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+	}
+
+	if (err && fp)
+		ksmbd_close_fd(work, fp->volatile_id);
+
+	kfree(conv_name);
+
+	if (!rsp->hdr.WordCount)
+		return err;
+
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(&rsp->hdr));
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		return rsp->AndXCommand; /* More processing required */
+	}
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+
+	return err;
+}
+
+/**
+ * smb_close_pipe() - ipc pipe close request handler
+ * @work:	smb work containing close command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_close_pipe(struct ksmbd_work *work)
+{
+	struct smb_com_close_req *req = work->request_buf;
+
+	ksmbd_session_rpc_close(work->sess, req->FileID);
+	return 0;
+}
+
+/**
+ * smb_close() - ipc pipe close request handler
+ * @work:	smb work containing close command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_close(struct ksmbd_work *work)
+{
+	struct smb_com_close_req *req = work->request_buf;
+	struct smb_com_close_rsp *rsp = work->response_buf;
+	int err = 0;
+
+	ksmbd_debug(SMB, "SMB_COM_CLOSE called for fid %u\n", req->FileID);
+
+	if (test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_PIPE)) {
+		err = smb_close_pipe(work);
+		if (err < 0)
+			goto out;
+		goto IPC_out;
+	}
+
+	/*
+	 * TODO: linux cifs client does not send LastWriteTime,
+	 * need to check if windows client use this field
+	 */
+	if (le32_to_cpu(req->LastWriteTime) > 0 &&
+	    le32_to_cpu(req->LastWriteTime) < 0xFFFFFFFF)
+		pr_info("need to set last modified time before close\n");
+
+	err = ksmbd_close_fd(work, req->FileID);
+
+IPC_out:
+	/* file close success, return response to server */
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 0;
+	rsp->ByteCount = 0;
+
+out:
+	if (err)
+		rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+	return err;
+}
+
+/**
+ * smb_read_andx_pipe() - read from ipc pipe request handler
+ * @work:	smb work containing read command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_read_andx_pipe(struct ksmbd_work *work)
+{
+	struct smb_com_read_req *req = work->request_buf;
+	struct smb_com_read_rsp *rsp = work->response_buf;
+	struct ksmbd_rpc_command *rpc_resp;
+	char *data_buf;
+	int ret = 0, nbytes = 0;
+	unsigned int count;
+	unsigned int rsp_buflen = MAX_CIFS_SMALL_BUFFER_SIZE -
+		sizeof(struct smb_com_read_rsp);
+
+	rsp_buflen = min((unsigned int)(MAX_CIFS_SMALL_BUFFER_SIZE -
+				sizeof(struct smb_com_read_rsp)), rsp_buflen);
+
+	count = min_t(unsigned int, le16_to_cpu(req->MaxCount), rsp_buflen);
+	data_buf = (char *) (&rsp->ByteCount) + sizeof(rsp->ByteCount);
+
+	rpc_resp = ksmbd_rpc_read(work->sess, req->Fid);
+	if (rpc_resp) {
+		if (rpc_resp->flags != KSMBD_RPC_OK || !rpc_resp->payload_sz) {
+			rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+			kvfree(rpc_resp);
+			return -EINVAL;
+		}
+
+		nbytes = rpc_resp->payload_sz;
+		memcpy(data_buf, rpc_resp->payload, rpc_resp->payload_sz);
+		kvfree(rpc_resp);
+	} else {
+		ret = -EINVAL;
+	}
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 12;
+	rsp->Remaining = 0;
+	rsp->DataCompactionMode = 0;
+	rsp->DataCompactionMode = 0;
+	rsp->Reserved = 0;
+	rsp->DataLength = cpu_to_le16(nbytes & 0xFFFF);
+	rsp->DataOffset = cpu_to_le16(sizeof(struct smb_com_read_rsp) -
+			sizeof(rsp->hdr.smb_buf_length));
+	rsp->DataLengthHigh = cpu_to_le16(nbytes >> 16);
+	rsp->Reserved2 = 0;
+
+	rsp->ByteCount = cpu_to_le16(nbytes);
+	inc_rfc1001_len(&rsp->hdr, (rsp->hdr.WordCount * 2 + nbytes));
+
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(&rsp->hdr));
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		return rsp->AndXCommand; /* More processing required */
+	}
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+
+	return ret;
+}
+
+/**
+ * smb_read_andx() - read request handler
+ * @work:	smb work containing read command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_read_andx(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+	struct smb_com_read_req *req = work->request_buf;
+	struct smb_com_read_rsp *rsp = work->response_buf;
+	struct ksmbd_file *fp;
+	loff_t pos;
+	size_t count;
+	ssize_t nbytes;
+	int err = 0;
+
+	if (test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_PIPE))
+		return smb_read_andx_pipe(work);
+
+	fp = ksmbd_lookup_fd_fast(work, req->Fid);
+	if (!fp) {
+		pr_err("failed to get filp for fid %d\n", req->Fid);
+		rsp->hdr.Status.CifsError = STATUS_FILE_CLOSED;
+		return -ENOENT;
+	}
+
+	pos = le32_to_cpu(req->OffsetLow);
+	if (req->hdr.WordCount == 12)
+		pos |= ((loff_t)le32_to_cpu(req->OffsetHigh) << 32);
+
+	count = le16_to_cpu(req->MaxCount);
+	/*
+	 * It probably seems to be set to 0 or 0xFFFF if MaxCountHigh is
+	 * not supported. If it is 0xFFFF, it is set to a too large value
+	 * and a read fail occurs. If it is 0xFFFF, limit it to not set
+	 * the value.
+	 *
+	 * [MS-SMB] 3.2.4.4.1:
+	 * If the CAP_LARGE_READX bit is set in
+	 * Client.Connection.ServerCapabilities, then the client is allowed to
+	 * issue a read of a size larger than Client.Connection.MaxBufferSize
+	 * using an SMB_COM_READ_ANDX request.
+	 */
+	if (conn->vals->capabilities & CAP_LARGE_READ_X &&
+	    le32_to_cpu(req->MaxCountHigh) < 0xFFFF)
+		count |= le32_to_cpu(req->MaxCountHigh) << 16;
+	else if (count > CIFS_DEFAULT_IOSIZE) {
+		ksmbd_debug(SMB, "read size(%zu) exceeds max size(%u)\n", count,
+			    CIFS_DEFAULT_IOSIZE);
+		ksmbd_debug(SMB, "limiting read size to max size(%u)\n",
+			    CIFS_DEFAULT_IOSIZE);
+		count = CIFS_DEFAULT_IOSIZE;
+	}
+
+	ksmbd_debug(SMB, "filename %pd, offset %lld, count %zu\n",
+		    fp->filp->f_path.dentry, pos, count);
+
+	work->aux_payload_buf = kvmalloc(count, GFP_KERNEL | __GFP_ZERO);
+	if (!work->aux_payload_buf) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	nbytes = ksmbd_vfs_read(work, fp, count, &pos, work->aux_payload_buf);
+	if (nbytes < 0) {
+		err = nbytes;
+		goto out;
+	}
+
+	/* read success, prepare response */
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 12;
+	rsp->Remaining = 0;
+	rsp->DataCompactionMode = 0;
+	rsp->DataCompactionMode = 0;
+	rsp->Reserved = 0;
+	rsp->DataLength = cpu_to_le16(nbytes & 0xFFFF);
+	rsp->DataOffset = cpu_to_le16(sizeof(struct smb_com_read_rsp) -
+			sizeof(rsp->hdr.smb_buf_length));
+	rsp->DataLengthHigh = cpu_to_le16(nbytes >> 16);
+	rsp->Reserved2 = 0;
+
+	rsp->ByteCount = cpu_to_le16(nbytes);
+	inc_rfc1001_len(&rsp->hdr, (rsp->hdr.WordCount * 2));
+	work->resp_hdr_sz = get_rfc1002_len(rsp) + 4;
+	work->aux_payload_sz = nbytes;
+	inc_rfc1001_len(&rsp->hdr, nbytes);
+
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(&rsp->hdr));
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		ksmbd_fd_put(work, fp);
+		return rsp->AndXCommand; /* More processing required */
+	}
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+
+out:
+	ksmbd_fd_put(work, fp);
+	if (err)
+		rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+	return err;
+}
+
+/**
+ * smb_write() - write request handler
+ * @work:	smb work containing write command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_write(struct ksmbd_work *work)
+{
+	struct smb_com_write_req_32bit *req = work->request_buf;
+	struct smb_com_write_rsp_32bit *rsp = work->response_buf;
+	struct ksmbd_file *fp = NULL;
+	loff_t pos;
+	size_t count;
+	char *data_buf;
+	ssize_t nbytes = 0;
+	int err = 0;
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		ksmbd_debug(SMB,
+			"returning as user does not have permission to write\n");
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		return -EACCES;
+	}
+
+	fp = ksmbd_lookup_fd_fast(work, req->Fid);
+	if (!fp) {
+		pr_err("failed to get filp for fid %u\n", req->Fid);
+		rsp->hdr.Status.CifsError = STATUS_FILE_CLOSED;
+		return -ENOENT;
+	}
+
+	pos = le32_to_cpu(req->Offset);
+	count = le16_to_cpu(req->Length);
+	data_buf = req->Data;
+
+	ksmbd_debug(SMB, "filename %pd, offset %lld, count %zu\n",
+		    fp->filp->f_path.dentry, pos, count);
+	if (!count) {
+		err = ksmbd_vfs_truncate(work, fp, pos);
+		nbytes = 0;
+	} else
+		err = ksmbd_vfs_write(work, fp, data_buf,
+				      count, &pos, 0, &nbytes);
+
+	rsp->hdr.WordCount = 1;
+	rsp->Written = cpu_to_le16(nbytes & 0xFFFF);
+	rsp->ByteCount = 0;
+	inc_rfc1001_len(&rsp->hdr, (rsp->hdr.WordCount * 2));
+
+	ksmbd_fd_put(work, fp);
+	if (!err) {
+		rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+		return 0;
+	}
+
+	if (err == -ENOSPC || err == -EFBIG)
+		rsp->hdr.Status.CifsError = STATUS_DISK_FULL;
+	else
+		rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+	return err;
+}
+
+/**
+ * smb_write_andx_pipe() - write on pipe request handler
+ * @work:	smb work containing write command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_write_andx_pipe(struct ksmbd_work *work)
+{
+	struct smb_com_write_req *req = work->request_buf;
+	struct smb_com_write_rsp *rsp = work->response_buf;
+	struct ksmbd_rpc_command *rpc_resp;
+	int ret = 0;
+	size_t count = 0;
+
+	count = le16_to_cpu(req->DataLengthLow);
+	if (work->conn->vals->capabilities & CAP_LARGE_WRITE_X)
+		count |= (le16_to_cpu(req->DataLengthHigh) << 16);
+
+	rpc_resp = ksmbd_rpc_write(work->sess, req->Fid, req->Data, count);
+	if (rpc_resp) {
+		if (rpc_resp->flags == KSMBD_RPC_ENOTIMPLEMENTED) {
+			rsp->hdr.Status.CifsError = STATUS_NOT_SUPPORTED;
+			kvfree(rpc_resp);
+			return -EOPNOTSUPP;
+		}
+		if (rpc_resp->flags != KSMBD_RPC_OK) {
+			rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+			kvfree(rpc_resp);
+			return -EINVAL;
+		}
+		count = rpc_resp->payload_sz;
+		kvfree(rpc_resp);
+	} else {
+		ret = -EINVAL;
+	}
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 6;
+	rsp->Count = cpu_to_le16(count & 0xFFFF);
+	rsp->Remaining = 0;
+	rsp->CountHigh = cpu_to_le16(count >> 16);
+	rsp->Reserved = 0;
+	rsp->ByteCount = 0;
+	inc_rfc1001_len(&rsp->hdr, (rsp->hdr.WordCount * 2));
+
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(&rsp->hdr));
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		return rsp->AndXCommand; /* More processing required */
+	}
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+
+	return ret;
+}
+
+/**
+ * smb_write_andx() - andx write request handler
+ * @work:	smb work containing write command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_write_andx(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+	struct smb_com_write_req *req = work->request_buf;
+	struct smb_com_write_rsp *rsp = work->response_buf;
+	struct ksmbd_file *fp;
+	bool writethrough = false;
+	loff_t pos;
+	size_t count;
+	ssize_t nbytes = 0;
+	char *data_buf;
+	int err = 0;
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		ksmbd_debug(SMB,
+			"returning as user does not have permission to write\n");
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		return -EACCES;
+	}
+
+	if (test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_PIPE)) {
+		ksmbd_debug(SMB, "Write ANDX called for IPC$");
+		return smb_write_andx_pipe(work);
+	}
+
+	fp = ksmbd_lookup_fd_fast(work, req->Fid);
+	if (!fp) {
+		pr_err("failed to get filp for fid %u\n", req->Fid);
+		rsp->hdr.Status.CifsError = STATUS_FILE_CLOSED;
+		return -ENOENT;
+	}
+
+	pos = le32_to_cpu(req->OffsetLow);
+	if (req->hdr.WordCount == 14)
+		pos |= ((loff_t)le32_to_cpu(req->OffsetHigh) << 32);
+
+	writethrough = (le16_to_cpu(req->WriteMode) == 1);
+
+	/*
+	 * [MS-SMB] 3.3.5.8:
+	 * If CAP_LARGE_WRITEX is set in Server.Connection.ClientCapabilities,
+	 * then it is possible that the count of bytes to be written is larger
+	 * than the server's MaxBufferSize
+	 */
+	count = le16_to_cpu(req->DataLengthLow);
+	if (conn->vals->capabilities & CAP_LARGE_WRITE_X)
+		count |= (le16_to_cpu(req->DataLengthHigh) << 16);
+	else if (count > CIFS_DEFAULT_IOSIZE) {
+		ksmbd_debug(SMB, "write size(%zu) exceeds max size(%u)\n",
+				count, CIFS_DEFAULT_IOSIZE);
+		ksmbd_debug(SMB, "limiting write size to max size(%u)\n",
+				CIFS_DEFAULT_IOSIZE);
+		count = CIFS_DEFAULT_IOSIZE;
+	}
+
+	if (le16_to_cpu(req->DataOffset) ==
+			(offsetof(struct smb_com_write_req, Data) - 4)) {
+		data_buf = (char *)&req->Data[0];
+	} else {
+		if ((le16_to_cpu(req->DataOffset) > get_rfc1002_len(req)) ||
+				(le16_to_cpu(req->DataOffset) +
+				 count > get_rfc1002_len(req))) {
+			pr_err("invalid write data offset %u, smb_len %u\n",
+			       le16_to_cpu(req->DataOffset),
+			       get_rfc1002_len(req));
+			err = -EINVAL;
+			goto out;
+		}
+
+		data_buf = (char *)(((char *)&req->hdr.Protocol) +
+				le16_to_cpu(req->DataOffset));
+	}
+
+	ksmbd_debug(SMB, "filename %pd, offset %lld, count %zu\n",
+		    fp->filp->f_path.dentry, pos, count);
+	err = ksmbd_vfs_write(work, fp, data_buf, count, &pos,
+			      writethrough, &nbytes);
+	if (err < 0)
+		goto out;
+
+	/* write success, prepare response */
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 6;
+	rsp->Count = cpu_to_le16(nbytes & 0xFFFF);
+	rsp->Remaining = 0;
+	rsp->CountHigh = cpu_to_le16(nbytes >> 16);
+	rsp->Reserved = 0;
+	rsp->ByteCount = 0;
+	inc_rfc1001_len(&rsp->hdr, (rsp->hdr.WordCount * 2));
+
+	ksmbd_fd_put(work, fp);
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(&rsp->hdr));
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		return rsp->AndXCommand; /* More processing required */
+	}
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+
+	return 0;
+
+out:
+	ksmbd_fd_put(work, fp);
+	if (err == -ENOSPC || err == -EFBIG)
+		rsp->hdr.Status.CifsError = STATUS_DISK_FULL;
+	else
+		rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+	return err;
+}
+
+/**
+ * smb_echo() - echo(ping) request handler
+ * @work:	smb work containing echo command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_echo(struct ksmbd_work *work)
+{
+	struct smb_com_echo_req *req = work->request_buf;
+	struct smb_com_echo_rsp *rsp = work->response_buf;
+	__u16 data_count, echo_count;
+	int i;
+
+	echo_count = le16_to_cpu(req->EchoCount);
+
+	ksmbd_debug(SMB, "SMB_COM_ECHO called with echo count %u\n",
+		    echo_count);
+
+	if (!echo_count) {
+		work->send_no_response = true;
+		return 0;
+	}
+
+	/* don't let a client make us work too much */
+	if (echo_count > 10)
+		echo_count = 10;
+
+	data_count = le16_to_cpu(req->ByteCount);
+	/* send echo response to server */
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 1;
+	rsp->ByteCount = cpu_to_le16(data_count);
+
+	memcpy(rsp->Data, req->Data, data_count);
+	inc_rfc1001_len(&rsp->hdr, (rsp->hdr.WordCount * 2) + data_count);
+
+	/* Send req->EchoCount - 1 number of ECHO response now &
+	 * if SMB CANCEL for Echo comes don't send response
+	 */
+	for (i = 1; i < echo_count && !work->send_no_response; i++) {
+		rsp->SequenceNumber = cpu_to_le16(i);
+		ksmbd_conn_write(work);
+	}
+
+	/* Last echo response */
+	rsp->SequenceNumber = cpu_to_le16(i);
+
+	return 0;
+}
+
+/**
+ * smb_flush() - file sync - flush request handler
+ * @work:	smb work containing flush command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_flush(struct ksmbd_work *work)
+{
+	struct smb_com_flush_req *req = work->request_buf;
+	struct smb_com_flush_rsp *rsp = work->response_buf;
+	int err = 0;
+
+	ksmbd_debug(SMB, "SMB_COM_FLUSH called for fid %u\n", req->FileID);
+
+	if (req->FileID == 0xFFFF) {
+		err = ksmbd_file_table_flush(work);
+		if (err)
+			goto out;
+	} else {
+		err = ksmbd_vfs_fsync(work, req->FileID, KSMBD_NO_FID);
+		if (err)
+			goto out;
+	}
+
+	/* file fsync success, return response to server */
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 0;
+	rsp->ByteCount = 0;
+	return err;
+
+out:
+	if (err)
+		rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+
+	return err;
+}
+
+/*****************************************************************************
+ * TRANS2 command implementation functions
+ *****************************************************************************/
+
+/**
+ * get_filetype() - convert file mode to smb file type
+ * @mode:	file mode to be convertd
+ *
+ * Return:	converted file type
+ */
+static __u32 get_filetype(mode_t mode)
+{
+	if (S_ISREG(mode))
+		return UNIX_FILE;
+	else if (S_ISDIR(mode))
+		return UNIX_DIR;
+	else if (S_ISLNK(mode))
+		return UNIX_SYMLINK;
+	else if (S_ISCHR(mode))
+		return UNIX_CHARDEV;
+	else if (S_ISBLK(mode))
+		return UNIX_BLOCKDEV;
+	else if (S_ISFIFO(mode))
+		return UNIX_FIFO;
+	else if (S_ISSOCK(mode))
+		return UNIX_SOCKET;
+
+	return UNIX_UNKNOWN;
+}
+
+/**
+ * init_unix_info() - convert file stat information to smb file info format
+ * @unix_info:	smb file information format
+ * @stat:	unix file/dir stat information
+ */
+static void init_unix_info(struct file_unix_basic_info *unix_info,
+			   struct user_namespace *user_ns, struct kstat *stat)
+{
+	u64 time;
+
+	unix_info->EndOfFile = cpu_to_le64(stat->size);
+	unix_info->NumOfBytes = cpu_to_le64(512 * stat->blocks);
+	time = ksmbd_UnixTimeToNT(stat->ctime);
+	unix_info->LastStatusChange = cpu_to_le64(time);
+	time = ksmbd_UnixTimeToNT(stat->atime);
+	unix_info->LastAccessTime = cpu_to_le64(time);
+	time = ksmbd_UnixTimeToNT(stat->mtime);
+	unix_info->LastModificationTime = cpu_to_le64(time);
+	unix_info->Uid = cpu_to_le64(from_kuid(user_ns, stat->uid));
+	unix_info->Gid = cpu_to_le64(from_kgid(user_ns, stat->gid));
+	unix_info->Type = cpu_to_le32(get_filetype(stat->mode));
+	unix_info->DevMajor = cpu_to_le64(MAJOR(stat->rdev));
+	unix_info->DevMinor = cpu_to_le64(MINOR(stat->rdev));
+	unix_info->UniqueId = cpu_to_le64(stat->ino);
+	unix_info->Permissions = cpu_to_le64(stat->mode);
+	unix_info->Nlinks = cpu_to_le64(stat->nlink);
+}
+
+/**
+ * unix_info_to_attr() - convert smb file info format to unix attr format
+ * @unix_info:	smb file information format
+ * @attrs:	unix file/dir stat information
+ *
+ * Return:	0
+ */
+static int unix_info_to_attr(struct file_unix_basic_info *unix_info,
+			     struct user_namespace *user_ns,
+			     struct iattr *attrs)
+{
+	struct timespec64 ts;
+
+	if (le64_to_cpu(unix_info->EndOfFile) != NO_CHANGE_64) {
+		attrs->ia_size = le64_to_cpu(unix_info->EndOfFile);
+		attrs->ia_valid |= ATTR_SIZE;
+	}
+
+	if (le64_to_cpu(unix_info->LastStatusChange) != NO_CHANGE_64) {
+		ts = smb_NTtimeToUnix(unix_info->LastStatusChange);
+		attrs->ia_ctime = ts;
+		attrs->ia_valid |= ATTR_CTIME;
+	}
+
+	if (le64_to_cpu(unix_info->LastAccessTime) != NO_CHANGE_64) {
+		ts = smb_NTtimeToUnix(unix_info->LastAccessTime);
+		attrs->ia_atime = ts;
+		attrs->ia_valid |= ATTR_ATIME;
+	}
+
+	if (le64_to_cpu(unix_info->LastModificationTime) != NO_CHANGE_64) {
+		ts = smb_NTtimeToUnix(unix_info->LastModificationTime);
+		attrs->ia_mtime = ts;
+		attrs->ia_valid |= ATTR_MTIME;
+	}
+
+	if (le64_to_cpu(unix_info->Uid) != NO_CHANGE_64) {
+		attrs->ia_uid = make_kuid(user_ns, le64_to_cpu(unix_info->Uid));
+		attrs->ia_valid |= ATTR_UID;
+	}
+
+	if (le64_to_cpu(unix_info->Gid) != NO_CHANGE_64) {
+		attrs->ia_gid = make_kgid(user_ns, le64_to_cpu(unix_info->Gid));
+		attrs->ia_valid |= ATTR_GID;
+	}
+
+	if (le64_to_cpu(unix_info->Permissions) != NO_CHANGE_64) {
+		attrs->ia_mode = le64_to_cpu(unix_info->Permissions);
+		attrs->ia_valid |= ATTR_MODE;
+	}
+
+	switch (le32_to_cpu(unix_info->Type)) {
+	case UNIX_FILE:
+		attrs->ia_mode |= S_IFREG;
+		break;
+	case UNIX_DIR:
+		attrs->ia_mode |= S_IFDIR;
+		break;
+	case UNIX_SYMLINK:
+		attrs->ia_mode |= S_IFLNK;
+		break;
+	case UNIX_CHARDEV:
+		attrs->ia_mode |= S_IFCHR;
+		break;
+	case UNIX_BLOCKDEV:
+		attrs->ia_mode |= S_IFBLK;
+		break;
+	case UNIX_FIFO:
+		attrs->ia_mode |= S_IFIFO;
+		break;
+	case UNIX_SOCKET:
+		attrs->ia_mode |= S_IFSOCK;
+		break;
+	default:
+		pr_err("unknown file type 0x%x\n",
+		       le32_to_cpu(unix_info->Type));
+	}
+
+	return 0;
+}
+
+/**
+ * unix_to_dos_time() - convert unix time to dos format
+ * @ts:		unix style time
+ * @time:	store dos style time
+ * @date:	store dos style date
+ */
+static void unix_to_dos_time(struct timespec64 ts, __le16 *time, __le16 *date)
+{
+	struct tm t;
+	__u16 val;
+
+	time64_to_tm(ts.tv_sec, (-sys_tz.tz_minuteswest) * 60, &t);
+	val = (((unsigned int)(t.tm_mon + 1)) >> 3) | ((t.tm_year - 80) << 1);
+	val = ((val & 0xFF) << 8) | (t.tm_mday | (((t.tm_mon + 1) & 0x7) << 5));
+	*date = cpu_to_le16(val);
+
+	val = ((((unsigned int)t.tm_min >> 3) & 0x7) |
+	       (((unsigned int)t.tm_hour) << 3));
+	val = ((val & 0xFF) << 8) | ((t.tm_sec / 2) | ((t.tm_min & 0x7) << 5));
+	*time = cpu_to_le16(val);
+}
+
+/**
+ * cifs_convert_ace() - helper function for convert an Access Control Entry
+ *		from cifs wire format to local POSIX xattr format
+ * @ace:	local - unix style Access Control Entry format
+ * @cifs_ace:	cifs wire Access Control Entry format
+ */
+static void cifs_convert_ace(struct posix_acl_xattr_entry *ace,
+			     struct cifs_posix_ace *cifs_ace)
+{
+	/* u8 cifs fields do not need le conversion */
+	ace->e_perm = cpu_to_le16(cifs_ace->cifs_e_perm);
+	ace->e_tag = cpu_to_le16(cifs_ace->cifs_e_tag);
+	ace->e_id = cpu_to_le32(le64_to_cpu(cifs_ace->cifs_uid));
+}
+
+/**
+ * cifs_copy_posix_acl() - Convert ACL from CIFS POSIX wire format to local
+ *		Linux POSIX ACL xattr
+ * @trgt:	target buffer for storing in local ace format
+ * @src:	source buffer in cifs ace format
+ * @buflen:	target buffer length
+ * @acl_type:	ace type
+ * @size_of_data_area:	max buffer size to store ace xattr
+ *
+ * Return:	size of convert ace xattr on success, otherwise error
+ */
+static int cifs_copy_posix_acl(char *trgt, char *src, const int buflen,
+			       const int acl_type, const int size_of_data_area)
+{
+	int size = 0;
+	int i;
+	__u16 count;
+	struct cifs_posix_ace *pACE;
+	struct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)src;
+	struct posix_acl_xattr_entry *ace;
+	struct posix_acl_xattr_header *local_acl = (void *)trgt;
+
+	if (le16_to_cpu(cifs_acl->version) != CIFS_ACL_VERSION)
+		return -EOPNOTSUPP;
+
+	if (acl_type & ACL_TYPE_ACCESS) {
+		count = le16_to_cpu(cifs_acl->access_entry_count);
+		pACE = &cifs_acl->ace_array[0];
+		size = sizeof(struct cifs_posix_acl);
+		size += sizeof(struct cifs_posix_ace) * count;
+		/* check if we would go beyond end of SMB */
+		if (size_of_data_area < size) {
+			ksmbd_debug(SMB, "bad CIFS POSIX ACL size %d vs. %d\n",
+				    size_of_data_area, size);
+			return -EINVAL;
+		}
+	} else if (acl_type & ACL_TYPE_DEFAULT) {
+		count = le16_to_cpu(cifs_acl->default_entry_count);
+		pACE = &cifs_acl->ace_array[0];
+		size = sizeof(struct cifs_posix_acl);
+		size += sizeof(struct cifs_posix_ace) * count;
+		/* check if we would go beyond end of SMB */
+		if (size_of_data_area < size)
+			return -EINVAL;
+	} else {
+		/* illegal type */
+		return -EINVAL;
+	}
+
+	size = posix_acl_xattr_size(count);
+	if ((buflen != 0) && local_acl && size > buflen)
+		return -ERANGE;
+
+	/* buffer big enough */
+	ace = (void *)(local_acl + 1);
+	local_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);
+	for (i = 0; i < count; i++) {
+		cifs_convert_ace(&ace[i], pACE);
+		pACE++;
+	}
+
+	return size;
+}
+
+/**
+ * convert_ace_to_cifs_ace() - helper function to convert ACL from local
+ * Linux POSIX ACL xattr to CIFS POSIX wire format to local
+ * @cifs_ace:	target buffer for storing in cifs ace format
+ * @local_ace:	source buffer in Linux POSIX ACL xattr format
+ *
+ * Return:	0
+ */
+static __u16 convert_ace_to_cifs_ace(struct cifs_posix_ace *cifs_ace,
+		const struct posix_acl_xattr_entry *local_ace)
+{
+	__u16 rc = 0; /* 0 = ACL converted ok */
+
+	cifs_ace->cifs_e_perm = le16_to_cpu(local_ace->e_perm);
+	cifs_ace->cifs_e_tag = le16_to_cpu(local_ace->e_tag);
+	/* BB is there a better way to handle the large uid? */
+	if (local_ace->e_id == cpu_to_le32(-1)) {
+		/* Probably no need to le convert -1 on any
+		 * arch but can not hurt
+		 */
+		cifs_ace->cifs_uid = cpu_to_le64(-1);
+	} else
+		cifs_ace->cifs_uid = cpu_to_le64(le32_to_cpu(local_ace->e_id));
+	return rc;
+}
+
+/**
+ * ACL_to_cifs_posix() - ACL from local Linux POSIX xattr to CIFS POSIX ACL
+ *		wire format
+ * @parm_data:	target buffer for storing in cifs ace format
+ * @pACL:	source buffer in cifs ace format
+ * @buflen:	target buffer length
+ * @acl_type:	ace type
+ *
+ * Return:	0 on success, otherwise error
+ */
+static __u16 ACL_to_cifs_posix(char *parm_data, const char *pACL,
+			       const int buflen, const int acl_type)
+{
+	__u16 rc = 0;
+	struct cifs_posix_acl *cifs_acl = (struct cifs_posix_acl *)parm_data;
+	struct posix_acl_xattr_header *local_acl = (void *)pACL;
+	struct posix_acl_xattr_entry *ace = (void *)(local_acl + 1);
+	int count;
+	int i, j = 0;
+
+	if ((buflen == 0) || !pACL || !cifs_acl)
+		return 0;
+
+	count = posix_acl_xattr_count((size_t)buflen);
+	ksmbd_debug(SMB, "setting acl with %d entries from buf of length %d and version of %d\n",
+		 count, buflen, le32_to_cpu(local_acl->a_version));
+	if (le32_to_cpu(local_acl->a_version) != 2) {
+		ksmbd_debug(SMB, "unknown POSIX ACL version %d\n",
+			    le32_to_cpu(local_acl->a_version));
+		return 0;
+	}
+	if (acl_type == ACL_TYPE_ACCESS) {
+		cifs_acl->access_entry_count = cpu_to_le16(count);
+		j = 0;
+	} else if (acl_type == ACL_TYPE_DEFAULT) {
+		cifs_acl->default_entry_count = cpu_to_le16(count);
+		if (cifs_acl->access_entry_count)
+			j = le16_to_cpu(cifs_acl->access_entry_count);
+	} else {
+		ksmbd_debug(SMB, "unknown ACL type %d\n", acl_type);
+		return 0;
+	}
+	for (i = 0; i < count; i++, j++) {
+		rc = convert_ace_to_cifs_ace(&cifs_acl->ace_array[i], &ace[i]);
+		if (rc != 0) {
+			/* ACE not converted */
+			break;
+		}
+	}
+	if (rc == 0) {
+		rc = (__u16)(count * sizeof(struct cifs_posix_ace));
+		/* BB add check to make sure ACL does not overflow SMB */
+	}
+	return rc;
+}
+
+/**
+ * smb_get_acl() - handler for query posix acl information
+ * @work:	smb work containing posix acl query command
+ * @path:	path of file/dir to query acl
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_get_acl(struct ksmbd_work *work, struct path *path)
+{
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	char *buf = NULL;
+	int rc = 0, value_len;
+	struct cifs_posix_acl *aclbuf;
+	__u16 rsp_data_cnt = 0;
+
+	aclbuf = (struct cifs_posix_acl *)(work->response_buf +
+			sizeof(struct smb_com_trans2_rsp) + 4);
+
+	aclbuf->version = cpu_to_le16(CIFS_ACL_VERSION);
+	aclbuf->default_entry_count = 0;
+	aclbuf->access_entry_count = 0;
+
+	/* check if POSIX_ACL_XATTR_ACCESS exists */
+	value_len = compat_ksmbd_vfs_getxattr(path, path->dentry,
+					      XATTR_NAME_POSIX_ACL_ACCESS,
+					      &buf);
+	if (value_len > 0) {
+		rsp_data_cnt += ACL_to_cifs_posix((char *)aclbuf, buf,
+				value_len, ACL_TYPE_ACCESS);
+		kfree(buf);
+		buf = NULL;
+	}
+
+	value_len = compat_ksmbd_vfs_getxattr(path, path->dentry,
+					      XATTR_NAME_POSIX_ACL_DEFAULT,
+					      &buf);
+	if (value_len > 0) {
+		rsp_data_cnt += ACL_to_cifs_posix((char *)aclbuf, buf,
+						  value_len, ACL_TYPE_DEFAULT);
+		kfree(buf);
+		buf = NULL;
+	}
+
+	if (rsp_data_cnt)
+		rsp_data_cnt += sizeof(struct cifs_posix_acl);
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = cpu_to_le16(rsp_data_cnt);
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = cpu_to_le16(2);
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = cpu_to_le16(60);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+	rsp->ByteCount = cpu_to_le16(rsp_data_cnt + 5);
+	inc_rfc1001_len(&rsp->hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+
+	if (buf)
+		kfree(buf);
+	return rc;
+}
+
+/**
+ * smb_set_acl() - handler for setting posix acl information
+ * @work:	smb work containing posix acl set command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_acl(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct cifs_posix_acl *wire_acl_data;
+	char *fname, *buf = NULL;
+	int rc = 0, acl_type = 0, value_len;
+
+	fname = smb_get_name(share, req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(fname)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(fname);
+	}
+
+	buf = vmalloc(XATTR_SIZE_MAX);
+	if (!buf) {
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	wire_acl_data = (struct cifs_posix_acl *)(((char *) &req->hdr.Protocol)
+			+ le16_to_cpu(req->DataOffset));
+	if (le16_to_cpu(wire_acl_data->access_entry_count) > 0 &&
+	    le16_to_cpu(wire_acl_data->access_entry_count) < 0xFFFF) {
+		acl_type = ACL_TYPE_ACCESS;
+
+	} else if (le16_to_cpu(wire_acl_data->default_entry_count) > 0 &&
+		   le16_to_cpu(wire_acl_data->default_entry_count) < 0xFFFF) {
+		acl_type = ACL_TYPE_DEFAULT;
+	} else {
+		rc = -EINVAL;
+		goto out;
+	}
+
+	rc = cifs_copy_posix_acl(buf, (char *)wire_acl_data, XATTR_SIZE_MAX,
+				 acl_type, XATTR_SIZE_MAX);
+	if (rc < 0) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+
+	value_len = rc;
+	if (acl_type == ACL_TYPE_ACCESS) {
+		rc = ksmbd_vfs_fsetxattr(work,
+					 fname,
+					 XATTR_NAME_POSIX_ACL_ACCESS,
+					 buf, value_len, 0);
+	} else if (acl_type == ACL_TYPE_DEFAULT) {
+		rc = ksmbd_vfs_fsetxattr(work,
+					 fname,
+					 XATTR_NAME_POSIX_ACL_DEFAULT,
+					 buf, value_len, 0);
+	}
+
+	if (rc < 0) {
+		rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+		goto out;
+	}
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = cpu_to_le16(0);
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = cpu_to_le16(2);
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = cpu_to_le16(0);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 2 for parameter count + 1 pad1*/
+	rsp->ByteCount = cpu_to_le16(3);
+	rsp->Pad = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+
+out:
+	if (buf)
+		vfree(buf);
+	kfree(fname);
+	return rc;
+}
+
+static void *ksmbd_realloc_response(void *ptr, size_t old_sz, size_t new_sz)
+{
+	size_t sz = min(old_sz, new_sz);
+	void *nptr;
+
+	nptr = kvmalloc(new_sz, GFP_KERNEL | __GFP_ZERO);
+	if (!nptr)
+		return ptr;
+	memcpy(nptr, ptr, sz);
+	kvfree(ptr);
+	return nptr;
+}
+
+/**
+ * smb_readlink() - handler for reading symlink source path
+ * @work:	smb work containing query link information
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_readlink(struct ksmbd_work *work, struct path *path)
+{
+	struct smb_com_trans2_qpi_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	int err, name_len, link_len;
+	char *buf, *ptr;
+
+	buf = kzalloc((CIFS_MF_SYMLINK_LINK_MAXLEN), GFP_KERNEL);
+	if (!buf) {
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		return -ENOMEM;
+	}
+
+	err = ksmbd_vfs_readlink(path, buf, CIFS_MF_SYMLINK_LINK_MAXLEN);
+	if (err < 0) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+		goto out;
+	}
+
+	/*
+	 * check if this namelen(unicode) and smb header can fit in small rsp
+	 * buf. If not, switch to large rsp buffer.
+	 */
+	err++;
+	err *= 2;
+	if (err + MAX_HEADER_SIZE(work->conn) > work->response_sz) {
+		void *nptr;
+		size_t nsz = err + MAX_HEADER_SIZE(work->conn);
+
+		nptr = ksmbd_realloc_response(work->response_buf,
+					      work->response_sz,
+					      nsz);
+		if (nptr == work->response_buf) {
+			rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+			err = -ENOMEM;
+			goto out;
+		}
+
+		work->response_buf = nptr;
+		rsp = (struct smb_com_trans2_rsp *)work->response_buf;
+	}
+	link_len = err;
+	err = 0;
+
+	ptr = (char *)&rsp->Buffer[0];
+	memset(ptr, 0, 4);
+	ptr += 4;
+
+	if (is_smbreq_unicode(&req->hdr)) {
+		name_len = smb_strtoUTF16((__le16 *)ptr,
+					  buf,
+					  link_len,
+					  work->conn->local_nls);
+		name_len++;     /* trailing null */
+		name_len *= 2;
+	} else { /* BB add path length overrun check */
+		name_len = strscpy(ptr, buf, link_len);
+		if (name_len == -E2BIG) {
+			err = -ENOMEM;
+			rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+			goto out;
+		}
+		name_len++;     /* trailing null */
+	}
+
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = cpu_to_le16(name_len);
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = cpu_to_le16(2);
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = cpu_to_le16(60);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+	rsp->ByteCount = cpu_to_le16(name_len + 5);
+	inc_rfc1001_len(&rsp->hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+
+out:
+	kfree(buf);
+	return err;
+}
+
+/**
+ * smb_get_ea() - handler for extended attribute query
+ * @work:	smb work containing query xattr command
+ * @path:	path of file/dir to query xattr command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_get_ea(struct ksmbd_work *work, struct path *path)
+{
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	char *name, *ptr, *xattr_list = NULL, *buf;
+	int rc, name_len, value_len, xattr_list_len;
+	struct fealist *eabuf = (struct fealist *)(work->response_buf +
+			sizeof(struct smb_com_trans2_rsp) + 4);
+	struct fea *temp_fea;
+	ssize_t buf_free_len;
+	__u16 rsp_data_cnt = 4;
+
+	eabuf->list_len = cpu_to_le32(rsp_data_cnt);
+	buf_free_len = work->response_sz - (get_rfc1002_len(rsp) + 4) -
+		sizeof(struct smb_com_trans2_rsp);
+	rc = ksmbd_vfs_listxattr(path->dentry, &xattr_list);
+	if (rc < 0) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+		goto out;
+	} else if (!rc) { /* there is no EA in the file */
+		eabuf->list_len = cpu_to_le32(rsp_data_cnt);
+		goto done;
+	}
+
+	xattr_list_len = rc;
+	rc = 0;
+
+	ptr = (char *)eabuf->list;
+	temp_fea = (struct fea *)ptr;
+	for (name = xattr_list; name - xattr_list < xattr_list_len;
+	     name += strlen(name) + 1) {
+		ksmbd_debug(SMB, "%s, len %zd\n", name, strlen(name));
+		/*
+		 * CIFS does not support EA other name user.* namespace,
+		 * still keep the framework generic, to list other attrs
+		 * in future.
+		 */
+		if (strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))
+			continue;
+
+		name_len = strlen(name);
+		if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))
+			name_len -= XATTR_USER_PREFIX_LEN;
+
+		ptr = (char *)(&temp_fea->name + name_len + 1);
+		buf_free_len -= (offsetof(struct fea, name) + name_len + 1);
+
+		value_len = compat_ksmbd_vfs_getxattr(path, path->dentry,
+						      name, &buf);
+		if (value_len <= 0) {
+			rc = -ENOENT;
+			rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+			goto out;
+		}
+
+		memcpy(ptr, buf, value_len);
+		kfree(buf);
+
+		temp_fea->EA_flags = 0;
+		temp_fea->name_len = name_len;
+		if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))
+			memcpy(temp_fea->name, &name[XATTR_USER_PREFIX_LEN],
+			       name_len);
+		else
+			memcpy(temp_fea->name, name, name_len);
+
+		temp_fea->value_len = cpu_to_le16(value_len);
+		buf_free_len -= value_len;
+		rsp_data_cnt += offsetof(struct fea, name) + name_len + 1 +
+			value_len;
+		eabuf->list_len += cpu_to_le32(offsetof(struct fea, name) +
+				name_len + 1 + value_len);
+		ptr += value_len;
+		temp_fea = (struct fea *)ptr;
+	}
+
+done:
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = cpu_to_le16(rsp_data_cnt);
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = cpu_to_le16(2);
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = cpu_to_le16(60);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+	rsp->ByteCount = cpu_to_le16(rsp_data_cnt + 5);
+	inc_rfc1001_len(&rsp->hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+out:
+	kvfree(xattr_list);
+	return rc;
+}
+
+/**
+ * query_path_info() - handler for query path info
+ * @work:	smb work containing query path info command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int query_path_info(struct ksmbd_work *work)
+{
+	struct smb_hdr *rsp_hdr = work->response_buf;
+	struct smb_com_trans2_req *req = work->request_buf;
+	struct ksmbd_conn *conn = work->conn;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct trans2_qpi_req_params *req_params;
+	char *name = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	struct path path, parent_path;
+#else
+	struct path path;
+#endif
+	struct kstat st;
+	int rc;
+	char *ptr;
+	__u64 create_time = 0, time;
+
+	if (test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_PIPE)) {
+		rsp_hdr->Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+		return 0;
+	}
+
+	req_params = (struct trans2_qpi_req_params *)(work->request_buf +
+		     le16_to_cpu(req->ParameterOffset) + 4);
+	name = smb_get_name(share, req_params->FileName, PATH_MAX, work,
+		false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+
+	if (ksmbd_override_fsids(work)) {
+		kfree(name);
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		return -ENOMEM;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	rc = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					&parent_path, &path, 0);
+#else
+	rc = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, 0);
+#endif
+	if (rc) {
+		if (rc == -EACCES || rc == -EXDEV)
+			rsp_hdr->Status.CifsError = STATUS_ACCESS_DENIED;
+		else
+			rsp_hdr->Status.CifsError =
+					STATUS_OBJECT_NAME_NOT_FOUND;
+		ksmbd_debug(SMB, "cannot get linux path for %s, err %d\n",
+				name, rc);
+		goto out;
+	}
+
+	if (d_is_symlink(path.dentry)) {
+		rsp_hdr->Status.CifsError = STATUS_ACCESS_DENIED;
+		goto err_out;
+	}
+
+	rc = vfs_getattr(&path, &st, STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);
+	if (rc) {
+		pr_err("cannot get stat information\n");
+		goto err_out;
+	}
+
+	if (test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
+		struct xattr_dos_attrib da;
+
+		rc = compat_ksmbd_vfs_get_dos_attrib_xattr(&path,
+							   path.dentry, &da);
+		if (rc > 0)
+			create_time = da.create_time;
+		rc = 0;
+	}
+
+	switch (le16_to_cpu(req_params->InformationLevel)) {
+	case SMB_INFO_STANDARD:
+	{
+		struct file_info_standard *infos;
+
+		ksmbd_debug(SMB, "SMB_INFO_STANDARD\n");
+		rc = ksmbd_query_inode_status(path.dentry);
+		if (rc == KSMBD_INODE_STATUS_PENDING_DELETE) {
+			rc = -EBUSY;
+			goto err_out;
+		}
+
+		rc = 0;
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		infos = (struct file_info_standard *)(ptr + 4);
+		unix_to_dos_time(ksmbd_NTtimeToUnix(cpu_to_le64(create_time)),
+				 &infos->CreationDate, &infos->CreationTime);
+		unix_to_dos_time(st.atime, &infos->LastAccessDate,
+				 &infos->LastAccessTime);
+		unix_to_dos_time(st.mtime, &infos->LastWriteDate,
+				 &infos->LastWriteTime);
+		infos->DataSize = cpu_to_le32(st.size);
+		infos->AllocationSize = cpu_to_le32(st.blocks << 9);
+		infos->Attributes = cpu_to_le16(S_ISDIR(st.mode) ?
+					ATTR_DIRECTORY : ATTR_ARCHIVE);
+		infos->EASize = 0;
+
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount = cpu_to_le16(22);
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(22);
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		rsp->ByteCount = cpu_to_le16(27);
+		rsp->Pad = 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_STANDARD_INFO:
+	{
+		struct file_standard_info *standard_info;
+		unsigned int del_pending;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_STANDARD_INFO\n");
+		del_pending = ksmbd_query_inode_status(path.dentry);
+		if (del_pending == KSMBD_INODE_STATUS_PENDING_DELETE)
+			del_pending = 1;
+		else
+			del_pending = 0;
+
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount =
+			cpu_to_le16(sizeof(struct file_standard_info));
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount =
+			cpu_to_le16(sizeof(struct file_standard_info));
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount =
+			cpu_to_le16(2 + sizeof(struct file_standard_info) + 3);
+		rsp->Pad = 0;
+		/* lets set EA info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		standard_info = (struct file_standard_info *)(ptr + 4);
+		standard_info->AllocationSize = cpu_to_le64(st.blocks << 9);
+		standard_info->EndOfFile = cpu_to_le64(st.size);
+		standard_info->NumberOfLinks = cpu_to_le32(get_nlink(&st) -
+			del_pending);
+		standard_info->DeletePending = del_pending;
+		standard_info->Directory = S_ISDIR(st.mode) ? 1 : 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_BASIC_INFO:
+	{
+		struct file_basic_info *basic_info;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_BASIC_INFO\n");
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount =
+			cpu_to_le16(sizeof(struct file_basic_info));
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(sizeof(struct file_basic_info));
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount =
+			cpu_to_le16(2 + sizeof(struct file_basic_info) + 3);
+		rsp->Pad = 0;
+		/* lets set EA info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		basic_info = (struct file_basic_info *)(ptr + 4);
+		basic_info->CreationTime = cpu_to_le64(create_time);
+		time = ksmbd_UnixTimeToNT(st.atime);
+		basic_info->LastAccessTime = cpu_to_le64(time);
+		time = ksmbd_UnixTimeToNT(st.mtime);
+		basic_info->LastWriteTime = cpu_to_le64(time);
+		time = ksmbd_UnixTimeToNT(st.ctime);
+		basic_info->ChangeTime = cpu_to_le64(time);
+		basic_info->Attributes = S_ISDIR(st.mode) ?
+					 ATTR_DIRECTORY_LE : ATTR_ARCHIVE_LE;
+		basic_info->Pad = 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_EA_INFO:
+	{
+		struct file_ea_info *ea_info;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_EA_INFO\n");
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount =
+			cpu_to_le16(sizeof(struct file_ea_info));
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(sizeof(struct file_ea_info));
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount =
+			cpu_to_le16(2 + sizeof(struct file_ea_info) + 3);
+		rsp->Pad = 0;
+		/* lets set EA info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		ea_info = (struct file_ea_info *)(ptr + 4);
+		ea_info->EaSize = 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_NAME_INFO:
+	{
+		struct file_name_info *name_info;
+		int uni_filename_len;
+		char *filename;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_NAME_INFO\n");
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		name_info = (struct file_name_info *)(ptr + 4);
+
+		filename = convert_to_nt_pathname(work->tcon->share_conf, &path);
+		if (!filename) {
+			rc = -ENOMEM;
+			goto err_out;
+		}
+		uni_filename_len = smbConvertToUTF16(
+				(__le16 *)name_info->FileName,
+				filename, PATH_MAX,
+				conn->local_nls, 0);
+		kfree(filename);
+		uni_filename_len *= 2;
+		name_info->FileNameLength = cpu_to_le32(uni_filename_len);
+
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount = cpu_to_le16(uni_filename_len + 4);
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(uni_filename_len + 4);
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount = cpu_to_le16(2 + uni_filename_len + 4 + 3);
+		rsp->Pad = 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_ALL_INFO:
+	{
+		struct file_all_info *ainfo;
+		unsigned int del_pending;
+		char *filename;
+		int uni_filename_len, total_count = 72;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_ALL_INFO\n");
+
+		del_pending = ksmbd_query_inode_status(path.dentry);
+		if (del_pending == KSMBD_INODE_STATUS_PENDING_DELETE)
+			del_pending = 1;
+		else
+			del_pending = 0;
+
+		filename = convert_to_nt_pathname(work->tcon->share_conf, &path);
+		if (!filename) {
+			rc = -ENOMEM;
+			goto err_out;
+		}
+
+		/*
+		 * Observation: sizeof smb_hdr is 33 bytes(including word count)
+		 * After that: trans2 response 22 bytes when stepcount 0 and
+		 * including ByteCount storage.
+		 */
+		/* lets set EA info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		ainfo = (struct file_all_info *) (ptr + 4);
+
+		ainfo->CreationTime = cpu_to_le64(create_time);
+		time = ksmbd_UnixTimeToNT(st.atime);
+		ainfo->LastAccessTime = cpu_to_le64(time);
+		time = ksmbd_UnixTimeToNT(st.mtime);
+		ainfo->LastWriteTime = cpu_to_le64(time);
+		time = ksmbd_UnixTimeToNT(st.ctime);
+		ainfo->ChangeTime = cpu_to_le64(time);
+		ainfo->Attributes = S_ISDIR(st.mode) ?
+					ATTR_DIRECTORY_LE : ATTR_ARCHIVE_LE;
+		ainfo->Pad1 = 0;
+		ainfo->AllocationSize = cpu_to_le64(st.blocks << 9);
+		ainfo->EndOfFile = cpu_to_le64(st.size);
+		ainfo->NumberOfLinks = cpu_to_le32(get_nlink(&st) -
+			del_pending);
+		ainfo->DeletePending = del_pending;
+		ainfo->Directory = S_ISDIR(st.mode) ? 1 : 0;
+		ainfo->Pad2 = 0;
+		ainfo->EASize = 0;
+		uni_filename_len = smbConvertToUTF16(
+				(__le16 *)ainfo->FileName,
+				filename, PATH_MAX,
+				conn->local_nls, 0);
+		kfree(filename);
+		uni_filename_len *= 2;
+		ainfo->FileNameLength = cpu_to_le32(uni_filename_len);
+		total_count += uni_filename_len;
+
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		/* add unicode name length of name */
+		rsp->t2.TotalDataCount = cpu_to_le16(total_count);
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(total_count);
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/* 2 for parameter count + 72 data count +
+		 * filename length + 3 pad (1pad1 + 2 pad2)
+		 */
+		rsp->ByteCount = cpu_to_le16(5 + total_count);
+		rsp->Pad = 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_ALT_NAME_INFO:
+	{
+		struct alt_name_info *alt_name_info;
+		char *base;
+		int filename_len;
+
+		ksmbd_debug(SMB, "SMB_QUERY_ALT_NAME_INFO\n");
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount = cpu_to_le16(25);
+		rsp->Pad = 0;
+		/* lets set EA info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		alt_name_info = (struct alt_name_info *)(ptr + 4);
+
+		base = strrchr(name, '/');
+		if (!base)
+			base = name;
+		else
+			base += 1;
+
+		filename_len = ksmbd_extract_shortname(conn, base,
+						       alt_name_info->FileName);
+		alt_name_info->FileNameLength = cpu_to_le32(filename_len);
+		rsp->t2.TotalDataCount = cpu_to_le16(4 + filename_len);
+		rsp->t2.DataCount = cpu_to_le16(4 + filename_len);
+
+		inc_rfc1001_len(rsp_hdr, (4 + filename_len + 25));
+		break;
+	}
+	case SMB_QUERY_FILE_UNIX_BASIC:
+	{
+		struct file_unix_basic_info *unix_info;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_UNIX_BASIC\n");
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = 0;
+		rsp->t2.TotalDataCount = cpu_to_le16(100);
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = 0;
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(100);
+		rsp->t2.DataOffset = cpu_to_le16(56);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		rsp->ByteCount = cpu_to_le16(101); /* 100 data count + 1pad */
+		rsp->Pad = 0;
+		unix_info = (struct file_unix_basic_info *)(&rsp->Pad + 1);
+		init_unix_info(unix_info, &init_user_ns, &st);
+		inc_rfc1001_len(rsp_hdr, (10 * 2 + 101));
+		break;
+	}
+	case SMB_QUERY_FILE_INTERNAL_INFO:
+	{
+		struct file_internal_info *iinfo;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_INTERNAL_INFO\n");
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount = cpu_to_le16(8);
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(8);
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		rsp->ByteCount = cpu_to_le16(13);
+		rsp->Pad = 0;
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		iinfo = (struct file_internal_info *) (ptr + 4);
+		iinfo->UniqueId = cpu_to_le64(st.ino);
+		inc_rfc1001_len(rsp_hdr, (10 * 2 + 13));
+		break;
+	}
+	case SMB_QUERY_FILE_UNIX_LINK:
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_UNIX_LINK\n");
+		rc = smb_readlink(work, &path);
+		if (rc < 0)
+			goto err_out;
+		break;
+	case SMB_INFO_QUERY_ALL_EAS:
+		ksmbd_debug(SMB, "SMB_INFO_QUERY_ALL_EAS\n");
+		rc = smb_get_ea(work, &path);
+		if (rc < 0)
+			goto err_out;
+		break;
+	case SMB_QUERY_POSIX_ACL:
+		ksmbd_debug(SMB, "SMB_QUERY_POSIX_ACL\n");
+		rc = smb_get_acl(work, &path);
+		if (rc < 0)
+			goto err_out;
+		break;
+	default:
+		pr_err("query path info not implemnted for %x\n",
+		       le16_to_cpu(req_params->InformationLevel));
+		rc = -EINVAL;
+		goto err_out;
+	}
+
+err_out:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	path_put(&path);
+#endif
+out:
+	ksmbd_revert_fsids(work);
+	kfree(name);
+	return rc;
+}
+
+/**
+ * create_trans2_reply() - create response for trans2 request
+ * @work:	smb work containing smb response buffer
+ * @count:	trans2 response buffer size
+ */
+static void create_trans2_reply(struct ksmbd_work *work, __u16 count)
+{
+	struct smb_hdr *rsp_hdr = work->response_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+
+	rsp_hdr->WordCount = 0x0A;
+	rsp->t2.TotalParameterCount = 0;
+	rsp->t2.TotalDataCount = cpu_to_le16(count);
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = 0;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = cpu_to_le16(count);
+	rsp->t2.DataOffset = cpu_to_le16(56);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	rsp->ByteCount = cpu_to_le16(count + 1);
+	rsp->Pad = 0;
+	inc_rfc1001_len(rsp_hdr, 10 * 2 + (count + 1));
+}
+
+/**
+ * set_fs_info() - handler for set fs info commands
+ * @work:	smb work containing set fs info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int set_fs_info(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_setfsi_req *req = work->request_buf;
+	struct smb_com_trans2_setfsi_rsp *rsp = work->response_buf;
+	struct smb_com_trans2_setfsi_req_params *params;
+	int info_level;
+
+	params = (struct smb_com_trans2_setfsi_req_params *)
+		(work->request_buf + le16_to_cpu(req->ParameterOffset) + 4);
+
+	info_level = le16_to_cpu(params->InformationLevel);
+
+	switch (info_level) {
+	case SMB_SET_CIFS_UNIX_INFO:
+	{
+		u64 client_cap;
+
+		ksmbd_debug(SMB, "SMB_SET_CIFS_UNIX_INFO\n");
+		if (le16_to_cpu(params->ClientUnixMajor) !=
+			CIFS_UNIX_MAJOR_VERSION) {
+			pr_err("Non compatible unix major info\n");
+			return -EINVAL;
+		}
+
+		if (le16_to_cpu(params->ClientUnixMinor) !=
+			CIFS_UNIX_MINOR_VERSION) {
+			pr_err("Non compatible unix minor info\n");
+			return -EINVAL;
+		}
+
+		client_cap = le64_to_cpu(params->ClientUnixCap);
+		ksmbd_debug(SMB, "clients unix cap = %llx\n", client_cap);
+		/* TODO: process caps */
+		rsp->hdr.WordCount = 0x0A;
+		rsp->t2.TotalDataCount = 0;
+		break;
+	}
+	default:
+		ksmbd_debug(SMB, "info level %x  not supported\n", info_level);
+		return -EINVAL;
+	}
+
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2);
+	return 0;
+}
+
+/**
+ * query_fs_info() - handler for query fs info commands
+ * @work:	smb work containing query fs info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int query_fs_info(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct smb_com_trans2_qfsi_req_params *req_params;
+	struct ksmbd_conn *conn = work->conn;
+	struct kstatfs stfs;
+	struct ksmbd_share_config *share;
+	int rc;
+	struct path path;
+	bool incomplete = false;
+	int info_level, len = 0;
+	struct ksmbd_tree_connect *tree_conn;
+
+	req_params = (struct smb_com_trans2_qfsi_req_params *)
+		(work->request_buf + le16_to_cpu(req->ParameterOffset) + 4);
+	/* check if more data is coming */
+	if (le16_to_cpu(req->TotalParameterCount) !=
+	    le16_to_cpu(req->ParameterCount)) {
+		ksmbd_debug(SMB, "total param = %d, received = %d\n",
+			    le16_to_cpu(req->TotalParameterCount),
+			    le16_to_cpu(req->ParameterCount));
+		incomplete = true;
+	}
+
+	if (le16_to_cpu(req->TotalDataCount) != le16_to_cpu(req->DataCount)) {
+		ksmbd_debug(SMB, "total data = %d, received = %d\n",
+			le16_to_cpu(req->TotalDataCount),
+			le16_to_cpu(req->DataCount));
+		incomplete = true;
+	}
+
+	if (incomplete) {
+		/* create 1 trans_state structure
+		 * and add to connection list
+		 */
+	}
+
+	info_level = le16_to_cpu(req_params->InformationLevel);
+
+	tree_conn = work->tcon;
+	if (!tree_conn)
+		return -ENOENT;
+	share = tree_conn->share_conf;
+
+	if (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE))
+		return -ENOENT;
+
+	if (ksmbd_override_fsids(work))
+		return -ENOMEM;
+
+	rc = kern_path(share->path, LOOKUP_NO_SYMLINKS, &path);
+	if (rc) {
+		ksmbd_revert_fsids(work);
+		pr_err("cannot create vfs path\n");
+		return rc;
+	}
+
+	rc = vfs_statfs(&path, &stfs);
+	if (rc) {
+		pr_err("cannot do stat of path %s\n", share->path);
+		goto err_out;
+	}
+
+	switch (info_level) {
+	case SMB_INFO_ALLOCATION:
+	{
+		struct filesystem_alloc_info *ainfo;
+
+		ksmbd_debug(SMB, "GOT SMB_INFO_ALLOCATION\n");
+		rsp->t2.TotalDataCount = cpu_to_le16(18);
+		ainfo = (struct filesystem_alloc_info *)(&rsp->Pad + 1);
+		ainfo->fsid = 0;
+		ainfo->BytesPerSector = cpu_to_le16(512);
+		ainfo->SectorsPerAllocationUnit =
+		cpu_to_le32(stfs.f_bsize/le16_to_cpu(ainfo->BytesPerSector));
+		ainfo->TotalAllocationUnits = cpu_to_le32(stfs.f_blocks);
+		ainfo->FreeAllocationUnits = cpu_to_le32(stfs.f_bfree);
+		break;
+	}
+	case SMB_QUERY_FS_VOLUME_INFO:
+	{
+		struct filesystem_vol_info *vinfo;
+
+		ksmbd_debug(SMB, "GOT SMB_QUERY_FS_VOLUME_INFO\n");
+		vinfo = (struct filesystem_vol_info *)(&rsp->Pad + 1);
+		vinfo->VolumeCreationTime = 0;
+		/* Taking dummy value of serial number*/
+		vinfo->SerialNumber = cpu_to_le32(0xbc3ac512);
+		len = smbConvertToUTF16((__le16 *)vinfo->VolumeLabel,
+			share->name, PATH_MAX, conn->local_nls, 0);
+		vinfo->VolumeLabelSize = cpu_to_le32(len);
+		vinfo->Reserved = 0;
+		rsp->t2.TotalDataCount =
+			cpu_to_le16(sizeof(struct filesystem_vol_info) +
+				    len - 2);
+		break;
+	}
+	case SMB_QUERY_FS_SIZE_INFO:
+	{
+		struct filesystem_info *sinfo;
+
+		ksmbd_debug(SMB, "GOT SMB_QUERY_FS_SIZE_INFO\n");
+		rsp->t2.TotalDataCount = cpu_to_le16(24);
+		sinfo = (struct filesystem_info *)(&rsp->Pad + 1);
+		sinfo->BytesPerSector = cpu_to_le32(512);
+		sinfo->SectorsPerAllocationUnit =
+			cpu_to_le32(stfs.f_bsize / sinfo->BytesPerSector);
+		sinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);
+		sinfo->FreeAllocationUnits = cpu_to_le64(stfs.f_bfree);
+		break;
+	}
+	case SMB_QUERY_FS_FULL_SIZE_INFO:
+	{
+		struct filesystem_full_info *sinfo;
+
+		ksmbd_debug(SMB, "GOT SMB_QUERY_FS_FULL_SIZE_INFO\n");
+		rsp->t2.TotalDataCount = cpu_to_le16(32);
+		sinfo = (struct filesystem_full_info *)(&rsp->Pad + 1);
+		sinfo->BytesPerSector = cpu_to_le32(stfs.f_bsize);
+		sinfo->SectorsPerAllocationUnit =
+			cpu_to_le32(stfs.f_bsize/sinfo->BytesPerSector);
+		sinfo->TotalAllocationUnits = cpu_to_le64(stfs.f_blocks);
+		sinfo->FreeAllocationUnits = cpu_to_le64(stfs.f_bfree);
+		sinfo->ActualAvailableUnits = cpu_to_le64(stfs.f_bavail);
+		break;
+	}
+	case SMB_QUERY_FS_DEVICE_INFO:
+	{
+		struct filesystem_device_info *fdi;
+
+		/* query fs info device info response is 0 word and 8 bytes */
+		ksmbd_debug(SMB, "GOT SMB_QUERY_FS_DEVICE_INFO\n");
+		if (le16_to_cpu(req->MaxDataCount) < 8) {
+			pr_err("Insufficient bytes, cannot response()\n");
+			rc = -EINVAL;
+			goto err_out;
+		}
+
+		rsp->t2.TotalDataCount = cpu_to_le16(18);
+		fdi = (struct filesystem_device_info *)(&rsp->Pad + 1);
+		fdi->DeviceType = cpu_to_le32(FILE_DEVICE_DISK);
+		fdi->DeviceCharacteristics = cpu_to_le32(0x20);
+		break;
+	}
+	case SMB_QUERY_FS_ATTRIBUTE_INFO:
+	{
+		struct filesystem_attribute_info *info;
+
+		ksmbd_debug(SMB, "GOT SMB_QUERY_FS_ATTRIBUTE_INFO\n");
+		/* constant 12 bytes + variable filesystem name */
+		info = (struct filesystem_attribute_info *)(&rsp->Pad + 1);
+
+		if (le16_to_cpu(req->MaxDataCount) < 12) {
+			pr_err("Insufficient bytes, cannot response()\n");
+			rc = -EINVAL;
+			goto err_out;
+		}
+
+		info->Attributes = cpu_to_le32(FILE_CASE_PRESERVED_NAMES |
+					       FILE_CASE_SENSITIVE_SEARCH |
+					       FILE_VOLUME_QUOTAS);
+		info->MaxPathNameComponentLength = cpu_to_le32(stfs.f_namelen);
+		info->FileSystemNameLen = 0;
+		rsp->t2.TotalDataCount = cpu_to_le16(12);
+		break;
+	}
+	case SMB_QUERY_CIFS_UNIX_INFO:
+	{
+		struct filesystem_unix_info *uinfo;
+
+		ksmbd_debug(SMB, "GOT SMB_QUERY_CIFS_UNIX_INFO\n");
+		/* constant 12 bytes + variable filesystem name */
+		uinfo = (struct filesystem_unix_info *)(&rsp->Pad + 1);
+
+		if (le16_to_cpu(req->MaxDataCount) < 12) {
+			pr_err("Insufficient bytes, cannot response()\n");
+			rc = -EINVAL;
+			goto err_out;
+		}
+		uinfo->MajorVersionNumber =
+			cpu_to_le16(CIFS_UNIX_MAJOR_VERSION);
+		uinfo->MinorVersionNumber =
+			cpu_to_le16(CIFS_UNIX_MINOR_VERSION);
+		uinfo->Capability = cpu_to_le64(SMB_UNIX_CAPS);
+		rsp->t2.TotalDataCount = cpu_to_le16(12);
+		break;
+	}
+	case SMB_QUERY_POSIX_FS_INFO:
+	{
+		struct filesystem_posix_info *pinfo;
+
+		ksmbd_debug(SMB, "GOT SMB_QUERY_POSIX_FS_INFO\n");
+		rsp->t2.TotalDataCount = cpu_to_le16(56);
+		pinfo = (struct filesystem_posix_info *)(&rsp->Pad + 1);
+		pinfo->BlockSize = cpu_to_le32(stfs.f_bsize);
+		pinfo->OptimalTransferSize = cpu_to_le32(stfs.f_blocks);
+		pinfo->TotalBlocks = cpu_to_le64(stfs.f_blocks);
+		pinfo->BlocksAvail = cpu_to_le64(stfs.f_bfree);
+		pinfo->UserBlocksAvail = cpu_to_le64(stfs.f_bavail);
+		pinfo->TotalFileNodes = cpu_to_le64(stfs.f_files);
+		pinfo->FreeFileNodes = cpu_to_le64(stfs.f_ffree);
+		pinfo->FileSysIdentifier = 0;
+		break;
+	}
+	default:
+		ksmbd_debug(SMB, "info level %x not implemented\n", info_level);
+		rc = -EINVAL;
+		goto err_out;
+	}
+
+	create_trans2_reply(work, le16_to_cpu(rsp->t2.TotalDataCount));
+
+err_out:
+	path_put(&path);
+	ksmbd_revert_fsids(work);
+	return rc;
+}
+
+/**
+ * smb_posix_convert_flags() - convert smb posix access flags to open flags
+ * @flags:	smb posix access flags
+ *
+ * Return:	file open flags
+ */
+static __u32 smb_posix_convert_flags(__u32 flags, int *may_flags)
+{
+	__u32 posix_flags = 0;
+
+	if ((flags & SMB_ACCMODE) == SMB_O_RDONLY)
+		posix_flags = O_RDONLY;
+	else if ((flags & SMB_ACCMODE) == SMB_O_WRONLY)
+		posix_flags = O_WRONLY;
+	else if ((flags & SMB_ACCMODE) == SMB_O_RDWR)
+		posix_flags = O_RDWR;
+
+	if (flags & SMB_O_CREAT)
+		posix_flags |= O_CREAT;
+	if (flags & SMB_O_SYNC)
+		posix_flags |= O_DSYNC;
+	if (flags & SMB_O_DIRECTORY)
+		posix_flags |= O_DIRECTORY;
+	if (flags & SMB_O_NOFOLLOW)
+		posix_flags |= O_NOFOLLOW;
+	if (flags & SMB_O_APPEND)
+		posix_flags |= O_APPEND;
+
+	*may_flags = ksmbd_openflags_to_mayflags(posix_flags);
+
+	return posix_flags;
+}
+
+/**
+ * smb_get_disposition() - convert smb disposition flags to open flags
+ * @flags:		smb file disposition flags
+ * @file_present:	file already present or not
+ * @stat:		file stat information
+ * @open_flags:		open flags should be stored here
+ *
+ * Return:		file disposition flags
+ */
+static int smb_get_disposition(unsigned int flags, bool file_present,
+			       struct kstat *stat, unsigned int *open_flags)
+{
+	int dispostion, disp_flags;
+
+	if ((flags & (SMB_O_CREAT | SMB_O_EXCL)) == (SMB_O_CREAT | SMB_O_EXCL))
+		dispostion = FILE_CREATE;
+	else if ((flags & (SMB_O_CREAT | SMB_O_TRUNC)) ==
+		 (SMB_O_CREAT | SMB_O_TRUNC))
+		dispostion = FILE_OVERWRITE_IF;
+	else if ((flags & SMB_O_CREAT) == SMB_O_CREAT)
+		dispostion = FILE_OPEN_IF;
+	else if ((flags & SMB_O_TRUNC) == SMB_O_TRUNC)
+		dispostion = FILE_OVERWRITE;
+	else if ((flags & (SMB_O_CREAT | SMB_O_EXCL | SMB_O_TRUNC)) == 0)
+		dispostion = FILE_OPEN;
+	else
+		dispostion = FILE_SUPERSEDE;
+
+	disp_flags = file_create_dispostion_flags(dispostion, file_present);
+	if (disp_flags < 0)
+		return disp_flags;
+
+	*open_flags |= disp_flags;
+	return disp_flags;
+}
+
+/**
+ * smb_posix_open() - handler for smb posix open
+ * @work:	smb work containing posix open command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_posix_open(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *pSMB_req = work->request_buf;
+	struct smb_com_trans2_spi_rsp *pSMB_rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct open_psx_req *psx_req;
+	struct open_psx_rsp *psx_rsp;
+	struct path path, parent_path;
+	struct kstat stat;
+	__u16 data_offset, rsp_info_level, file_info = 0;
+	__u32 oplock_flags, posix_open_flags, may_flags;
+	umode_t mode;
+	char *name;
+	bool file_present = true, create_directory;
+	int err;
+	struct ksmbd_file *fp = NULL;
+	int oplock_rsp = OPLOCK_NONE;
+
+	name = smb_get_name(share, pSMB_req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		pSMB_rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+
+	if (ksmbd_override_fsids(work)) {
+		pSMB_rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		kfree(name);
+		return -ENOMEM;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	err = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					 &parent_path, &path, 0);
+#else
+	err = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, 0);
+#endif
+	if (err) {
+		file_present = false;
+		ksmbd_debug(SMB, "cannot get linux path for %s, err = %d\n",
+			    name, err);
+		if (err == -EACCES || err == -EXDEV)
+			goto out;
+	} else {
+		if (d_is_symlink(path.dentry)) {
+			err = -EACCES;
+			goto free_path;
+		}
+		err = vfs_getattr(&path, &stat, STATX_BASIC_STATS,
+				  AT_STATX_SYNC_AS_STAT);
+		if (err) {
+			pr_err("can not stat %s, err = %d\n", name, err);
+			goto free_path;
+		}
+	}
+
+	data_offset = le16_to_cpu(pSMB_req->DataOffset);
+	psx_req = (struct open_psx_req *)(((char *)&pSMB_req->hdr.Protocol) +
+			data_offset);
+	oplock_flags = le32_to_cpu(psx_req->OpenFlags);
+
+	posix_open_flags = smb_posix_convert_flags(
+			le32_to_cpu(psx_req->PosixOpenFlags),
+			&may_flags);
+	create_directory = !!(posix_open_flags == (O_DIRECTORY | O_CREAT));
+
+	err = smb_get_disposition(le32_to_cpu(psx_req->PosixOpenFlags),
+				  file_present, &stat, &posix_open_flags);
+	if (err < 0) {
+		ksmbd_debug(SMB, "create_dispostion returned %d\n", err);
+		if (file_present)
+			goto free_path;
+		else
+			goto out;
+	}
+
+	ksmbd_debug(SMB, "filename : %s, posix_open_flags : %x\n", name,
+		    posix_open_flags);
+	mode = (umode_t)le64_to_cpu(psx_req->Permissions);
+	rsp_info_level = le16_to_cpu(psx_req->Level);
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		if (posix_open_flags & O_CREAT) {
+			err = -EACCES;
+			ksmbd_debug(SMB,
+				"returning as user does not have permission to write\n");
+			if (file_present)
+				goto free_path;
+			else
+				goto out;
+		}
+	}
+
+	if (file_present && create_directory) {
+		err = -EEXIST;
+		goto free_path;
+	}
+
+	if (!file_present && (posix_open_flags & O_CREAT)) {
+		err = smb_common_create(work, &parent_path, &path, name,
+					posix_open_flags, mode,
+					create_directory);
+		if (err) {
+			ksmbd_debug(SMB, "smb_common_create err: %d\n", err);
+			goto out;
+		}
+
+		if (create_directory)
+			goto prepare_rsp;
+	} else {
+		err = compat_inode_permission(&path, d_inode(path.dentry),
+					      may_flags);
+		if (err)
+			goto free_path;
+	}
+
+	fp = ksmbd_vfs_dentry_open(work, &path, posix_open_flags, 0,
+				   file_present);
+	if (IS_ERR(fp)) {
+		err = PTR_ERR(fp);
+		fp = NULL;
+		goto free_path;
+	}
+	fp->pid = le16_to_cpu(pSMB_req->hdr.Pid);
+
+	write_lock(&fp->f_ci->m_lock);
+	list_add(&fp->node, &fp->f_ci->m_fp_list);
+	write_unlock(&fp->f_ci->m_lock);
+
+	if (smb1_oplock_enable &&
+	    test_share_config_flag(work->tcon->share_conf,
+			KSMBD_SHARE_FLAG_OPLOCKS) &&
+		!S_ISDIR(file_inode(fp->filp)->i_mode)) {
+		/* Client cannot request levelII oplock directly */
+		err = smb_grant_oplock(work, oplock_flags &
+			(REQ_OPLOCK | REQ_BATCHOPLOCK), fp->volatile_id, fp,
+			le16_to_cpu(pSMB_req->hdr.Tid), NULL, 0);
+		if (err)
+			goto free_path;
+	}
+
+	oplock_rsp = fp->f_opinfo != NULL ? fp->f_opinfo->level : 0;
+
+prepare_rsp:
+	/* open/mkdir success, send back response */
+	data_offset = sizeof(struct smb_com_trans2_spi_rsp) -
+		      sizeof(pSMB_rsp->hdr.smb_buf_length) + 3 /*alignment*/;
+	psx_rsp = (struct open_psx_rsp *)(((char *)&pSMB_rsp->hdr.Protocol) +
+			data_offset);
+	if (data_offset + sizeof(struct open_psx_rsp) > work->response_sz) {
+		err = -EIO;
+		goto free_path;
+	}
+
+	psx_rsp->OplockFlags = cpu_to_le16(oplock_rsp);
+	psx_rsp->Fid = fp != NULL ? fp->volatile_id : 0;
+
+	if (file_present) {
+		if (!(posix_open_flags & O_TRUNC))
+			file_info = F_OPENED;
+		else
+			file_info = F_OVERWRITTEN;
+	} else
+		file_info = F_CREATED;
+	psx_rsp->CreateAction = cpu_to_le32(file_info);
+
+	if (rsp_info_level != SMB_QUERY_FILE_UNIX_BASIC) {
+		ksmbd_debug(SMB, "returning null information level response");
+		rsp_info_level = SMB_NO_INFO_LEVEL_RESPONSE;
+	}
+	psx_rsp->ReturnedLevel = cpu_to_le16(rsp_info_level);
+
+	err = vfs_getattr(&path, &stat, STATX_BASIC_STATS,
+			  AT_STATX_SYNC_AS_STAT);
+	if (err) {
+		pr_err("cannot get stat information\n");
+		goto free_path;
+	}
+
+	pSMB_rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	pSMB_rsp->hdr.WordCount = 10;
+	pSMB_rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	pSMB_rsp->t2.TotalDataCount = cpu_to_le16(sizeof(struct open_psx_rsp));
+	pSMB_rsp->t2.ParameterCount = pSMB_rsp->t2.TotalParameterCount;
+	pSMB_rsp->t2.Reserved = 0;
+	pSMB_rsp->t2.ParameterCount = cpu_to_le16(2);
+	pSMB_rsp->t2.ParameterOffset = cpu_to_le16(56);
+	pSMB_rsp->t2.ParameterDisplacement = 0;
+	pSMB_rsp->t2.DataCount = pSMB_rsp->t2.TotalDataCount;
+	pSMB_rsp->t2.DataOffset = cpu_to_le16(data_offset);
+	pSMB_rsp->t2.DataDisplacement = 0;
+	pSMB_rsp->t2.SetupCount = 0;
+	pSMB_rsp->t2.Reserved1 = 0;
+
+	/* 2 for parameter count + 12 data count + 3 pad (1 pad1 + 2 pad2)*/
+	pSMB_rsp->ByteCount = cpu_to_le16(sizeof(struct open_psx_rsp) + 2 + 3);
+	pSMB_rsp->Reserved2 = 0;
+	inc_rfc1001_len(&pSMB_rsp->hdr, (pSMB_rsp->hdr.WordCount * 2 + 117));
+
+free_path:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	path_put(&path);
+#endif
+out:
+	switch (err) {
+	case 0:
+		break;
+	case -ENOSPC:
+		pSMB_rsp->hdr.Status.CifsError = STATUS_DISK_FULL;
+		break;
+	case -EINVAL:
+		pSMB_rsp->hdr.Status.CifsError = STATUS_NO_SUCH_USER;
+		break;
+	case -EACCES:
+		pSMB_rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		break;
+	case -ENOENT:
+		pSMB_rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_NOT_FOUND;
+		break;
+	case -EBUSY:
+		pSMB_rsp->hdr.Status.CifsError = STATUS_DELETE_PENDING;
+		break;
+	case -EEXIST:
+		pSMB_rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_COLLISION;
+		break;
+	default:
+		pSMB_rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+	}
+
+	if (err && fp)
+		ksmbd_close_fd(work, fp->volatile_id);
+	kfree(name);
+	ksmbd_revert_fsids(work);
+	return err;
+}
+
+/**
+ * smb_posix_unlink() - handler for posix file delete
+ * @work:	smb work containing trans2 posix delete command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_posix_unlink(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct unlink_psx_rsp *psx_rsp = NULL;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	struct path path, parent_path;
+#endif
+	char *name;
+	int rc = 0;
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		ksmbd_debug(SMB,
+			"returning as user does not have permission to write\n");
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		return -EACCES;
+	}
+
+	name = smb_get_name(share, req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	rc = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					&parent_path, &path, 0);
+	if (rc < 0)
+		goto out;
+
+	rc = ksmbd_vfs_remove_file(work, &path);
+
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	rc = ksmbd_vfs_remove_file(work, name);
+#endif
+	if (rc < 0)
+		goto out;
+
+	psx_rsp = (struct unlink_psx_rsp *)((char *)rsp +
+			sizeof(struct smb_com_trans2_rsp));
+	psx_rsp->EAErrorOffset = cpu_to_le16(0);
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = cpu_to_le16(0);
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = cpu_to_le16(2);
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = cpu_to_le16(0);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 2 for parameter count + 1 pad1*/
+	rsp->ByteCount = cpu_to_le16(3);
+	rsp->Pad = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+
+out:
+	if (rc)
+		rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+
+	kfree(name);
+	return rc;
+}
+
+/**
+ * smb_set_time_pathinfo() - handler for setting time using set path info
+ * @work:	smb work containing set path info command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_time_pathinfo(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct file_basic_info *info;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct iattr attrs;
+	char *name;
+	int err = 0;
+
+	name = smb_get_name(share, req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+
+	info = (struct file_basic_info *)(((char *) &req->hdr.Protocol) +
+			le16_to_cpu(req->DataOffset));
+
+	attrs.ia_valid = 0;
+	if (le64_to_cpu(info->LastAccessTime)) {
+		attrs.ia_atime = smb_NTtimeToUnix(info->LastAccessTime);
+		attrs.ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);
+	}
+
+	if (le64_to_cpu(info->ChangeTime)) {
+		attrs.ia_ctime = smb_NTtimeToUnix(info->ChangeTime);
+		attrs.ia_valid |= ATTR_CTIME;
+	}
+
+	if (le64_to_cpu(info->LastWriteTime)) {
+		attrs.ia_mtime = smb_NTtimeToUnix(info->LastWriteTime);
+		attrs.ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);
+	}
+	/* TODO: check dos mode and acl bits if req->Attributes nonzero */
+
+	if (!attrs.ia_valid)
+		goto done;
+
+	err = ksmbd_vfs_setattr(work, name, 0, &attrs);
+	if (err) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		return err;
+	}
+
+done:
+	ksmbd_debug(SMB, "%s setattr done\n", name);
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 3 pad (1 pad1 + 2 pad2)*/
+	rsp->ByteCount = cpu_to_le16(3);
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+
+	kfree(name);
+	return 0;
+}
+
+/**
+ * smb_set_unix_pathinfo() - handler for setting unix path info(setattr)
+ * @work:	smb work containing set path info command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_unix_pathinfo(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct file_unix_basic_info *unix_info;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct path path;
+	struct iattr attrs;
+	char *name;
+	int err = 0;
+
+	name = smb_get_name(share, req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+
+	if (ksmbd_override_fsids(work))
+		return -ENOMEM;
+	err = kern_path(name, 0, &path);
+	if (err) {
+		ksmbd_revert_fsids(work);
+		kfree(name);
+		return -ENOENT;
+	}
+
+	unix_info =  (struct file_unix_basic_info *)
+		(((char *) &req->hdr.Protocol) + le16_to_cpu(req->DataOffset));
+	attrs.ia_valid = 0;
+	attrs.ia_mode = 0;
+	err = unix_info_to_attr(unix_info, &init_user_ns, &attrs);
+	path_put(&path);
+	ksmbd_revert_fsids(work);
+	if (err)
+		goto out;
+
+	err = ksmbd_vfs_setattr(work, name, 0, &attrs);
+	if (err)
+		goto out;
+	/* setattr success, prepare response */
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 3 pad (1 pad1 + 2 pad2)*/
+	rsp->ByteCount = cpu_to_le16(3);
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+
+out:
+	kfree(name);
+	if (err) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		return err;
+	}
+	return 0;
+}
+
+/**
+ * smb_set_ea() - handler for setting extended attributes using set path
+ *		info command
+ * @work:	smb work containing set path info command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_ea(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct fealist *eabuf;
+	struct fea *ea;
+	char *fname, *attr_name = NULL, *value;
+	int rc = 0, list_len, i, next = 0;
+
+	fname = smb_get_name(share, req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(fname)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(fname);
+	}
+
+	eabuf = (struct fealist *)(((char *) &req->hdr.Protocol)
+			+ le16_to_cpu(req->DataOffset));
+
+	list_len = le32_to_cpu(eabuf->list_len) - 4;
+	ea = (struct fea *)eabuf->list;
+
+	for (i = 0; list_len >= 0 && ea->name_len != 0; i++, list_len -= next) {
+		if (ea->name_len > (XATTR_NAME_MAX - XATTR_USER_PREFIX_LEN)) {
+			rc = -EINVAL;
+			goto out;
+		}
+
+		next = ea->name_len + le16_to_cpu(ea->value_len) + 4;
+
+		attr_name = kmalloc(XATTR_NAME_MAX + 1, GFP_KERNEL);
+		if (!attr_name) {
+			rc = -ENOMEM;
+			goto out;
+		}
+
+		memcpy(attr_name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN);
+		memcpy(&attr_name[XATTR_USER_PREFIX_LEN], ea->name,
+		       ea->name_len);
+		attr_name[XATTR_USER_PREFIX_LEN + ea->name_len] = '\0';
+		value = (char *)&ea->name + ea->name_len + 1;
+		ksmbd_debug(SMB, "name: <%s>, name_len %u, value_len %u\n",
+			    ea->name, ea->name_len, le16_to_cpu(ea->value_len));
+
+		rc = ksmbd_vfs_fsetxattr(work, fname, attr_name, value,
+					 le16_to_cpu(ea->value_len), 0);
+		if (rc < 0) {
+			kfree(attr_name);
+			rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+			goto out;
+		}
+		kfree(attr_name);
+		ea += next;
+	}
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = cpu_to_le16(0);
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = cpu_to_le16(2);
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = cpu_to_le16(0);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 2 for parameter count + 1 pad1*/
+	rsp->ByteCount = cpu_to_le16(3);
+	rsp->Pad = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+
+out:
+	kfree(fname);
+	return rc;
+}
+
+/**
+ * smb_set_file_size_pinfo() - handler for setting eof or truncate using
+ *		trans2 set path info command
+ * @work:	smb work containing set path info command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_file_size_pinfo(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct file_end_of_file_info *eofinfo;
+	struct iattr attr;
+	char *name = NULL;
+	loff_t newsize;
+	int rc = 0;
+
+	name = smb_get_name(share, req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+
+	eofinfo =  (struct file_end_of_file_info *)
+		(((char *) &req->hdr.Protocol) + le16_to_cpu(req->DataOffset));
+	newsize = le64_to_cpu(eofinfo->FileSize);
+	attr.ia_valid = ATTR_SIZE;
+	attr.ia_size = newsize;
+	rc = ksmbd_vfs_setattr(work, name, 0, &attr);
+	if (rc) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		goto out;
+	}
+	ksmbd_debug(SMB, "%s truncated to newsize %lld\n", name, newsize);
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 2 for parameter count + 1 pad1*/
+	rsp->ByteCount = cpu_to_le16(3);
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+
+out:
+	kfree(name);
+	return rc;
+}
+
+/**
+ * smb_creat_hardlink() - handler for creating hardlink
+ * @work:	smb work containing set path info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_creat_hardlink(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	char *oldname, *newname, *oldname_offset;
+	int err;
+
+	newname = smb_get_name(share, req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(newname)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(newname);
+	}
+
+	oldname_offset = ((char *)&req->hdr.Protocol) +
+				le16_to_cpu(req->DataOffset);
+	oldname = smb_get_name(share, oldname_offset, PATH_MAX, work, false);
+	if (IS_ERR(oldname)) {
+		err = PTR_ERR(oldname);
+		oldname = NULL;
+		goto out;
+	}
+	ksmbd_debug(SMB, "oldname %s, newname %s\n", oldname, newname);
+
+	err = ksmbd_vfs_link(work, oldname, newname);
+	if (err < 0) {
+		if (err == -EACCES)
+			rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		else
+			rsp->hdr.Status.CifsError = STATUS_NOT_SAME_DEVICE;
+		goto out;
+	}
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = 0;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+	rsp->ByteCount = cpu_to_le16(3);
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+out:
+	kfree(newname);
+	kfree(oldname);
+	return err;
+}
+
+/**
+ * smb_creat_symlink() - handler for creating symlink
+ * @work:	smb work containing set path info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_creat_symlink(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *req = work->request_buf;
+	struct smb_com_trans2_spi_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	char *name, *symname, *name_offset;
+	bool is_unicode = is_smbreq_unicode(&req->hdr);
+	int err;
+
+	symname = smb_get_name(share, req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(symname)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(symname);
+	}
+
+	name_offset = ((char *)&req->hdr.Protocol) +
+		le16_to_cpu(req->DataOffset);
+	name = smb_strndup_from_utf16(name_offset, PATH_MAX, is_unicode,
+				      work->conn->local_nls);
+	if (IS_ERR(name)) {
+		kfree(symname);
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		return PTR_ERR(name);
+	}
+	ksmbd_debug(SMB, "name %s, symname %s\n", name, symname);
+
+	err = ksmbd_vfs_symlink(work, name, symname);
+	if (err < 0) {
+		if (err == -ENOSPC)
+			rsp->hdr.Status.CifsError = STATUS_DISK_FULL;
+		else if (err == -EEXIST)
+			rsp->hdr.Status.CifsError =
+				STATUS_OBJECT_NAME_COLLISION;
+		else
+			rsp->hdr.Status.CifsError = STATUS_NOT_SAME_DEVICE;
+	} else
+		rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = 0;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+	rsp->ByteCount = cpu_to_le16(3);
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+	kfree(name);
+	kfree(symname);
+	return err;
+}
+
+/**
+ * set_path_info() - handler for trans2 set path info sub commands
+ * @work:	smb work containing set path info command
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int set_path_info(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_spi_req *pSMB_req = work->request_buf;
+	struct smb_com_trans2_spi_rsp *pSMB_rsp = work->response_buf;
+	__u16 info_level, total_param;
+	int err = 0;
+
+	info_level = le16_to_cpu(pSMB_req->InformationLevel);
+	total_param = le16_to_cpu(pSMB_req->TotalParameterCount);
+	if (total_param < 7) {
+		pSMB_rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		pr_err("invalid total parameter for info_level 0x%x\n",
+		       total_param);
+		return -EINVAL;
+	}
+
+	switch (info_level) {
+	case SMB_POSIX_OPEN:
+		err = smb_posix_open(work);
+		break;
+	case SMB_POSIX_UNLINK:
+		err = smb_posix_unlink(work);
+		break;
+	case SMB_SET_FILE_UNIX_HLINK:
+		err = smb_creat_hardlink(work);
+		break;
+	case SMB_SET_FILE_UNIX_LINK:
+		err = smb_creat_symlink(work);
+		break;
+	case SMB_SET_FILE_BASIC_INFO:
+		/* fall through */
+	case SMB_SET_FILE_BASIC_INFO2:
+		err = smb_set_time_pathinfo(work);
+		break;
+	case SMB_SET_FILE_UNIX_BASIC:
+		err = smb_set_unix_pathinfo(work);
+		break;
+	case SMB_SET_FILE_EA:
+		err = smb_set_ea(work);
+		break;
+	case SMB_SET_POSIX_ACL:
+		err = smb_set_acl(work);
+		break;
+	case SMB_SET_FILE_END_OF_FILE_INFO2:
+		/* fall through */
+	case SMB_SET_FILE_END_OF_FILE_INFO:
+		err = smb_set_file_size_pinfo(work);
+		break;
+	default:
+		ksmbd_debug(SMB, "info level = %x not implemented yet\n",
+			    info_level);
+		pSMB_rsp->hdr.Status.CifsError = STATUS_NOT_IMPLEMENTED;
+		return -EOPNOTSUPP;
+	}
+
+	if (err < 0)
+		ksmbd_debug(SMB, "info_level 0x%x failed, err %d\n", info_level,
+			    err);
+	return err;
+}
+static int readdir_info_level_struct_sz(int info_level)
+{
+	switch (info_level) {
+	case SMB_FIND_FILE_INFO_STANDARD:
+		return sizeof(struct find_info_standard);
+	case SMB_FIND_FILE_QUERY_EA_SIZE:
+		return sizeof(struct find_info_query_ea_size);
+	case SMB_FIND_FILE_DIRECTORY_INFO:
+		return sizeof(struct file_directory_info);
+	case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
+		return sizeof(struct file_full_directory_info);
+	case SMB_FIND_FILE_NAMES_INFO:
+		return sizeof(struct file_names_info);
+	case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
+		return sizeof(struct file_both_directory_info);
+	case SMB_FIND_FILE_ID_FULL_DIR_INFO:
+		return sizeof(struct file_id_full_dir_info);
+	case SMB_FIND_FILE_ID_BOTH_DIR_INFO:
+		return sizeof(struct file_id_both_directory_info);
+	case SMB_FIND_FILE_UNIX:
+		return sizeof(struct file_unix_info);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/**
+ * smb_populate_readdir_entry() - encode directory entry in smb response buffer
+ * @conn:	connection instance
+ * @info_level:	smb information level
+ * @d_info: structure included variables for query dir
+ * @ksmbd_kstat: ksmbd wrapper of dirent stat information
+ *
+ * if directory has many entries, find first can't read it fully.
+ * find next might be called multiple times to read remaining dir entries
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,
+				      struct ksmbd_dir_info *d_info,
+				      struct ksmbd_kstat *ksmbd_kstat)
+{
+	int next_entry_offset;
+	char *conv_name;
+	int conv_len;
+	int struct_sz;
+
+	struct_sz = readdir_info_level_struct_sz(info_level);
+	if (struct_sz == -EOPNOTSUPP)
+		return -EOPNOTSUPP;
+
+	conv_name = ksmbd_convert_dir_info_name(d_info,
+						conn->local_nls,
+						&conv_len);
+	if (!conv_name)
+		return -ENOMEM;
+
+	next_entry_offset = ALIGN(struct_sz - 1 + conv_len,
+				  KSMBD_DIR_INFO_ALIGNMENT);
+
+	if (next_entry_offset > d_info->out_buf_len) {
+		kfree(conv_name);
+		d_info->out_buf_len = -1;
+		return -ENOSPC;
+	}
+
+	switch (info_level) {
+	case SMB_FIND_FILE_INFO_STANDARD:
+	{
+		struct find_info_standard *fsinfo;
+
+		fsinfo = (struct find_info_standard *)(d_info->wptr);
+		unix_to_dos_time(
+			ksmbd_NTtimeToUnix(
+				cpu_to_le64(ksmbd_kstat->create_time)),
+			&fsinfo->CreationTime,
+			&fsinfo->CreationDate);
+		unix_to_dos_time(ksmbd_kstat->kstat->atime,
+				 &fsinfo->LastAccessTime,
+				 &fsinfo->LastAccessDate);
+		unix_to_dos_time(ksmbd_kstat->kstat->mtime,
+				 &fsinfo->LastWriteTime,
+				 &fsinfo->LastWriteDate);
+		fsinfo->DataSize = cpu_to_le32(ksmbd_kstat->kstat->size);
+		fsinfo->AllocationSize =
+			cpu_to_le32(ksmbd_kstat->kstat->blocks << 9);
+		fsinfo->Attributes =
+			cpu_to_le16(S_ISDIR(ksmbd_kstat->kstat->mode) ?
+				ATTR_DIRECTORY : ATTR_ARCHIVE);
+		fsinfo->FileNameLength = cpu_to_le16(conv_len);
+		memcpy(fsinfo->FileName, conv_name, conv_len);
+
+		break;
+	}
+	case SMB_FIND_FILE_QUERY_EA_SIZE:
+	{
+		struct find_info_query_ea_size *fesize;
+
+		fesize = (struct find_info_query_ea_size *)(d_info->wptr);
+		unix_to_dos_time(
+			ksmbd_NTtimeToUnix(
+				cpu_to_le64(ksmbd_kstat->create_time)),
+			&fesize->CreationTime,
+			&fesize->CreationDate);
+		unix_to_dos_time(ksmbd_kstat->kstat->atime,
+				 &fesize->LastAccessTime,
+				 &fesize->LastAccessDate);
+		unix_to_dos_time(ksmbd_kstat->kstat->mtime,
+				 &fesize->LastWriteTime,
+				 &fesize->LastWriteDate);
+
+		fesize->DataSize = cpu_to_le32(ksmbd_kstat->kstat->size);
+		fesize->AllocationSize =
+			cpu_to_le32(ksmbd_kstat->kstat->blocks << 9);
+		fesize->Attributes =
+			cpu_to_le16(S_ISDIR(ksmbd_kstat->kstat->mode) ?
+				ATTR_DIRECTORY : ATTR_ARCHIVE);
+		fesize->EASize = 0;
+		fesize->FileNameLength = (__u8)(conv_len);
+		memcpy(fesize->FileName, conv_name, conv_len);
+
+		break;
+	}
+	case SMB_FIND_FILE_DIRECTORY_INFO:
+	{
+		struct file_directory_info *fdinfo = NULL;
+
+		fdinfo = (struct file_directory_info *)
+			ksmbd_vfs_init_kstat(&d_info->wptr, ksmbd_kstat);
+		fdinfo->FileNameLength = cpu_to_le32(conv_len);
+		memcpy(fdinfo->FileName, conv_name, conv_len);
+		fdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
+		memset((char *)fdinfo + struct_sz - 1 + conv_len,
+			'\0',
+			next_entry_offset - struct_sz - 1 + conv_len);
+		break;
+	}
+	case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
+	{
+		struct file_full_directory_info *ffdinfo = NULL;
+
+		ffdinfo = (struct file_full_directory_info *)
+			ksmbd_vfs_init_kstat(&d_info->wptr, ksmbd_kstat);
+		ffdinfo->FileNameLength = cpu_to_le32(conv_len);
+		ffdinfo->EaSize = 0;
+		memcpy(ffdinfo->FileName, conv_name, conv_len);
+		ffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
+		memset((char *)ffdinfo + struct_sz - 1 + conv_len,
+			'\0',
+			next_entry_offset - struct_sz - 1 + conv_len);
+		break;
+	}
+	case SMB_FIND_FILE_NAMES_INFO:
+	{
+		struct file_names_info *fninfo = NULL;
+
+		fninfo = (struct file_names_info *)(d_info->wptr);
+		fninfo->FileNameLength = cpu_to_le32(conv_len);
+		memcpy(fninfo->FileName, conv_name, conv_len);
+		fninfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
+		memset((char *)fninfo + struct_sz - 1 + conv_len,
+			'\0',
+			next_entry_offset - struct_sz - 1 + conv_len);
+
+		break;
+	}
+	case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
+	{
+		struct file_both_directory_info *fbdinfo = NULL;
+
+		fbdinfo = (struct file_both_directory_info *)
+			ksmbd_vfs_init_kstat(&d_info->wptr, ksmbd_kstat);
+		fbdinfo->FileNameLength = cpu_to_le32(conv_len);
+		fbdinfo->EaSize = 0;
+		fbdinfo->ShortNameLength = 0;
+		fbdinfo->Reserved = 0;
+		memcpy(fbdinfo->FileName, conv_name, conv_len);
+		fbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
+		memset((char *)fbdinfo + struct_sz - 1 + conv_len,
+			'\0',
+			next_entry_offset - struct_sz - 1 + conv_len);
+		break;
+	}
+	case SMB_FIND_FILE_ID_FULL_DIR_INFO:
+	{
+		struct file_id_full_dir_info *dinfo = NULL;
+
+		dinfo = (struct file_id_full_dir_info *)
+			ksmbd_vfs_init_kstat(&d_info->wptr, ksmbd_kstat);
+		dinfo->FileNameLength = cpu_to_le32(conv_len);
+		dinfo->EaSize = 0;
+		dinfo->Reserved = 0;
+		dinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);
+		memcpy(dinfo->FileName, conv_name, conv_len);
+		dinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
+		memset((char *)dinfo + struct_sz - 1 + conv_len,
+			'\0',
+			next_entry_offset - struct_sz - 1 + conv_len);
+		break;
+	}
+	case SMB_FIND_FILE_ID_BOTH_DIR_INFO:
+	{
+		struct file_id_both_directory_info *fibdinfo = NULL;
+
+		fibdinfo = (struct file_id_both_directory_info *)
+			ksmbd_vfs_init_kstat(&d_info->wptr, ksmbd_kstat);
+		fibdinfo->FileNameLength = cpu_to_le32(conv_len);
+		fibdinfo->EaSize = 0;
+		fibdinfo->ShortNameLength = 0;
+		fibdinfo->Reserved = 0;
+		fibdinfo->Reserved2 = 0;
+		fibdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);
+		memcpy(fibdinfo->FileName, conv_name, conv_len);
+		fibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
+		memset((char *)fibdinfo + struct_sz - 1 + conv_len,
+			'\0',
+			next_entry_offset - struct_sz - 1 + conv_len);
+
+		break;
+	}
+	case SMB_FIND_FILE_UNIX:
+	{
+		struct file_unix_info *finfo = NULL;
+		struct file_unix_basic_info *unix_info;
+
+		finfo = (struct file_unix_info *)(d_info->wptr);
+		finfo->ResumeKey = 0;
+		unix_info = (struct file_unix_basic_info *)((char *)finfo + 8);
+		init_unix_info(unix_info, &init_user_ns, ksmbd_kstat->kstat);
+		/* include null terminator */
+		memcpy(finfo->FileName, conv_name, conv_len + 2);
+		next_entry_offset += 2;
+		finfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
+		memset((char *)finfo + struct_sz - 1 + conv_len,
+			'\0',
+			next_entry_offset - struct_sz - 1 + conv_len);
+		break;
+	}
+	}
+
+	d_info->num_entry++;
+	d_info->last_entry_offset = d_info->data_count;
+	d_info->data_count += next_entry_offset;
+	d_info->out_buf_len -= next_entry_offset;
+	d_info->wptr = (char *)(d_info->wptr) + next_entry_offset;
+	kfree(conv_name);
+
+	ksmbd_debug(SMB, "info_level : %d, buf_len :%d, next_offset : %d, data_count : %d\n",
+		    info_level, d_info->out_buf_len, next_entry_offset,
+		    d_info->data_count);
+	return 0;
+}
+
+/**
+ * ksmbd_fill_dirent() - populates a dirent details in readdir
+ * @ctx:	dir_context information
+ * @name:	dirent name
+ * @namelen:	dirent name length
+ * @offset:	dirent offset in directory
+ * @ino:	dirent inode number
+ * @d_type:	dirent type
+ *
+ * Return:	0 on success, otherwise -EINVAL
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
+static bool ksmbd_fill_dirent(struct dir_context *ctx, const char *name, int namlen,
+#else
+static int ksmbd_fill_dirent(struct dir_context *ctx, const char *name, int namlen,
+#endif
+		loff_t offset, u64 ino, unsigned int d_type)
+{
+	struct ksmbd_readdir_data *buf =
+		container_of(ctx, struct ksmbd_readdir_data, ctx);
+	struct ksmbd_dirent *de = (void *)(buf->dirent + buf->used);
+	unsigned int reclen;
+
+	reclen = ALIGN(sizeof(struct ksmbd_dirent) + namlen, sizeof(u64));
+	if (buf->used + reclen > PAGE_SIZE)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
+		return false;
+#else
+		return -EINVAL;
+#endif
+
+	de->namelen = namlen;
+	de->offset = offset;
+	de->ino = ino;
+	de->d_type = d_type;
+	memcpy(de->name, name, namlen);
+	buf->used += reclen;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
+	return true;
+#else
+	return 0;
+#endif
+}
+
+/**
+ * find_first() - smb readdir command
+ * @work:	smb work containing find first request params
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int find_first(struct ksmbd_work *work)
+{
+	struct smb_hdr *rsp_hdr = work->response_buf;
+	struct ksmbd_conn *conn = work->conn;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct smb_com_trans2_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct smb_com_trans2_ffirst_req_params *req_params;
+	struct smb_com_trans2_ffirst_rsp_parms *params = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	struct path path, parent_path;
+#else
+	struct path path;
+#endif
+	struct ksmbd_dirent *de;
+	struct ksmbd_file *dir_fp = NULL;
+	struct kstat kstat;
+	struct ksmbd_kstat ksmbd_kstat;
+	struct ksmbd_dir_info d_info;
+	int params_count = sizeof(struct smb_com_trans2_ffirst_rsp_parms);
+	int data_alignment_offset = 0;
+	int rc = 0, reclen = 0;
+	int srch_cnt = 0;
+	char *dirpath = NULL;
+	char *srch_ptr = NULL;
+	int header_size;
+	int struct_sz;
+
+	memset(&d_info, 0, sizeof(struct ksmbd_dir_info));
+
+	if (ksmbd_override_fsids(work)) {
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		return -ENOMEM;
+	}
+
+	req_params = (struct smb_com_trans2_ffirst_req_params *)
+		(work->request_buf + le16_to_cpu(req->ParameterOffset) + 4);
+	dirpath = smb_get_dir_name(share, req_params->FileName, PATH_MAX, work,
+				   &srch_ptr);
+	if (IS_ERR(dirpath)) {
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		rc = PTR_ERR(dirpath);
+		goto err_out;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	/* convert '/' to null character to avoid lookup failing */
+	if (strlen(dirpath) == 1 && dirpath[0] == '/')
+		dirpath[0] = '\0';
+
+	ksmbd_debug(SMB, "complete dir path = %s\n", dirpath);
+	rc = ksmbd_vfs_kern_path_locked(work, dirpath,
+					LOOKUP_NO_SYMLINKS | LOOKUP_DIRECTORY,
+					&parent_path, &path, 0);
+#else
+	ksmbd_debug(SMB, "complete dir path = %s\n",  dirpath);
+	rc = ksmbd_vfs_kern_path(work, dirpath,
+				 LOOKUP_NO_SYMLINKS | LOOKUP_DIRECTORY,
+				 &path, 0);
+#endif
+	if (rc < 0) {
+		ksmbd_debug(SMB, "cannot create vfs root path <%s> %d\n",
+			    dirpath, rc);
+		goto err_free_dirpath;
+	} else {
+		if (compat_inode_permission(&path, d_inode(path.dentry),
+					    MAY_READ | MAY_EXEC)) {
+			rc = -EACCES;
+			goto err_free_kernpath;
+		}
+	}
+
+	if (d_is_symlink(path.dentry)) {
+		rc = -EACCES;
+		goto err_free_kernpath;
+	}
+
+	dir_fp = ksmbd_vfs_dentry_open(work, &path, O_RDONLY, 0, 1);
+	if (IS_ERR(dir_fp)) {
+		ksmbd_debug(SMB, "dir dentry open failed with rc=%d\n", rc);
+		rc = -EINVAL;
+		dir_fp = NULL;
+		goto err_free_kernpath;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	inode_unlock(d_inode(parent_path.dentry));
+	path_put(&parent_path);
+#endif
+
+	write_lock(&dir_fp->f_ci->m_lock);
+	list_add(&dir_fp->node, &dir_fp->f_ci->m_fp_list);
+	write_unlock(&dir_fp->f_ci->m_lock);
+
+	set_ctx_actor(&dir_fp->readdir_data.ctx, ksmbd_fill_dirent);
+	dir_fp->readdir_data.dirent = (void *)__get_free_page(GFP_KERNEL);
+	if (!dir_fp->readdir_data.dirent) {
+		rc = -ENOMEM;
+		goto err_out;
+	}
+
+	dir_fp->filename = dirpath;
+	dir_fp->readdir_data.used = 0;
+	dir_fp->dirent_offset = 0;
+	dir_fp->readdir_data.file_attr =
+		le16_to_cpu(req_params->SearchAttributes);
+	ksmbd_update_fstate(&work->sess->file_table, dir_fp, FP_INITED);
+
+	if (params_count % 4)
+		data_alignment_offset = 4 - params_count % 4;
+
+	d_info.smb1_name = kmalloc(NAME_MAX + 1, GFP_KERNEL);
+	if (!d_info.smb1_name) {
+		rc = -ENOMEM;
+		goto err_out;
+	}
+	d_info.wptr = (char *)((char *)rsp + sizeof(struct smb_com_trans2_rsp) +
+			params_count + data_alignment_offset);
+
+	header_size = sizeof(struct smb_com_trans2_rsp) + params_count +
+		data_alignment_offset;
+
+
+	struct_sz = readdir_info_level_struct_sz(le16_to_cpu(req_params->InformationLevel));
+
+	if (struct_sz < 0) {
+		rc = -EFAULT;
+		goto err_out;
+	}
+
+	/* When search count is zero, respond only 1 entry. */
+	srch_cnt = le16_to_cpu(req_params->SearchCount);
+	if (!srch_cnt)
+		d_info.out_buf_len = struct_sz + header_size;
+	else
+		d_info.out_buf_len = min_t(int, srch_cnt * struct_sz + header_size,
+				MAX_CIFS_LOOKUP_BUFFER_SIZE - header_size);
+
+
+	/* reserve dot and dotdot entries in head of buffer in first response */
+	if (!*srch_ptr || is_asterisk(srch_ptr)) {
+		rc = ksmbd_populate_dot_dotdot_entries(work,
+				le16_to_cpu(req_params->InformationLevel),
+				dir_fp,
+				&d_info,
+				srch_ptr,
+				smb_populate_readdir_entry);
+		if (rc)
+			goto err_out;
+	}
+
+	do {
+		if (dir_fp->dirent_offset >= dir_fp->readdir_data.used) {
+			dir_fp->dirent_offset = 0;
+			dir_fp->readdir_data.used = 0;
+			rc = iterate_dir(dir_fp->filp,
+					 &dir_fp->readdir_data.ctx);
+			if (rc < 0) {
+				ksmbd_debug(SMB, "err : %d\n", rc);
+				goto err_out;
+			}
+
+			if (!dir_fp->readdir_data.used) {
+				free_page((unsigned long)
+						(dir_fp->readdir_data.dirent));
+				dir_fp->readdir_data.dirent = NULL;
+				break;
+			}
+
+			de = (struct ksmbd_dirent *)
+				((char *)dir_fp->readdir_data.dirent);
+		} else {
+			de = (struct ksmbd_dirent *)
+				((char *)dir_fp->readdir_data.dirent +
+				 dir_fp->dirent_offset);
+		}
+
+		reclen = ALIGN(sizeof(struct ksmbd_dirent) + de->namelen,
+			       sizeof(__le64));
+		dir_fp->dirent_offset += reclen;
+
+		if (dir_fp->readdir_data.file_attr &
+			SMB_SEARCH_ATTRIBUTE_DIRECTORY && de->d_type != DT_DIR)
+			continue;
+
+		ksmbd_kstat.kstat = &kstat;
+
+		if (de->namelen > NAME_MAX) {
+			pr_err("filename length exceeds 255 bytes.\n");
+			continue;
+		}
+
+		if (!strncmp(de->name, ".", de->namelen) ||
+		    !strncmp(de->name, "..", de->namelen))
+			continue;
+
+		memcpy(d_info.smb1_name, de->name, de->namelen);
+		d_info.smb1_name[de->namelen] = '\0';
+		d_info.name = (const char *)d_info.smb1_name;
+		d_info.name_len = de->namelen;
+		rc = ksmbd_vfs_readdir_name(work,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					    file_mnt_idmap(dir_fp->filp),
+#else
+					    file_mnt_user_ns(dir_fp->filp),
+#endif
+					    &ksmbd_kstat,
+					    de->name,
+					    de->namelen,
+					    dirpath);
+		if (rc) {
+			ksmbd_debug(SMB, "Cannot read dirent: %d\n", rc);
+			continue;
+		}
+
+		if (ksmbd_share_veto_filename(share, d_info.name)) {
+			ksmbd_debug(SMB, "Veto filename %s\n", d_info.name);
+			continue;
+		}
+
+		if (match_pattern(d_info.name, d_info.name_len, srch_ptr)) {
+			rc = smb_populate_readdir_entry(conn,
+				le16_to_cpu(req_params->InformationLevel),
+				&d_info,
+				&ksmbd_kstat);
+			if (rc == -ENOSPC)
+				break;
+			else if (rc)
+				goto err_out;
+		}
+	} while (d_info.out_buf_len >= 0);
+
+	if (!d_info.data_count && *srch_ptr) {
+		ksmbd_debug(SMB, "There is no entry matched with the search pattern\n");
+		rc = -ENOENT;
+		goto err_out;
+	}
+
+	if (d_info.out_buf_len < 0)
+		dir_fp->dirent_offset -= reclen;
+
+	params = (struct smb_com_trans2_ffirst_rsp_parms *)((char *)rsp +
+			sizeof(struct smb_com_trans2_rsp));
+	params->SearchHandle = dir_fp->volatile_id;
+	params->SearchCount = cpu_to_le16(d_info.num_entry);
+	params->LastNameOffset = cpu_to_le16(d_info.last_entry_offset);
+
+	if (d_info.out_buf_len < 0) {
+		ksmbd_debug(SMB, "continue search\n");
+		params->EndofSearch = cpu_to_le16(0);
+	} else {
+		ksmbd_debug(SMB, "end of search\n");
+		params->EndofSearch = cpu_to_le16(1);
+		path_put(&(dir_fp->filp->f_path));
+		if (le16_to_cpu(req_params->SearchFlags) &
+				CIFS_SEARCH_CLOSE_AT_END)
+			ksmbd_close_fd(work, dir_fp->volatile_id);
+	}
+	params->EAErrorOffset = cpu_to_le16(0);
+
+	rsp_hdr->WordCount = 0x0A;
+	rsp->t2.TotalParameterCount = cpu_to_le16(params_count);
+	rsp->t2.TotalDataCount = cpu_to_le16(d_info.data_count);
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = cpu_to_le16(params_count);
+	rsp->t2.ParameterOffset =
+		cpu_to_le16(sizeof(struct smb_com_trans2_rsp) - 4);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = cpu_to_le16(d_info.data_count);
+	rsp->t2.DataOffset = cpu_to_le16(sizeof(struct smb_com_trans2_rsp) +
+		params_count + data_alignment_offset - 4);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+	rsp->Pad = 0;
+	rsp->ByteCount = cpu_to_le16(d_info.data_count +
+		params_count + 1 /*pad*/ + data_alignment_offset);
+	memset((char *)rsp + sizeof(struct smb_com_trans2_rsp) + params_count,
+			'\0', 2);
+	inc_rfc1001_len(rsp_hdr, (10 * 2 + d_info.data_count +
+				params_count + 1 + data_alignment_offset));
+	kfree(srch_ptr);
+	kfree(d_info.smb1_name);
+	ksmbd_revert_fsids(work);
+	return 0;
+
+err_free_kernpath:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	path_put(&path);
+#endif
+err_free_dirpath:
+	kfree(dirpath);
+err_out:
+	if (rc == -EINVAL)
+		rsp_hdr->Status.CifsError = STATUS_INVALID_PARAMETER;
+	else if (rc == -EACCES || rc == -EXDEV)
+		rsp_hdr->Status.CifsError = STATUS_ACCESS_DENIED;
+	else if (rc == -ENOENT)
+		rsp_hdr->Status.CifsError = STATUS_NO_SUCH_FILE;
+	else if (rc == -EBADF)
+		rsp_hdr->Status.CifsError = STATUS_FILE_CLOSED;
+	else if (rc == -ENOMEM)
+		rsp_hdr->Status.CifsError = STATUS_NO_MEMORY;
+	else if (rc == -EFAULT)
+		rsp_hdr->Status.CifsError = STATUS_INVALID_LEVEL;
+	if (!rsp->hdr.Status.CifsError)
+		rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+
+	if (dir_fp) {
+		if (dir_fp->readdir_data.dirent) {
+			free_page((unsigned long)(dir_fp->readdir_data.dirent));
+			dir_fp->readdir_data.dirent = NULL;
+		}
+		path_put(&(dir_fp->filp->f_path));
+		ksmbd_close_fd(work, dir_fp->volatile_id);
+	}
+
+	kfree(srch_ptr);
+	kfree(d_info.smb1_name);
+	ksmbd_revert_fsids(work);
+	return 0;
+}
+
+/**
+ * find_next() - smb next readdir command
+ * @work:	smb work containing find next request params
+ *
+ * if directory has many entries, find first can't read it fully.
+ * find next might be called multiple times to read remaining dir entries
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int find_next(struct ksmbd_work *work)
+{
+	struct smb_hdr *rsp_hdr = work->response_buf;
+	struct ksmbd_conn *conn = work->conn;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct smb_com_trans2_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct smb_com_trans2_fnext_req_params *req_params;
+	struct smb_com_trans2_fnext_rsp_params *params = NULL;
+	struct ksmbd_dirent *de;
+	struct ksmbd_file *dir_fp;
+	struct kstat kstat;
+	struct ksmbd_kstat ksmbd_kstat;
+	struct ksmbd_dir_info d_info;
+	int params_count = sizeof(struct smb_com_trans2_fnext_rsp_params);
+	int data_alignment_offset = 0;
+	int rc = 0, reclen = 0;
+	__u16 sid;
+	int header_size, srch_cnt, struct_sz;
+
+	memset(&d_info, 0, sizeof(struct ksmbd_dir_info));
+
+	req_params = (struct smb_com_trans2_fnext_req_params *)
+		(work->request_buf + le16_to_cpu(req->ParameterOffset) + 4);
+	sid = req_params->SearchHandle;
+
+	dir_fp = ksmbd_lookup_fd_fast(work, sid);
+	if (!dir_fp) {
+		ksmbd_debug(SMB, "error invalid sid\n");
+		rc = -EINVAL;
+		goto err_out;
+	}
+
+	set_ctx_actor(&dir_fp->readdir_data.ctx, ksmbd_fill_dirent);
+
+	if (params_count % 4)
+		data_alignment_offset = 4 - params_count % 4;
+
+	d_info.smb1_name = kmalloc(NAME_MAX + 1, GFP_KERNEL);
+	if (!d_info.smb1_name) {
+		rc = -ENOMEM;
+		goto err_out;
+	}
+	d_info.wptr = (char *)((char *)rsp + sizeof(struct smb_com_trans2_rsp) +
+			params_count + data_alignment_offset);
+
+	header_size = sizeof(struct smb_com_trans2_rsp) + params_count +
+		data_alignment_offset;
+
+	srch_cnt = le16_to_cpu(req_params->SearchCount);
+	struct_sz = readdir_info_level_struct_sz(le16_to_cpu(req_params->InformationLevel));
+
+	if (struct_sz < 0) {
+		rc = -EFAULT;
+		goto err_out;
+	}
+
+	d_info.out_buf_len = min_t(int, srch_cnt * struct_sz + header_size,
+				   MAX_CIFS_LOOKUP_BUFFER_SIZE - header_size);
+	do {
+		if (dir_fp->dirent_offset >= dir_fp->readdir_data.used) {
+			dir_fp->dirent_offset = 0;
+			dir_fp->readdir_data.used = 0;
+			rc = iterate_dir(dir_fp->filp,
+					 &dir_fp->readdir_data.ctx);
+			if (rc < 0) {
+				ksmbd_debug(SMB, "err : %d\n", rc);
+				goto err_out;
+			}
+
+			if (!dir_fp->readdir_data.used) {
+				free_page((unsigned long)
+						(dir_fp->readdir_data.dirent));
+				dir_fp->readdir_data.dirent = NULL;
+				break;
+			}
+
+			de = (struct ksmbd_dirent *)
+				((char *)dir_fp->readdir_data.dirent);
+		} else {
+			de = (struct ksmbd_dirent *)
+				((char *)dir_fp->readdir_data.dirent +
+				 dir_fp->dirent_offset);
+		}
+
+		reclen = ALIGN(sizeof(struct ksmbd_dirent) + de->namelen,
+			       sizeof(__le64));
+		dir_fp->dirent_offset += reclen;
+
+		if (dir_fp->readdir_data.file_attr &
+			SMB_SEARCH_ATTRIBUTE_DIRECTORY && de->d_type != DT_DIR)
+			continue;
+
+		if (dir_fp->readdir_data.file_attr &
+			SMB_SEARCH_ATTRIBUTE_ARCHIVE && (de->d_type == DT_DIR ||
+			(!strcmp(de->name, ".") || !strcmp(de->name, ".."))))
+			continue;
+
+		ksmbd_kstat.kstat = &kstat;
+
+		if (de->namelen > NAME_MAX) {
+			pr_err("filename length exceeds 255 bytes.\n");
+			continue;
+		}
+		memcpy(d_info.smb1_name, de->name, de->namelen);
+		d_info.smb1_name[de->namelen] = '\0';
+		d_info.name = (const char *)d_info.smb1_name;
+		d_info.name_len = de->namelen;
+		rc = ksmbd_vfs_readdir_name(work,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					    file_mnt_idmap(dir_fp->filp),
+#else
+					    file_mnt_user_ns(dir_fp->filp),
+#endif
+					    &ksmbd_kstat,
+					    de->name,
+					    de->namelen,
+					    dir_fp->filename);
+		if (rc) {
+			ksmbd_debug(SMB, "Err while dirent read rc = %d\n", rc);
+			rc = 0;
+			continue;
+		}
+
+		if (ksmbd_share_veto_filename(share, d_info.name)) {
+			ksmbd_debug(SMB, "file(%s) is invisible by setting as veto file\n",
+				    d_info.name);
+			continue;
+		}
+
+		ksmbd_debug(SMB, "filename string = %.*s\n",
+				d_info.name_len, d_info.name);
+		ksmbd_debug(SMB, "filename string = %.*s\n", d_info.name_len,
+			    d_info.name);
+		rc = smb_populate_readdir_entry(conn,
+						le16_to_cpu(req_params->InformationLevel),
+						&d_info, &ksmbd_kstat);
+		if (rc == -ENOSPC)
+			break;
+		else if (rc)
+			goto err_out;
+
+	} while (d_info.out_buf_len >= 0);
+
+	if (d_info.out_buf_len < 0)
+		dir_fp->dirent_offset -= reclen;
+
+	params = (struct smb_com_trans2_fnext_rsp_params *)
+		((char *)rsp + sizeof(struct smb_com_trans_rsp));
+	params->SearchCount = cpu_to_le16(d_info.num_entry);
+
+	if (d_info.out_buf_len < 0) {
+		ksmbd_debug(SMB, "continue search\n");
+		params->EndofSearch = cpu_to_le16(0);
+		params->LastNameOffset = cpu_to_le16(d_info.last_entry_offset);
+	} else {
+		ksmbd_debug(SMB, "end of search\n");
+		params->EndofSearch = cpu_to_le16(1);
+		params->LastNameOffset = cpu_to_le16(0);
+		path_put(&(dir_fp->filp->f_path));
+		if (le16_to_cpu(req_params->SearchFlags) &
+				CIFS_SEARCH_CLOSE_AT_END)
+			ksmbd_close_fd(work, sid);
+	}
+	params->EAErrorOffset = cpu_to_le16(0);
+
+	rsp_hdr->WordCount = 0x0A;
+	rsp->t2.TotalParameterCount = cpu_to_le16(params_count);
+	rsp->t2.TotalDataCount = cpu_to_le16(d_info.data_count);
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = cpu_to_le16(params_count);
+	rsp->t2.ParameterOffset =
+		cpu_to_le16(sizeof(struct smb_com_trans_rsp) - 4);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = cpu_to_le16(d_info.data_count);
+	rsp->t2.DataOffset = cpu_to_le16(sizeof(struct smb_com_trans_rsp) +
+		params_count + data_alignment_offset - 4);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+	rsp->Pad = 0;
+	rsp->ByteCount = cpu_to_le16(d_info.data_count + params_count + 1 +
+		data_alignment_offset);
+	memset((char *)rsp + sizeof(struct smb_com_trans_rsp) +
+		params_count, '\0', data_alignment_offset);
+	inc_rfc1001_len(rsp_hdr, (10 * 2 + d_info.data_count +
+		params_count + 1 + data_alignment_offset));
+	kfree(d_info.smb1_name);
+	ksmbd_fd_put(work, dir_fp);
+	return 0;
+
+err_out:
+	if (rc == -EINVAL)
+		rsp_hdr->Status.CifsError = STATUS_INVALID_PARAMETER;
+	else if (rc == -EACCES || rc == -EXDEV)
+		rsp_hdr->Status.CifsError = STATUS_ACCESS_DENIED;
+	else if (rc == -ENOENT)
+		rsp_hdr->Status.CifsError = STATUS_NO_SUCH_FILE;
+	else if (rc == -EBADF)
+		rsp_hdr->Status.CifsError = STATUS_FILE_CLOSED;
+	else if (rc == -ENOMEM)
+		rsp_hdr->Status.CifsError = STATUS_NO_MEMORY;
+	else if (rc == -EFAULT)
+		rsp_hdr->Status.CifsError = STATUS_INVALID_LEVEL;
+	if (!rsp->hdr.Status.CifsError)
+		rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+
+	if (dir_fp) {
+		if (dir_fp->readdir_data.dirent) {
+			free_page((unsigned long)(dir_fp->readdir_data.dirent));
+			dir_fp->readdir_data.dirent = NULL;
+		}
+		path_put(&(dir_fp->filp->f_path));
+		ksmbd_close_fd(work, sid);
+	}
+
+	kfree(d_info.smb1_name);
+	return 0;
+}
+
+/**
+ * smb_set_alloc_size() - set file truncate method using trans2
+ *		set file info command - file allocation info level
+ * @work:	smb work containing set file info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_alloc_size(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_sfi_req *req;
+	struct smb_com_trans2_sfi_rsp *rsp;
+	struct file_allocation_info *allocinfo;
+	struct kstat stat;
+	struct ksmbd_file *fp = NULL;
+	loff_t newsize;
+	int err = 0;
+
+	req = (struct smb_com_trans2_sfi_req *)work->request_buf;
+	rsp = (struct smb_com_trans2_sfi_rsp *)work->response_buf;
+
+	allocinfo =  (struct file_allocation_info *)
+		(((char *) &req->hdr.Protocol) + le16_to_cpu(req->DataOffset));
+	newsize = le64_to_cpu(allocinfo->AllocationSize);
+
+	fp = ksmbd_lookup_fd_fast(work, req->Fid);
+	if (!fp) {
+		pr_err("failed to get filp for fid %u\n", req->Fid);
+		rsp->hdr.Status.CifsError = STATUS_FILE_CLOSED;
+		return -ENOENT;
+	}
+
+	err = ksmbd_vfs_getattr(&fp->filp->f_path, &stat);
+	if (err) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		ksmbd_fd_put(work, fp);
+		return err;
+	}
+
+	if (newsize == stat.size) /* nothing to do */
+		goto out;
+
+	/* Round up size */
+	if (alloc_roundup_size) {
+		newsize = div64_u64(newsize + alloc_roundup_size - 1,
+				    alloc_roundup_size);
+		newsize *= alloc_roundup_size;
+	}
+
+	err = ksmbd_vfs_truncate(work, fp, newsize);
+	if (err) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		ksmbd_fd_put(work, fp);
+		return err;
+	}
+
+out:
+	ksmbd_debug(SMB, "fid %u, truncated to newsize %llu\n", req->Fid,
+		    newsize);
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 3 pad (1 pad1 + 2 pad2)*/
+	rsp->ByteCount = cpu_to_le16(3);
+	rsp->Reserved2 = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+	ksmbd_fd_put(work, fp);
+
+	return 0;
+}
+
+/**
+ * smb_set_file_size_finfo() - set file truncate method using trans2
+ *		set file info command
+ * @work:	smb work containing set file info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_file_size_finfo(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_sfi_req *req;
+	struct smb_com_trans2_sfi_rsp *rsp;
+	struct file_end_of_file_info *eofinfo;
+	struct ksmbd_file *fp;
+	loff_t newsize;
+	int err = 0;
+
+	req = (struct smb_com_trans2_sfi_req *)work->request_buf;
+	rsp = (struct smb_com_trans2_sfi_rsp *)work->response_buf;
+
+	eofinfo =  (struct file_end_of_file_info *)
+		(((char *) &req->hdr.Protocol) + le16_to_cpu(req->DataOffset));
+
+	fp = ksmbd_lookup_fd_fast(work, req->Fid);
+	if (!fp) {
+		pr_err("failed to get filp for fid %u\n", req->Fid);
+		rsp->hdr.Status.CifsError = STATUS_FILE_CLOSED;
+		return -ENOENT;
+	}
+
+	newsize = le64_to_cpu(eofinfo->FileSize);
+	err = ksmbd_vfs_truncate(work, fp, newsize);
+	if (err) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		ksmbd_fd_put(work, fp);
+		return err;
+	}
+
+	ksmbd_debug(SMB, "fid %u, truncated to newsize %lld\n", req->Fid,
+		    newsize);
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 3 pad (1 pad1 + 2 pad2)*/
+	rsp->ByteCount = cpu_to_le16(3);
+	rsp->Reserved2 = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+	ksmbd_fd_put(work, fp);
+
+	return 0;
+}
+
+/**
+ * query_file_info_pipe() - query file info of IPC pipe
+ *		using query file info command
+ * @work:	smb work containing query file info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int query_file_info_pipe(struct ksmbd_work *work)
+{
+	struct smb_hdr *rsp_hdr = work->response_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct smb_com_trans2_req *req = work->request_buf;
+	struct smb_trans2_qfi_req_params *req_params;
+	struct file_standard_info *standard_info;
+	char *ptr;
+
+	req_params = (struct smb_trans2_qfi_req_params *)(work->request_buf +
+			le16_to_cpu(req->ParameterOffset) + 4);
+
+	if (le16_to_cpu(req_params->InformationLevel) !=
+	    SMB_QUERY_FILE_STANDARD_INFO) {
+		ksmbd_debug(SMB, "query file info for info %u not supported\n",
+				le16_to_cpu(req_params->InformationLevel));
+		rsp_hdr->Status.CifsError = STATUS_NOT_SUPPORTED;
+		return -EOPNOTSUPP;
+	}
+
+	ksmbd_debug(SMB, "SMB_QUERY_FILE_STANDARD_INFO\n");
+	rsp_hdr->WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = cpu_to_le16(sizeof(struct file_standard_info));
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = cpu_to_le16(2);
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = cpu_to_le16(sizeof(struct file_standard_info));
+	rsp->t2.DataOffset = cpu_to_le16(60);
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+	/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+	rsp->ByteCount = cpu_to_le16(2 + sizeof(struct file_standard_info) + 3);
+	rsp->Pad = 0;
+	/* lets set EA info */
+	ptr = (char *)&rsp->Pad + 1;
+	memset(ptr, 0, 4);
+	standard_info = (struct file_standard_info *)(ptr + 4);
+	standard_info->AllocationSize = cpu_to_le64(4096);
+	standard_info->EndOfFile = 0;
+	standard_info->NumberOfLinks = cpu_to_le32(1);
+	standard_info->DeletePending = 0;
+	standard_info->Directory = 0;
+	standard_info->DeletePending = 1;
+	inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+
+	return 0;
+}
+
+/**
+ * query_file_info() - query file info of file/dir
+ *		using query file info command
+ * @work:	smb work containing query file info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int query_file_info(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+	struct smb_hdr *rsp_hdr = work->response_buf;
+	struct smb_com_trans2_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct smb_trans2_qfi_req_params *req_params;
+	struct ksmbd_file *fp;
+	struct kstat st;
+	char *ptr;
+	int rc = 0;
+	u64 time;
+
+	req_params = (struct smb_trans2_qfi_req_params *)(work->request_buf +
+			le16_to_cpu(req->ParameterOffset) + 4);
+
+	if (test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_PIPE)) {
+		ksmbd_debug(SMB, "query file info for IPC srvsvc\n");
+		return query_file_info_pipe(work);
+	}
+
+	fp = ksmbd_lookup_fd_fast(work, req_params->Fid);
+	if (!fp) {
+		pr_err("failed to get filp for fid %u\n", req_params->Fid);
+		rsp_hdr->Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+		rc = -EIO;
+		goto err_out;
+	}
+
+	compat_generic_fillattr(&fp->filp->f_path, STATX_BASIC_STATS,
+				file_inode(fp->filp), &st);
+
+	switch (le16_to_cpu(req_params->InformationLevel)) {
+
+	case SMB_QUERY_FILE_STANDARD_INFO:
+	{
+		struct file_standard_info *standard_info;
+		unsigned int delete_pending;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_STANDARD_INFO\n");
+		delete_pending = ksmbd_inode_pending_delete(fp);
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount =
+			cpu_to_le16(sizeof(struct file_standard_info));
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount =
+			cpu_to_le16(sizeof(struct file_standard_info));
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount =
+			cpu_to_le16(2 + sizeof(struct file_standard_info) + 3);
+		rsp->Pad = 0;
+		/* lets set EA info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		standard_info = (struct file_standard_info *)(ptr + 4);
+		standard_info->AllocationSize = cpu_to_le64(st.blocks << 9);
+		standard_info->EndOfFile = cpu_to_le64(st.size);
+		standard_info->NumberOfLinks = cpu_to_le32(get_nlink(&st) -
+			delete_pending);
+		standard_info->DeletePending = delete_pending;
+		standard_info->Directory = S_ISDIR(st.mode) ? 1 : 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_BASIC_INFO:
+	{
+		struct file_basic_info *basic_info;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_BASIC_INFO\n");
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount =
+			cpu_to_le16(sizeof(struct file_basic_info));
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(sizeof(struct file_basic_info));
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount =
+			cpu_to_le16(2 + sizeof(struct file_basic_info) + 3);
+		rsp->Pad = 0;
+		/* lets set EA info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		basic_info = (struct file_basic_info *)(ptr + 4);
+		basic_info->CreationTime = cpu_to_le64(fp->create_time);
+		time = ksmbd_UnixTimeToNT(st.atime);
+		basic_info->LastAccessTime = cpu_to_le64(time);
+		time = ksmbd_UnixTimeToNT(st.mtime);
+		basic_info->LastWriteTime = cpu_to_le64(time);
+		time = ksmbd_UnixTimeToNT(st.ctime);
+		basic_info->ChangeTime = cpu_to_le64(time);
+		basic_info->Attributes = S_ISDIR(st.mode) ?
+			ATTR_DIRECTORY_LE : ATTR_ARCHIVE_LE;
+		basic_info->Pad = 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_EA_INFO:
+	{
+		struct file_ea_info *ea_info;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_EA_INFO\n");
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount =
+			cpu_to_le16(sizeof(struct file_ea_info));
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(sizeof(struct file_ea_info));
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount =
+			cpu_to_le16(2 + sizeof(struct file_ea_info) + 3);
+		rsp->Pad = 0;
+		/* lets set EA info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		ea_info = (struct file_ea_info *)(ptr + 4);
+		ea_info->EaSize = 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_UNIX_BASIC:
+	{
+		struct file_unix_basic_info *uinfo;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_UNIX_BASIC\n");
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount =
+			cpu_to_le16(sizeof(struct file_unix_basic_info));
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount =
+			cpu_to_le16(sizeof(struct file_unix_basic_info));
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount =
+			cpu_to_le16(2 + sizeof(struct file_unix_basic_info)
+				+ 3);
+		rsp->Pad = 0;
+		/* lets set unix info info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		uinfo = (struct file_unix_basic_info *)(ptr + 4);
+		init_unix_info(uinfo, &init_user_ns, &st);
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_NAME_INFO:
+	{
+		struct file_name_info *name_info;
+		int uni_filename_len;
+		char *filename;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_NAME_INFO\n");
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		name_info = (struct file_name_info *)(ptr + 4);
+
+		filename = convert_to_nt_pathname(work->tcon->share_conf,
+						  &fp->filp->f_path);
+		if (!filename) {
+			rc = -ENOMEM;
+			goto err_out;
+		}
+		uni_filename_len = smbConvertToUTF16(
+				(__le16 *)name_info->FileName,
+				filename, PATH_MAX,
+				conn->local_nls, 0);
+		kfree(filename);
+		uni_filename_len *= 2;
+		name_info->FileNameLength = cpu_to_le32(uni_filename_len);
+
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount = cpu_to_le16(uni_filename_len + 4);
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(uni_filename_len + 4);
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount = cpu_to_le16(2 + uni_filename_len + 4 + 3);
+		rsp->Pad = 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	case SMB_QUERY_FILE_ALL_INFO:
+	{
+		struct file_all_info *ainfo;
+		unsigned int delete_pending;
+
+		ksmbd_debug(SMB, "SMB_QUERY_FILE_ALL_INFO\n");
+		delete_pending = ksmbd_inode_pending_delete(fp);
+		rsp_hdr->WordCount = 10;
+		rsp->t2.TotalParameterCount = cpu_to_le16(2);
+		rsp->t2.TotalDataCount =
+			cpu_to_le16(sizeof(struct file_all_info));
+		rsp->t2.Reserved = 0;
+		rsp->t2.ParameterCount = cpu_to_le16(2);
+		rsp->t2.ParameterOffset = cpu_to_le16(56);
+		rsp->t2.ParameterDisplacement = 0;
+		rsp->t2.DataCount = cpu_to_le16(sizeof(struct file_all_info));
+		rsp->t2.DataOffset = cpu_to_le16(60);
+		rsp->t2.DataDisplacement = 0;
+		rsp->t2.SetupCount = 0;
+		rsp->t2.Reserved1 = 0;
+		/*2 for parameter count & 3 pad (1pad1 + 2 pad2)*/
+		rsp->ByteCount =
+			cpu_to_le16(2 + sizeof(struct file_all_info) + 3);
+		rsp->Pad = 0;
+		/* lets set all info info */
+		ptr = (char *)&rsp->Pad + 1;
+		memset(ptr, 0, 4);
+		ainfo = (struct file_all_info *)(ptr + 4);
+		ainfo->CreationTime = cpu_to_le64(fp->create_time);
+		time = ksmbd_UnixTimeToNT(st.atime);
+		ainfo->LastAccessTime = cpu_to_le64(time);
+		time = ksmbd_UnixTimeToNT(st.mtime);
+		ainfo->LastWriteTime = cpu_to_le64(time);
+		time = ksmbd_UnixTimeToNT(st.ctime);
+		ainfo->ChangeTime = cpu_to_le64(time);
+		ainfo->Attributes = cpu_to_le32(S_ISDIR(st.mode) ?
+				ATTR_DIRECTORY : ATTR_ARCHIVE);
+		ainfo->Pad1 = 0;
+		ainfo->AllocationSize = cpu_to_le64(st.blocks << 9);
+		ainfo->EndOfFile = cpu_to_le64(st.size);
+		ainfo->NumberOfLinks = cpu_to_le32(get_nlink(&st) -
+			delete_pending);
+		ainfo->DeletePending = delete_pending;
+		ainfo->Directory = S_ISDIR(st.mode) ? 1 : 0;
+		ainfo->Pad2 = 0;
+		ainfo->EASize = 0;
+		ainfo->FileNameLength = 0;
+		inc_rfc1001_len(rsp_hdr, 10 * 2 + le16_to_cpu(rsp->ByteCount));
+		break;
+	}
+	default:
+		pr_err("query path info not implemnted for %x\n",
+		       le16_to_cpu(req_params->InformationLevel));
+		rsp_hdr->Status.CifsError = STATUS_NOT_SUPPORTED;
+		rc = -EINVAL;
+		goto err_out;
+
+	}
+
+err_out:
+	ksmbd_fd_put(work, fp);
+	return rc;
+}
+
+/**
+ * smb_set_unix_fileinfo() - set smb unix file info(setattr)
+ * @work:	smb work containing unix basic info buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_unix_fileinfo(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_sfi_req *req = work->request_buf;
+	struct smb_com_trans2_sfi_rsp *rsp = work->response_buf;
+	struct file_unix_basic_info *unix_info;
+	struct ksmbd_file *fp;
+	struct iattr attrs;
+	int err = 0;
+
+	if (ksmbd_override_fsids(work))
+		return -ENOMEM;
+	fp = ksmbd_lookup_fd_fast(work, req->Fid);
+	if (!fp) {
+		ksmbd_revert_fsids(work);
+		return -ENOENT;
+	}
+
+	unix_info =  (struct file_unix_basic_info *)
+		(((char *) &req->hdr.Protocol) + le16_to_cpu(req->DataOffset));
+
+	attrs.ia_valid = 0;
+	attrs.ia_mode = 0;
+	err = unix_info_to_attr(unix_info, &init_user_ns, &attrs);
+	ksmbd_fd_put(work, fp);
+	ksmbd_revert_fsids(work);
+	if (err)
+		goto out;
+
+	err = ksmbd_vfs_setattr(work, NULL, (u64)req->Fid, &attrs);
+	if (err)
+		goto out;
+
+	/* setattr success, prepare response */
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 3 pad (1 pad1 + 2 pad2)*/
+	rsp->ByteCount = cpu_to_le16(3);
+	rsp->Reserved2 = 0;
+	inc_rfc1001_len(&rsp->hdr,
+			rsp->hdr.WordCount * 2 + le16_to_cpu(rsp->ByteCount));
+
+out:
+	if (err) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		return err;
+	}
+	return 0;
+}
+
+/**
+ * smb_set_disposition() - set file dispostion method using trans2
+ *		using set file info command
+ * @work:	smb work containing set file info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_disposition(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_sfi_req *req = work->request_buf;
+	struct smb_com_trans2_sfi_rsp *rsp = work->response_buf;
+	char *disp_info;
+	struct ksmbd_file *fp;
+	int ret = 0;
+
+	disp_info =  (char *) (((char *) &req->hdr.Protocol)
+			+ le16_to_cpu(req->DataOffset));
+
+	fp = ksmbd_lookup_fd_fast(work, req->Fid);
+	if (!fp) {
+		ksmbd_debug(SMB, "Invalid id for close: %d\n", req->Fid);
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		return -EINVAL;
+	}
+
+	if (*disp_info) {
+		if (!fp->is_nt_open) {
+			rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+			ret = -EPERM;
+			goto err_out;
+		}
+
+		if (!(file_inode(fp->filp)->i_mode & 0222)) {
+			rsp->hdr.Status.CifsError = STATUS_CANNOT_DELETE;
+			ret = -EPERM;
+			goto err_out;
+		}
+
+		if (S_ISDIR(file_inode(fp->filp)->i_mode) &&
+		    ksmbd_vfs_empty_dir(fp) == -ENOTEMPTY) {
+			rsp->hdr.Status.CifsError = STATUS_DIRECTORY_NOT_EMPTY;
+			ret = -ENOTEMPTY;
+			goto err_out;
+		}
+
+		ksmbd_set_inode_pending_delete(fp);
+	} else {
+		ksmbd_clear_inode_pending_delete(fp);
+	}
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 3 pad (1 pad1 + 2 pad2)*/
+	rsp->ByteCount = cpu_to_le16(3);
+	rsp->Reserved2 = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+
+err_out:
+	ksmbd_fd_put(work, fp);
+	return ret;
+}
+
+/**
+ * smb_set_time_fileinfo() - set file time method using trans2
+ *		using set file info command
+ * @work:	smb work containing set file info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_set_time_fileinfo(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_sfi_req *req;
+	struct smb_com_trans2_sfi_rsp *rsp;
+	struct file_basic_info *info;
+	struct iattr attrs;
+	int err = 0;
+
+	req = (struct smb_com_trans2_sfi_req *)work->request_buf;
+	rsp = (struct smb_com_trans2_sfi_rsp *)work->response_buf;
+
+	info = (struct file_basic_info *)(((char *) &req->hdr.Protocol) +
+			le16_to_cpu(req->DataOffset));
+
+	attrs.ia_valid = 0;
+	if (le64_to_cpu(info->LastAccessTime)) {
+		attrs.ia_atime = smb_NTtimeToUnix(info->LastAccessTime);
+		attrs.ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);
+	}
+
+	if (le64_to_cpu(info->ChangeTime)) {
+		attrs.ia_ctime = smb_NTtimeToUnix(info->ChangeTime);
+		attrs.ia_valid |= ATTR_CTIME;
+	}
+
+	if (le64_to_cpu(info->LastWriteTime)) {
+		attrs.ia_mtime = smb_NTtimeToUnix(info->LastWriteTime);
+		attrs.ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);
+	}
+	/* TODO: check dos mode and acl bits if req->Attributes nonzero */
+
+	if (!attrs.ia_valid)
+		goto done;
+
+	err = ksmbd_vfs_setattr(work, NULL, (u64)req->Fid, &attrs);
+	if (err) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		return err;
+	}
+
+done:
+	ksmbd_debug(SMB, "fid %u, setattr done\n", req->Fid);
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 3 pad (1 pad1 + 2 pad2)*/
+	rsp->ByteCount = cpu_to_le16(3);
+	rsp->Reserved2 = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+
+	return 0;
+}
+
+/**
+ * smb_fileinfo_rename() - rename method using trans2 set file info command
+ * @work:	smb work containing set file info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int smb_fileinfo_rename(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_sfi_req *req;
+	struct smb_com_trans2_sfi_rsp *rsp;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct set_file_rename *info;
+	struct ksmbd_file *fp;
+	char *newname;
+	int rc = 0;
+
+	req = (struct smb_com_trans2_sfi_req *)work->request_buf;
+	rsp = (struct smb_com_trans2_sfi_rsp *)work->response_buf;
+	info =  (struct set_file_rename *)
+		(((char *) &req->hdr.Protocol) + le16_to_cpu(req->DataOffset));
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		ksmbd_debug(SMB,
+			"returning as user does not have permission to write\n");
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		return -EACCES;
+	}
+
+	fp = ksmbd_lookup_fd_fast(work, req->Fid);
+	if (!fp) {
+		pr_err("failed to get filp for fid %u\n", req->Fid);
+		rsp->hdr.Status.CifsError = STATUS_FILE_CLOSED;
+		return -ENOENT;
+	}
+
+	if (info->overwrite) {
+		rc = ksmbd_vfs_truncate(work, fp, 0);
+		if (rc) {
+			rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+			ksmbd_fd_put(work, fp);
+			return rc;
+		}
+	}
+
+	newname = smb_get_name(share, info->target_name, PATH_MAX, work, 0);
+	if (IS_ERR(newname)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		ksmbd_fd_put(work, fp);
+		return PTR_ERR(newname);
+	}
+
+	ksmbd_debug(SMB, "new name(%s)\n", newname);
+	rc = ksmbd_vfs_fp_rename(work, fp, newname);
+	if (rc) {
+		rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+		goto out;
+	}
+
+	rsp->hdr.WordCount = 10;
+	rsp->t2.TotalParameterCount = cpu_to_le16(2);
+	rsp->t2.TotalDataCount = 0;
+	rsp->t2.Reserved = 0;
+	rsp->t2.ParameterCount = rsp->t2.TotalParameterCount;
+	rsp->t2.ParameterOffset = cpu_to_le16(56);
+	rsp->t2.ParameterDisplacement = 0;
+	rsp->t2.DataCount = rsp->t2.TotalDataCount;
+	rsp->t2.DataOffset = 0;
+	rsp->t2.DataDisplacement = 0;
+	rsp->t2.SetupCount = 0;
+	rsp->t2.Reserved1 = 0;
+
+	/* 3 pad (1 pad1 + 2 pad2)*/
+	rsp->ByteCount = cpu_to_le16(3);
+	rsp->Reserved2 = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2 + 3);
+
+out:
+	ksmbd_fd_put(work, fp);
+	kfree(newname);
+	return rc;
+}
+
+/**
+ * set_file_info() - trans2 set file info command dispatcher
+ * @work:	smb work containing set file info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+static int set_file_info(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_sfi_req *req;
+	struct smb_com_trans2_sfi_rsp *rsp;
+	__u16 info_level, total_param;
+	int err = 0;
+
+	req = (struct smb_com_trans2_sfi_req *)work->request_buf;
+	rsp = (struct smb_com_trans2_sfi_rsp *)work->response_buf;
+	info_level = le16_to_cpu(req->InformationLevel);
+	total_param = le16_to_cpu(req->TotalParameterCount);
+	if (total_param < 4) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		pr_err("invalid total parameter for info_level 0x%x\n",
+		       total_param);
+		return -EINVAL;
+	}
+
+	switch (info_level) {
+	case SMB_SET_FILE_EA:
+		err = smb_set_ea(work);
+		break;
+	case SMB_SET_FILE_ALLOCATION_INFO2:
+		/* fall through */
+	case SMB_SET_FILE_ALLOCATION_INFO:
+		err = smb_set_alloc_size(work);
+		break;
+	case SMB_SET_FILE_END_OF_FILE_INFO2:
+		/* fall through */
+	case SMB_SET_FILE_END_OF_FILE_INFO:
+		err = smb_set_file_size_finfo(work);
+		break;
+	case SMB_SET_FILE_UNIX_BASIC:
+		err = smb_set_unix_fileinfo(work);
+		break;
+	case SMB_SET_FILE_DISPOSITION_INFO:
+	case SMB_SET_FILE_DISPOSITION_INFORMATION:
+		err = smb_set_disposition(work);
+		break;
+	case SMB_SET_FILE_BASIC_INFO2:
+		/* fall through */
+	case SMB_SET_FILE_BASIC_INFO:
+		err = smb_set_time_fileinfo(work);
+		break;
+	case SMB_SET_FILE_RENAME_INFORMATION:
+		err = smb_fileinfo_rename(work);
+		break;
+	default:
+		ksmbd_debug(SMB, "info level = %x not implemented yet\n",
+			    info_level);
+		rsp->hdr.Status.CifsError = STATUS_NOT_IMPLEMENTED;
+		return -EOPNOTSUPP;
+	}
+
+	if (err < 0)
+		ksmbd_debug(SMB, "info_level 0x%x failed, err %d\n", info_level,
+			    err);
+	return err;
+}
+
+/*
+ * helper to create a directory and set DOS attrs
+ */
+static int smb_common_mkdir(struct ksmbd_work *work, char *name, mode_t mode)
+{
+	struct smb_hdr *rsp = work->response_buf;
+	int err;
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		ksmbd_debug(SMB,
+			"returning as user does not have permission to write\n");
+		rsp->Status.CifsError = STATUS_ACCESS_DENIED;
+		return -EACCES;
+	}
+
+	if (ksmbd_override_fsids(work)) {
+		rsp->Status.CifsError = STATUS_NO_MEMORY;
+		return -ENOMEM;
+	}
+
+	err = ksmbd_vfs_mkdir(work, name, mode);
+	if (err) {
+		if (err == -EEXIST) {
+			if (!(rsp->Flags2 & SMBFLG2_ERR_STATUS)) {
+				rsp->Status.DosError.ErrorClass = ERRDOS;
+				rsp->Status.DosError.Error =
+					cpu_to_le16(ERRnoaccess);
+			} else
+				rsp->Status.CifsError =
+					STATUS_OBJECT_NAME_COLLISION;
+		} else
+			rsp->Status.CifsError = STATUS_DATA_ERROR;
+		goto out;
+	}
+
+	if (test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
+		__u64 ctime;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+		struct path path, parent_path;
+#else
+		struct path path;
+#endif
+		struct xattr_dos_attrib da = {0};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+		err = ksmbd_vfs_kern_path_locked(work, name, 0,
+						 &parent_path, &path, 1);
+#else
+		err = ksmbd_vfs_kern_path(work, name, 0, &path, 1);
+#endif
+		if (!err) {
+			ctime = ksmbd_UnixTimeToNT(current_time(d_inode(path.dentry)));
+
+			da.version = 4;
+			da.attr = ATTR_DIRECTORY;
+			da.itime = da.create_time = ctime;
+			da.flags = XATTR_DOSINFO_ATTRIB |
+				   XATTR_DOSINFO_CREATE_TIME |
+				   XATTR_DOSINFO_ITIME;
+
+			err = compat_ksmbd_vfs_set_dos_attrib_xattr(&path, &da, false);
+			if (err)
+				ksmbd_debug(SMB, "failed to store creation time in xattr\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+			ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+			path_put(&path);
+#endif
+		}
+		err = 0;
+	}
+
+	rsp->Status.CifsError = STATUS_SUCCESS;
+	rsp->WordCount = 0;
+
+out:
+	ksmbd_revert_fsids(work);
+
+	return err;
+}
+
+/**
+ * create_dir() - trans2 create directory dispatcher
+ * @work:   smb work containing set file info command buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+static int create_dir(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_req *req = work->request_buf;
+	struct smb_com_trans2_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	mode_t mode = S_IALLUGO;
+	char *name;
+	int err;
+
+	name = smb_get_name(share, work->request_buf +
+			    le16_to_cpu(req->ParameterOffset) + 4,
+			    PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+
+	err = smb_common_mkdir(work, name, mode);
+
+	rsp->ByteCount = 0;
+	kfree(name);
+
+	return err;
+}
+
+/**
+ * smb_trans2() - handler for trans2 commands
+ * @work:	smb work containing trans2 command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_trans2(struct ksmbd_work *work)
+{
+	struct smb_com_trans2_req *req = work->request_buf;
+	struct smb_hdr *rsp_hdr = work->response_buf;
+	int err = 0;
+	u16 sub_command = le16_to_cpu(req->SubCommand);
+
+	/* at least one setup word for TRANS2 command
+	 *		MS-CIFS, SMB COM TRANSACTION
+	 */
+	if (req->SetupCount < 1) {
+		pr_err("Wrong setup count in SMB_TRANS2 - indicates wrong request\n");
+		rsp_hdr->Status.CifsError = STATUS_UNSUCCESSFUL;
+		return -EINVAL;
+	}
+
+	ksmbd_debug(SMB, "processing trans2 subcommand: %s\n",
+		    smb_trans2_cmd_to_str(sub_command));
+	switch (sub_command) {
+	case TRANS2_FIND_FIRST:
+		err = find_first(work);
+		break;
+	case TRANS2_FIND_NEXT:
+		err = find_next(work);
+		break;
+	case TRANS2_QUERY_FS_INFORMATION:
+		err = query_fs_info(work);
+		break;
+	case TRANS2_QUERY_PATH_INFORMATION:
+		err = query_path_info(work);
+		break;
+	case TRANS2_SET_PATH_INFORMATION:
+		err = set_path_info(work);
+		break;
+	case TRANS2_SET_FS_INFORMATION:
+		err = set_fs_info(work);
+		break;
+	case TRANS2_QUERY_FILE_INFORMATION:
+		err = query_file_info(work);
+		break;
+	case TRANS2_SET_FILE_INFORMATION:
+		err = set_file_info(work);
+		break;
+	case TRANS2_CREATE_DIRECTORY:
+		err = create_dir(work);
+		break;
+	case TRANS2_GET_DFS_REFERRAL:
+	default:
+		ksmbd_debug(SMB, "sub command 0x%x not implemented yet\n",
+			    sub_command);
+		err = -EINVAL;
+	}
+
+	if (err) {
+		switch (err) {
+		case -EINVAL:
+			rsp_hdr->Status.CifsError = STATUS_NOT_SUPPORTED;
+			break;
+		case -ENOMEM:
+			rsp_hdr->Status.CifsError = STATUS_NO_MEMORY;
+			break;
+		case -ENOENT:
+			rsp_hdr->Status.CifsError = STATUS_NO_SUCH_FILE;
+			break;
+		case -EBUSY:
+			rsp_hdr->Status.CifsError = STATUS_DELETE_PENDING;
+			break;
+		case -EACCES:
+		case -EXDEV:
+			rsp_hdr->Status.CifsError = STATUS_ACCESS_DENIED;
+			break;
+		case -EBADF:
+			rsp_hdr->Status.CifsError = STATUS_FILE_CLOSED;
+			break;
+		case -EFAULT:
+			rsp_hdr->Status.CifsError = STATUS_INVALID_LEVEL;
+			break;
+		case -EOPNOTSUPP:
+			rsp_hdr->Status.CifsError = STATUS_NOT_IMPLEMENTED;
+			break;
+		case -EIO:
+			rsp_hdr->Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+			break;
+		}
+
+		ksmbd_debug(SMB, "%s failed with error %d\n", __func__, err);
+	}
+
+	return err;
+}
+
+/**
+ * smb_mkdir() - handler for smb mkdir
+ * @work:	smb work containing creat directory command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_mkdir(struct ksmbd_work *work)
+{
+	struct smb_com_create_directory_req *req = work->request_buf;
+	struct smb_com_create_directory_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	mode_t mode = S_IALLUGO;
+	char *name;
+	int err;
+
+	name = smb_get_name(share, req->DirName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+
+	err = smb_common_mkdir(work, name, mode);
+
+	rsp->ByteCount = 0;
+	kfree(name);
+
+	return err;
+}
+
+/**
+ * smb_checkdir() - handler to verify whether a specified
+ * path resolves to a valid directory or not
+ *
+ * @work:   smb work containing creat directory command buffer
+ *
+ * Return:      0 on success, otherwise error
+ */
+int smb_checkdir(struct ksmbd_work *work)
+{
+	struct smb_com_check_directory_req *req = work->request_buf;
+	struct smb_com_check_directory_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	struct path path, parent_path;
+#else
+	struct path path;
+#endif
+	struct kstat stat;
+	char *name, *last;
+	int err;
+	bool caseless_lookup = req->hdr.Flags & SMBFLG_CASELESS;
+
+	name = smb_get_name(share, req->DirName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	err = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					 &parent_path, &path, caseless_lookup);
+#else
+	err = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path,
+				  caseless_lookup);
+#endif
+	if (err) {
+		if (err == -ENOENT) {
+			/*
+			 * If the parent directory is valid but not the
+			 * last component - then returns
+			 * STATUS_OBJECT_NAME_NOT_FOUND
+			 * for that case and STATUS_OBJECT_PATH_NOT_FOUND
+			 * if the path is invalid.
+			 */
+			last = strrchr(name, '/');
+			if (last && last[1] != '\0') {
+				*last = '\0';
+				last++;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+				err = ksmbd_vfs_kern_path_locked(work, name,
+						LOOKUP_FOLLOW | LOOKUP_DIRECTORY,
+						&parent_path, &path,
+						caseless_lookup);
+#else
+				err = ksmbd_vfs_kern_path(work, name, LOOKUP_FOLLOW |
+						LOOKUP_DIRECTORY, &path,
+						caseless_lookup);
+#endif
+			} else {
+				ksmbd_debug(SMB, "can't lookup parent %s\n",
+					name);
+				err = -ENOENT;
+			}
+		}
+		if (err) {
+			ksmbd_debug(SMB, "look up failed err %d\n", err);
+			switch (err) {
+			case -ENOENT:
+				rsp->hdr.Status.CifsError =
+					STATUS_OBJECT_NAME_NOT_FOUND;
+				break;
+			case -ENOMEM:
+				rsp->hdr.Status.CifsError =
+					STATUS_INSUFFICIENT_RESOURCES;
+				break;
+			case -EACCES:
+				rsp->hdr.Status.CifsError =
+					STATUS_ACCESS_DENIED;
+				break;
+			case -EIO:
+				rsp->hdr.Status.CifsError = STATUS_DATA_ERROR;
+				break;
+			default:
+				rsp->hdr.Status.CifsError =
+					STATUS_OBJECT_PATH_SYNTAX_BAD;
+				break;
+			}
+			kfree(name);
+			return err;
+		}
+	}
+
+	compat_generic_fillattr(&path, STATX_BASIC_STATS,
+				d_inode(path.dentry), &stat);
+
+	if (!S_ISDIR(stat.mode)) {
+		rsp->hdr.Status.CifsError = STATUS_NOT_A_DIRECTORY;
+	} else {
+		/* checkdir success, return response to server */
+		rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+		rsp->hdr.WordCount = 0;
+		rsp->ByteCount = 0;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	path_put(&path);
+#endif
+	kfree(name);
+	return err;
+}
+
+/**
+ * smb_process_exit() - handler for smb process exit
+ * @work:	smb work containing process exit command buffer
+ *
+ * Return:	0 on success always
+ * This command is obsolete now. Starting with the LAN Manager 1.0 dialect,
+ * FIDs are no longer associated with PIDs.CIFS clients SHOULD NOT send
+ * SMB_COM_PROCESS_EXIT requests. Instead, CIFS clients SHOULD perform all
+ * process cleanup operations, sending individual file close operations
+ * as needed.Here it is implemented very minimally for sake
+ * of passing smbtorture testcases.
+ */
+int smb_process_exit(struct ksmbd_work *work)
+{
+	struct smb_com_process_exit_rsp *rsp = work->response_buf;
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 0;
+	rsp->ByteCount = 0;
+	return 0;
+}
+
+/**
+ * smb_rmdir() - handler for smb rmdir
+ * @work:	smb work containing delete directory command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_rmdir(struct ksmbd_work *work)
+{
+	struct smb_com_delete_directory_req *req = work->request_buf;
+	struct smb_com_delete_directory_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	struct path path, parent_path;
+#endif
+	char *name;
+	int err;
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		ksmbd_debug(SMB,
+			"returning as user does not have permission to write\n");
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		return -EACCES;
+	}
+
+	name = smb_get_name(share, req->DirName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	err = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					 &parent_path, &path, 0);
+	if (err < 0) {
+		kfree(name);
+		return err;
+	}
+
+	err = ksmbd_vfs_remove_file(work, &path);
+
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	err = ksmbd_vfs_remove_file(work, name);
+#endif
+	if (err) {
+		if (err == -ENOTEMPTY)
+			rsp->hdr.Status.CifsError = STATUS_DIRECTORY_NOT_EMPTY;
+		else if (err == -ENOENT)
+			rsp->hdr.Status.CifsError =
+				STATUS_OBJECT_NAME_NOT_FOUND;
+		else
+			rsp->hdr.Status.CifsError = STATUS_DATA_ERROR;
+	} else {
+		/* rmdir success, return response to server */
+		rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+		rsp->hdr.WordCount = 0;
+		rsp->ByteCount = 0;
+	}
+
+	kfree(name);
+	return err;
+}
+
+/**
+ * smb_unlink() - handler for smb delete file
+ * @work:	smb work containing delete file command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_unlink(struct ksmbd_work *work)
+{
+	struct smb_com_delete_file_req *req = work->request_buf;
+	struct smb_com_delete_file_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	char *name;
+	int err;
+	struct ksmbd_file *fp;
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		ksmbd_debug(SMB,
+			"returning as user does not have permission to write\n");
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		return -EACCES;
+	}
+
+	name = smb_get_name(share, req->fileName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+
+	fp = ksmbd_lookup_fd_filename(work, name);
+	if (fp)
+		err = -ESHARE;
+	else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+		struct path path, parent_path;
+
+		err = ksmbd_vfs_kern_path_locked(work, name,
+						 LOOKUP_NO_SYMLINKS,
+						 &parent_path, &path, 0);
+		if (!err) {
+			err = ksmbd_vfs_remove_file(work, &path);
+			ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+		}
+#else
+		err = ksmbd_vfs_remove_file(work, name);
+#endif
+	}
+
+	if (err) {
+		if (err == -EISDIR)
+			rsp->hdr.Status.CifsError = STATUS_FILE_IS_A_DIRECTORY;
+		else if (err == -ESHARE)
+			rsp->hdr.Status.CifsError = STATUS_SHARING_VIOLATION;
+		else if (err == -EACCES || err == -EXDEV)
+			rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		else
+			rsp->hdr.Status.CifsError =
+				STATUS_OBJECT_NAME_NOT_FOUND;
+	} else {
+		rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+		rsp->hdr.WordCount = 0;
+		rsp->ByteCount = 0;
+	}
+
+	ksmbd_fd_put(work, fp);
+	kfree(name);
+	return err;
+}
+
+/**
+ * smb_nt_cancel() - handler for smb cancel command
+ * @work:	smb work containing cancel command buffer
+ *
+ * Return:	0
+ */
+int smb_nt_cancel(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+	struct smb_hdr *hdr = (struct smb_hdr *)work->request_buf;
+	struct smb_hdr *work_hdr;
+	struct ksmbd_work *new_work;
+
+	ksmbd_debug(SMB, "smb cancel called on mid %u\n", hdr->Mid);
+
+	spin_lock(&conn->request_lock);
+	list_for_each_entry(new_work, &conn->requests, request_entry) {
+		work_hdr = (struct smb_hdr *)new_work->request_buf;
+		if (work_hdr->Mid == hdr->Mid) {
+			ksmbd_debug(SMB, "smb with mid %u cancelled command = 0x%x\n",
+			       hdr->Mid, work_hdr->Command);
+			new_work->send_no_response = 1;
+			list_del_init(&new_work->request_entry);
+			new_work->sess->sequence_number--;
+			break;
+		}
+	}
+	spin_unlock(&conn->request_lock);
+
+	/* For SMB_COM_NT_CANCEL command itself send no response */
+	work->send_no_response = 1;
+	return 0;
+}
+
+/**
+ * smb_nt_rename() - handler for smb rename command
+ * @work:	smb work containing nt rename command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_nt_rename(struct ksmbd_work *work)
+{
+	struct smb_com_nt_rename_req *req = work->request_buf;
+	struct smb_com_rename_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	char *oldname, *newname;
+	int oldname_len, err;
+
+	if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) {
+		ksmbd_debug(SMB,
+			"returning as user does not have permission to write\n");
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		return -EACCES;
+	}
+
+	if (le16_to_cpu(req->Flags) != CREATE_HARD_LINK) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		return -EINVAL;
+	}
+
+	oldname = smb_get_name(share, req->OldFileName, PATH_MAX, work, false);
+	if (IS_ERR(oldname)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(oldname);
+	}
+
+	if (is_smbreq_unicode(&req->hdr))
+		oldname_len = smb1_utf16_name_length((__le16 *)req->OldFileName,
+						     PATH_MAX);
+	else {
+		oldname_len = strlen(oldname);
+		oldname_len++;
+	}
+
+	newname = smb_get_name(share, &req->OldFileName[oldname_len + 2],
+			       PATH_MAX, work, false);
+	if (IS_ERR(newname)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		kfree(oldname);
+		return PTR_ERR(newname);
+	}
+	ksmbd_debug(SMB, "oldname %s, newname %s, oldname_len %d, unicode %d\n",
+		    oldname, newname, oldname_len,
+		    is_smbreq_unicode(&req->hdr));
+
+	err = ksmbd_vfs_link(work, oldname, newname);
+	if (err == -EACCES)
+		rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+	else if (err < 0)
+		rsp->hdr.Status.CifsError = STATUS_NOT_SAME_DEVICE;
+
+	kfree(newname);
+	kfree(oldname);
+	return err;
+}
+
+static __le32 smb_query_info_pipe(struct ksmbd_share_config *share,
+				  struct kstat *st)
+{
+	st->mode = S_IFDIR;
+	return 0;
+}
+
+static __le32 smb_query_info_path(struct ksmbd_work *work, struct kstat *st)
+{
+	struct smb_com_query_information_req *req = work->request_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	struct path path, parent_path;
+#else
+	struct path path;
+#endif
+	char *name;
+	__le32 err = 0;
+	int ret;
+
+	name = smb_get_name(share, req->FileName, PATH_MAX, work, false);
+	if (IS_ERR(name))
+		return STATUS_OBJECT_NAME_INVALID;
+
+	if (ksmbd_override_fsids(work)) {
+		kfree(name);
+		return STATUS_NO_MEMORY;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ret = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					 &parent_path, &path, 0);
+#else
+	ret = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, 0);
+#endif
+	if (ret) {
+		pr_err("look up failed err %d\n", ret);
+
+		if (d_is_symlink(path.dentry)) {
+			err = STATUS_ACCESS_DENIED;
+			goto out;
+		}
+		err = STATUS_OBJECT_NAME_NOT_FOUND;
+		goto out;
+	}
+
+	compat_generic_fillattr(&path, STATX_BASIC_STATS,
+				d_inode(path.dentry), st);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	path_put(&path);
+#endif
+out:
+	ksmbd_revert_fsids(work);
+	kfree(name);
+	return err;
+}
+
+/**
+ * smb_query_info() - handler for query information command
+ * @work:	smb work containing query info command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_query_info(struct ksmbd_work *work)
+{
+	struct smb_com_query_information_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct kstat st = {0,};
+	__u16 attr = 0;
+	int i;
+	__le32 err;
+
+	if (!test_share_config_flag(work->tcon->share_conf,
+				    KSMBD_SHARE_FLAG_PIPE))
+		err = smb_query_info_path(work, &st);
+	else
+		err = smb_query_info_pipe(share, &st);
+
+	if (le32_to_cpu(err) != 0) {
+		rsp->hdr.Status.CifsError = err;
+		return -EINVAL;
+	}
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 10;
+
+	if (st.mode & S_ISVTX)
+		attr |= (ATTR_HIDDEN | ATTR_SYSTEM);
+	if (!(st.mode & 0222))
+		attr |= ATTR_READONLY;
+	if (S_ISDIR(st.mode))
+		attr |= ATTR_DIRECTORY;
+
+	rsp->attr = cpu_to_le16(attr);
+	rsp->last_write_time = cpu_to_le32(st.mtime.tv_sec);
+	rsp->size = cpu_to_le32((u32)st.size);
+	for (i = 0; i < 5; i++)
+		rsp->reserved[i] = 0;
+
+	rsp->ByteCount = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2);
+	return 0;
+}
+
+/**
+ * smb_closedir() - handler closing dir handle, opened for readdir
+ * @work:	smb work containing find close command buffer
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_closedir(struct ksmbd_work *work)
+{
+	struct smb_com_findclose_req *req = work->request_buf;
+	struct smb_com_close_rsp *rsp = work->response_buf;
+	int err;
+
+	ksmbd_debug(SMB, "SMB_COM_FIND_CLOSE2 called for fid %u\n",
+		    req->FileID);
+
+	rsp->hdr.WordCount = 0;
+	rsp->ByteCount = 0;
+
+	err = ksmbd_close_fd(work, req->FileID);
+	if (!err)
+		rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	else
+		rsp->hdr.Status.CifsError = STATUS_INVALID_HANDLE;
+	return err;
+}
+
+/**
+ * convert_open_flags() - convert smb open flags to file open flags
+ * @file_present:	is file already present
+ * @mode:		smp file open mode
+ * @disposition:	smp file disposition information
+ *
+ * Return:	converted file open flags
+ */
+static int convert_open_flags(bool file_present,
+			      __u16 mode, __u16 dispostion,
+			      int *may_flags)
+{
+	int oflags = 0;
+
+	switch (mode & 0x0007) {
+	case SMBOPEN_READ:
+		oflags |= O_RDONLY;
+		break;
+	case SMBOPEN_WRITE:
+		oflags |= O_WRONLY;
+		break;
+	case SMBOPEN_READWRITE:
+		oflags |= O_RDWR;
+		break;
+	default:
+		oflags |= O_RDONLY;
+		break;
+	}
+
+	if (mode & SMBOPEN_WRITE_THROUGH)
+		oflags |= O_SYNC;
+
+	if (file_present) {
+		switch (dispostion & 0x0003) {
+		case SMBOPEN_DISPOSITION_NONE:
+			return -EEXIST;
+		case SMBOPEN_OAPPEND:
+			oflags |= O_APPEND;
+			break;
+		case SMBOPEN_OTRUNC:
+			oflags |= O_TRUNC;
+			break;
+		default:
+			break;
+		}
+	} else {
+		switch (dispostion & 0x0010) {
+		case SMBOPEN_DISPOSITION_NONE:
+			return -EINVAL;
+		case SMBOPEN_OCREATE:
+			oflags |= O_CREAT;
+			break;
+		default:
+			break;
+		}
+	}
+
+	*may_flags = ksmbd_openflags_to_mayflags(oflags);
+
+	return oflags;
+}
+
+/**
+ * smb_open_andx() - smb andx open method handler
+ * @work:	smb work containing buffer for andx open command buffer
+ *
+ * Return:	error if there is error while processing current command,
+ *		otherwise pointer to next andx command in the chain
+ */
+int smb_open_andx(struct ksmbd_work *work)
+{
+	struct smb_com_openx_req *req = work->request_buf;
+	struct smb_com_openx_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct path path, parent_path;
+	struct kstat stat;
+	int oplock_flags, file_info, open_flags, may_flags;
+	char *name;
+	bool file_present = true;
+	umode_t mode = 0;
+	int err;
+	struct ksmbd_file *fp = NULL;
+	int oplock_rsp = OPLOCK_NONE, share_ret;
+
+	rsp->hdr.Status.CifsError = STATUS_UNSUCCESSFUL;
+
+	/* check for sharing mode flag */
+	if ((le16_to_cpu(req->Mode) & SMBOPEN_SHARING_MODE) >
+			SMBOPEN_DENY_NONE) {
+		rsp->hdr.Status.DosError.ErrorClass = ERRDOS;
+		rsp->hdr.Status.DosError.Error = cpu_to_le16(ERRbadaccess);
+		rsp->hdr.Flags2 &= ~SMBFLG2_ERR_STATUS;
+
+		memset(&rsp->hdr.WordCount, 0, 3);
+		return -EINVAL;
+	}
+
+	if (is_smbreq_unicode(&req->hdr))
+		name = smb_get_name(share, req->fileName + 1, PATH_MAX, work,
+				    false);
+	else
+		name = smb_get_name(share, req->fileName, PATH_MAX, work,
+				    false);
+
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+
+	if (ksmbd_override_fsids(work)) {
+		kfree(name);
+		rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+		return -ENOMEM;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	err = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					 &parent_path, &path,
+					 req->hdr.Flags & SMBFLG_CASELESS);
+#else
+	err = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path,
+				  req->hdr.Flags & SMBFLG_CASELESS);
+#endif
+	if (err) {
+		if (err == -EACCES || err == -EXDEV)
+			goto out;
+		file_present = false;
+	} else
+		compat_generic_fillattr(&path, STATX_BASIC_STATS,
+					d_inode(path.dentry), &stat);
+
+	oplock_flags =
+		le16_to_cpu(req->OpenFlags) & (REQ_OPLOCK | REQ_BATCHOPLOCK);
+
+	open_flags = convert_open_flags(file_present,
+					le16_to_cpu(req->Mode),
+					le16_to_cpu(req->OpenFunction),
+					&may_flags);
+	if (open_flags < 0) {
+		ksmbd_debug(SMB, "create_dispostion returned %d\n", open_flags);
+		if (file_present)
+			goto free_path;
+		else {
+			err = -ENOENT;
+			goto out;
+		}
+	}
+
+	if (file_present && !(stat.mode & 0222)) {
+		if ((open_flags & O_ACCMODE) == O_WRONLY ||
+		    (open_flags & O_ACCMODE) == O_RDWR) {
+			ksmbd_debug(SMB, "readonly file(%s)\n", name);
+			rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+			memset(&rsp->hdr.WordCount, 0, 3);
+			goto free_path;
+		}
+	}
+
+	if (!file_present && (open_flags & O_CREAT)) {
+		mode |= 0777;
+		if (le16_to_cpu(req->FileAttributes) & ATTR_READONLY)
+			mode &= ~0222;
+
+		mode |= S_IFREG;
+		err = smb_common_create(work, &parent_path, &path, name,
+					open_flags, mode, false);
+		if (err) {
+			ksmbd_debug(SMB, "smb_common_create err: %d\n", err);
+			goto out;
+		}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		generic_fillattr(mnt_idmap(path.mnt), d_inode(path.dentry), &stat);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		generic_fillattr(mnt_user_ns(path.mnt), d_inode(path.dentry), &stat);
+#else
+		generic_fillattr(d_inode(path.dentry), &stat);
+#endif
+#endif
+	} else if (file_present) {
+		err = compat_inode_permission(&path, d_inode(path.dentry),
+					      may_flags);
+		if (err)
+			goto free_path;
+	}
+
+	err = ksmbd_query_inode_status(path.dentry->d_parent);
+	if (err == KSMBD_INODE_STATUS_PENDING_DELETE) {
+		err = -EBUSY;
+		goto free_path;
+	}
+
+	err = 0;
+	ksmbd_debug(SMB, "(%s) open_flags = 0x%x, oplock_flags 0x%x\n", name,
+		    open_flags, oplock_flags);
+	/* open  file and get FID */
+	fp = ksmbd_vfs_dentry_open(work, &path, open_flags, 0, file_present);
+	if (IS_ERR(fp)) {
+		err = PTR_ERR(fp);
+		fp = NULL;
+		goto free_path;
+	}
+	fp->pid = le16_to_cpu(req->hdr.Pid);
+
+	write_lock(&fp->f_ci->m_lock);
+	list_add(&fp->node, &fp->f_ci->m_fp_list);
+	write_unlock(&fp->f_ci->m_lock);
+
+	share_ret = ksmbd_smb_check_shared_mode(fp->filp, fp);
+	if (smb1_oplock_enable &&
+	    test_share_config_flag(work->tcon->share_conf,
+				   KSMBD_SHARE_FLAG_OPLOCKS) &&
+	    !S_ISDIR(file_inode(fp->filp)->i_mode) && oplock_flags) {
+		/* Client cannot request levelII oplock directly */
+		err = smb_grant_oplock(work, oplock_flags, fp->volatile_id, fp,
+				       le16_to_cpu(req->hdr.Tid), NULL, 0);
+		if (err)
+			goto free_path;
+	} else {
+		if (ksmbd_inode_pending_delete(fp)) {
+			err = -EBUSY;
+			goto free_path;
+		}
+
+		if (share_ret < 0) {
+			err = -EPERM;
+			goto free_path;
+		}
+	}
+
+	oplock_rsp = fp->f_opinfo != NULL ? fp->f_opinfo->level : 0;
+
+	/* open success, send back response */
+	if (file_present) {
+		if (!(open_flags & O_TRUNC))
+			file_info = F_OPENED;
+		else
+			file_info = F_OVERWRITTEN;
+	} else
+		file_info = F_CREATED;
+
+	if (oplock_rsp)
+		file_info |= SMBOPEN_LOCK_GRANTED;
+
+	if (stat.result_mask & STATX_BTIME)
+		fp->create_time = ksmbd_UnixTimeToNT(stat.btime);
+	else
+		fp->create_time = ksmbd_UnixTimeToNT(stat.ctime);
+	if (file_present) {
+		if (test_share_config_flag(work->tcon->share_conf,
+					   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
+			struct xattr_dos_attrib da;
+
+			err = compat_ksmbd_vfs_get_dos_attrib_xattr(&path,
+								    path.dentry,
+								    &da);
+			if (err > 0) {
+				fp->create_time = da.create_time;
+				fp->itime = da.itime;
+			}
+			err = 0;
+		}
+	} else {
+		if (test_share_config_flag(work->tcon->share_conf,
+					   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
+			struct xattr_dos_attrib da = {0};
+
+			da.version = 4;
+			da.attr = ATTR_NORMAL;
+			da.itime = da.create_time = fp->create_time;
+			da.flags = XATTR_DOSINFO_ATTRIB |
+				   XATTR_DOSINFO_CREATE_TIME |
+				   XATTR_DOSINFO_ITIME;
+
+			err = compat_ksmbd_vfs_set_dos_attrib_xattr(&path, &da,
+					false);
+			if (err)
+				ksmbd_debug(SMB, "failed to store creation time in xattr\n");
+			err = 0;
+		}
+	}
+
+	/* prepare response buffer */
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 0x0F;
+	rsp->Fid = fp->volatile_id;
+	rsp->FileAttributes = cpu_to_le16(ATTR_NORMAL);
+	rsp->LastWriteTime = cpu_to_le32(stat.mtime.tv_sec);
+	rsp->EndOfFile = cpu_to_le32(stat.size);
+	switch (open_flags & O_ACCMODE) {
+	case O_RDONLY:
+		rsp->Access = cpu_to_le16(SMB_DA_ACCESS_READ);
+		break;
+	case O_WRONLY:
+		rsp->Access = cpu_to_le16(SMB_DA_ACCESS_WRITE);
+		break;
+	case O_RDWR:
+		rsp->Access = cpu_to_le16(SMB_DA_ACCESS_READ_WRITE);
+		break;
+	default:
+		rsp->Access = cpu_to_le16(SMB_DA_ACCESS_READ);
+		break;
+	}
+
+	rsp->FileType = 0;
+	rsp->IPCState = 0;
+	rsp->Action = cpu_to_le16(file_info);
+	rsp->Reserved = 0;
+	rsp->ByteCount = 0;
+	inc_rfc1001_len(&rsp->hdr, rsp->hdr.WordCount * 2);
+
+free_path:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	path_put(&path);
+#endif
+out:
+	ksmbd_revert_fsids(work);
+	if (err) {
+		if (err == -ENOSPC)
+			rsp->hdr.Status.CifsError = STATUS_DISK_FULL;
+		else if (err == -EMFILE)
+			rsp->hdr.Status.CifsError =
+				STATUS_TOO_MANY_OPENED_FILES;
+		else if (err == -EBUSY)
+			rsp->hdr.Status.CifsError = STATUS_DELETE_PENDING;
+		else if (err == -ENOENT)
+			rsp->hdr.Status.CifsError =
+				STATUS_OBJECT_NAME_NOT_FOUND;
+		else if (err == -EACCES || err == -EXDEV)
+			rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+		else
+			rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+		if (fp)
+			ksmbd_close_fd(work, fp->volatile_id);
+	} else
+		ksmbd_update_fstate(&work->sess->file_table, fp, FP_INITED);
+
+	kfree(name);
+	if (!rsp->hdr.WordCount)
+		return err;
+
+	/* this is an ANDx command ? */
+	rsp->AndXReserved = 0;
+	rsp->AndXOffset = cpu_to_le16(get_rfc1002_len(&rsp->hdr));
+	if (req->AndXCommand != SMB_NO_MORE_ANDX_COMMAND) {
+		/* adjust response */
+		rsp->AndXCommand = req->AndXCommand;
+		return rsp->AndXCommand; /* More processing required */
+	}
+	rsp->AndXCommand = SMB_NO_MORE_ANDX_COMMAND;
+
+	return err;
+}
+
+/**
+ * smb_setattr() - set file attributes
+ * @work:	smb work containing setattr command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_setattr(struct ksmbd_work *work)
+{
+	struct smb_com_setattr_req *req = work->request_buf;
+	struct smb_com_setattr_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	struct path path, parent_path;
+#else
+	struct path path;
+#endif
+	struct kstat stat;
+	struct iattr attrs;
+	int err = 0;
+	char *name;
+	__u16 dos_attr;
+
+	name = smb_get_name(share, req->fileName, PATH_MAX, work, false);
+	if (IS_ERR(name)) {
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_INVALID;
+		return PTR_ERR(name);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	err = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					 &parent_path, &path,
+					 req->hdr.Flags & SMBFLG_CASELESS);
+#else
+	err = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path,
+				  req->hdr.Flags & SMBFLG_CASELESS);
+#endif
+	if (err) {
+		ksmbd_debug(SMB, "look up failed err %d\n", err);
+		rsp->hdr.Status.CifsError = STATUS_OBJECT_NAME_NOT_FOUND;
+		err = 0;
+		goto out;
+	}
+	compat_generic_fillattr(&path, STATX_BASIC_STATS,
+				d_inode(path.dentry), &stat);
+	path_put(&path);
+	attrs.ia_valid = 0;
+	attrs.ia_mode = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	path_put(&path);
+#endif
+
+	dos_attr = le16_to_cpu(req->attr);
+	if (!dos_attr)
+		attrs.ia_mode = stat.mode | 0200;
+
+	if (dos_attr & ATTR_READONLY)
+		attrs.ia_mode = stat.mode & ~0222;
+
+	if (attrs.ia_mode)
+		attrs.ia_valid |= ATTR_MODE;
+
+	attrs.ia_mtime.tv_sec = le32_to_cpu(req->LastWriteTime);
+	attrs.ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);
+
+	err = ksmbd_vfs_setattr(work, name, 0, &attrs);
+	if (err)
+		goto out;
+
+	rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	rsp->hdr.WordCount = 0;
+	rsp->ByteCount = 0;
+
+out:
+	kfree(name);
+	if (err) {
+		rsp->hdr.Status.CifsError = STATUS_INVALID_PARAMETER;
+		return err;
+	}
+
+	return 0;
+}
+
+/**
+ * smb_query_information_disk() - determine capacity and remaining free space
+ * @work:	smb work containing command
+ *
+ * Return:	0 on success, otherwise error
+ */
+int smb_query_information_disk(struct ksmbd_work *work)
+{
+	struct smb_hdr *req = work->request_buf;
+	struct smb_com_query_information_disk_rsp *rsp = work->response_buf;
+	struct ksmbd_share_config *share = work->tcon->share_conf;
+	struct ksmbd_tree_connect *tree_conn;
+	struct kstatfs stfs;
+	struct path path;
+	int err = 0;
+
+	u16 blocks_per_unit, bytes_per_block, total_units, free_units;
+	u64 total_blocks, free_blocks;
+	u32 block_size, unit_size;
+
+	if (req->WordCount) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	tree_conn = work->tcon;
+	if (!tree_conn) {
+		err = -ENOENT;
+		goto out;
+	}
+
+	share = tree_conn->share_conf;
+
+	if (test_share_config_flag(share, KSMBD_SHARE_FLAG_PIPE)) {
+		err = -ENOENT;
+		goto out;
+	}
+
+	if (ksmbd_override_fsids(work)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	err = kern_path(share->path, LOOKUP_NO_SYMLINKS, &path);
+	if (err)
+		goto out_fsids;
+
+	err = vfs_statfs(&path, &stfs);
+	if (err) {
+		pr_err("cannot do stat of path %s\n", share->path);
+		goto out_path;
+	}
+
+	unit_size = stfs.f_bsize / stfs.f_frsize;
+	block_size = stfs.f_bsize;
+	total_blocks = stfs.f_blocks;
+	free_blocks = stfs.f_bavail;
+
+	/*
+	 * clamp block size to at most 512 KB for compatibility with
+	 * older clients
+	 */
+	while (block_size > 512) {
+		block_size >>= 1;
+		unit_size <<= 1;
+	}
+
+	/* adjust blocks and sizes until they fit into a u16 */
+	while (total_blocks >= 0xFFFF) {
+		total_blocks >>= 1;
+		free_blocks >>= 1;
+		if ((unit_size <<= 1) > 0xFFFF) {
+			unit_size >>= 1;
+			total_blocks = 0xFFFF;
+			free_blocks <<= 1;
+			break;
+		}
+	}
+
+	total_units = (total_blocks >= 0xFFFF) ? 0xFFFF : (u16)total_blocks;
+	free_units = (free_blocks >= 0xFFFF) ? 0xFFFF : (u16)free_blocks;
+	bytes_per_block = (u16)block_size;
+	blocks_per_unit = (u16)unit_size;
+
+	rsp->hdr.WordCount = 5;
+
+	rsp->TotalUnits = total_units;
+	rsp->BlocksPerUnit = blocks_per_unit;
+	rsp->BlockSize = bytes_per_block;
+	rsp->FreeUnits = free_units;
+	rsp->Pad = 0;
+	rsp->ByteCount = 0;
+
+	inc_rfc1001_len(rsp, rsp->hdr.WordCount * 2);
+
+out_path:
+	path_put(&path);
+out_fsids:
+	ksmbd_revert_fsids(work);
+out:
+	if (err) {
+		switch (err) {
+		case -EINVAL:
+			rsp->hdr.Status.CifsError = STATUS_NOT_SUPPORTED;
+			break;
+		case -ENOMEM:
+			rsp->hdr.Status.CifsError = STATUS_NO_MEMORY;
+			break;
+		case -ENOENT:
+			rsp->hdr.Status.CifsError = STATUS_NO_SUCH_FILE;
+			break;
+		case -EBUSY:
+			rsp->hdr.Status.CifsError = STATUS_DELETE_PENDING;
+			break;
+		case -EACCES:
+		case -EXDEV:
+			rsp->hdr.Status.CifsError = STATUS_ACCESS_DENIED;
+			break;
+		case -EBADF:
+			rsp->hdr.Status.CifsError = STATUS_FILE_CLOSED;
+			break;
+		case -EFAULT:
+			rsp->hdr.Status.CifsError = STATUS_INVALID_LEVEL;
+			break;
+		case -EOPNOTSUPP:
+			rsp->hdr.Status.CifsError = STATUS_NOT_IMPLEMENTED;
+			break;
+		case -EIO:
+			rsp->hdr.Status.CifsError = STATUS_UNEXPECTED_IO_ERROR;
+			break;
+		}
+		ksmbd_debug(SMB, "%s failed with error %d\n", __func__, err);
+	}
+
+	return err;
+}
+
+/**
+ * smb1_is_sign_req() - handler for checking packet signing status
+ * @work:	smb work containing notify command buffer
+ *
+ * Return:	true if packed is signed, false otherwise
+ */
+bool smb1_is_sign_req(struct ksmbd_work *work, unsigned int command)
+{
+#if 0
+	struct smb_hdr *rcv_hdr1 = (struct smb_hdr *)work->request_buf;
+
+	/*
+	 * FIXME: signed tree connect failed by signing error
+	 * with windows XP client. For now, Force to turn off
+	 * signing feature in SMB1.
+	 */
+	if ((rcv_hdr1->Flags2 & SMBFLG2_SECURITY_SIGNATURE) &&
+			command != SMB_COM_SESSION_SETUP_ANDX)
+		return true;
+	return false;
+#else
+	return false;
+#endif
+}
+
+/**
+ * smb1_check_sign_req() - handler for req packet sign processing
+ * @work:	smb work containing notify command buffer
+ *
+ * Return:	1 on success, 0 otherwise
+ */
+int smb1_check_sign_req(struct ksmbd_work *work)
+{
+	struct smb_hdr *rcv_hdr1 = (struct smb_hdr *)work->request_buf;
+	char signature_req[CIFS_SMB1_SIGNATURE_SIZE];
+	char signature[20];
+	struct kvec iov[1];
+
+	memcpy(signature_req, rcv_hdr1->Signature.SecuritySignature,
+	       CIFS_SMB1_SIGNATURE_SIZE);
+	rcv_hdr1->Signature.Sequence.SequenceNumber =
+		cpu_to_le32(++work->sess->sequence_number);
+	rcv_hdr1->Signature.Sequence.Reserved = 0;
+
+	iov[0].iov_base = rcv_hdr1->Protocol;
+	iov[0].iov_len = be32_to_cpu(rcv_hdr1->smb_buf_length);
+
+	if (ksmbd_sign_smb1_pdu(work->sess, iov, 1, signature))
+		return 0;
+
+	if (memcmp(signature, signature_req, CIFS_SMB1_SIGNATURE_SIZE)) {
+		ksmbd_debug(SMB, "bad smb1 sign\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+/**
+ * smb1_set_sign_rsp() - handler for rsp packet sign processing
+ * @work:	smb work containing notify command buffer
+ *
+ */
+void smb1_set_sign_rsp(struct ksmbd_work *work)
+{
+	struct smb_hdr *rsp_hdr = (struct smb_hdr *)work->response_buf;
+	char signature[20];
+	struct kvec iov[2];
+	int n_vec = 1;
+
+	rsp_hdr->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;
+	rsp_hdr->Signature.Sequence.SequenceNumber =
+		cpu_to_le32(++work->sess->sequence_number);
+	rsp_hdr->Signature.Sequence.Reserved = 0;
+
+	iov[0].iov_base = rsp_hdr->Protocol;
+	iov[0].iov_len = be32_to_cpu(rsp_hdr->smb_buf_length);
+
+	if (work->aux_payload_sz) {
+		iov[0].iov_len -= work->aux_payload_sz;
+
+		iov[1].iov_base = work->aux_payload_buf;
+		iov[1].iov_len = work->aux_payload_sz;
+		n_vec++;
+	}
+
+	if (ksmbd_sign_smb1_pdu(work->sess, iov, n_vec, signature))
+		memset(rsp_hdr->Signature.SecuritySignature, 0,
+		       CIFS_SMB1_SIGNATURE_SIZE);
+	else
+		memcpy(rsp_hdr->Signature.SecuritySignature, signature,
+		       CIFS_SMB1_SIGNATURE_SIZE);
+}
diff --git a/fs/ksmbd/smb1pdu.h b/fs/ksmbd/smb1pdu.h
new file mode 100644
index 000000000000..8cef2ab25bab
--- /dev/null
+++ b/fs/ksmbd/smb1pdu.h
@@ -0,0 +1,1651 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ *   Copyright (C) 2016 Namjae Jeon <linkinjeon@kernel.org>
+ *   Copyright (C) 2018 Samsung Electronics Co., Ltd.
+ */
+
+#ifndef __SMB1PDU_H
+#define __SMB1PDU_H
+
+#define MAX_CIFS_HDR_SIZE 0x58
+
+#define SMB1_CLIENT_GUID_SIZE		(16)
+#define SMB1_MAX_MPX_COUNT		10
+#define SMB1_MAX_VCS			1
+#define SMB1_MAX_RAW_SIZE		65536
+#define MAX_CIFS_LOOKUP_BUFFER_SIZE	(16*1024)
+
+/*
+ * Size of the ntlm client response
+ */
+#define CIFS_AUTH_RESP_SIZE		24
+#define CIFS_SMB1_SIGNATURE_SIZE	8
+#define CIFS_SMB1_SESSKEY_SIZE		16
+
+#define SMB1_SERVER_CAPS					\
+	(CAP_UNICODE | CAP_LARGE_FILES | CAP_EXTENDED_SECURITY |\
+	 CAP_NT_SMBS | CAP_STATUS32 | CAP_LOCK_AND_READ |	\
+	 CAP_NT_FIND | CAP_UNIX | CAP_LARGE_READ_X |		\
+	 CAP_LARGE_WRITE_X | CAP_LEVEL_II_OPLOCKS)
+
+#define SMB1_SERVER_SECU  (SECMODE_USER | SECMODE_PW_ENCRYPT)
+
+/* Service Type of TreeConnect*/
+#define SERVICE_DISK_SHARE	"A:"
+#define SERVICE_IPC_SHARE	"IPC"
+#define SERVICE_PRINTER_SHARE	"LPT1:"
+#define SERVICE_COMM		"COMM"
+
+#define NATIVE_FILE_SYSTEM	"NTFS"
+
+#define SMB_NO_MORE_ANDX_COMMAND 0xFF
+#define SMB1_PROTO_NUMBER cpu_to_le32(0x424d53ff)
+
+/* Transact2 subcommand codes */
+#define TRANS2_OPEN                   0x00
+#define TRANS2_FIND_FIRST             0x01
+#define TRANS2_FIND_NEXT              0x02
+#define TRANS2_QUERY_FS_INFORMATION   0x03
+#define TRANS2_SET_FS_INFORMATION     0x04
+#define TRANS2_QUERY_PATH_INFORMATION 0x05
+#define TRANS2_SET_PATH_INFORMATION   0x06
+#define TRANS2_QUERY_FILE_INFORMATION 0x07
+#define TRANS2_SET_FILE_INFORMATION   0x08
+#define TRANS2_CREATE_DIRECTORY       0x0d
+#define TRANS2_GET_DFS_REFERRAL       0x10
+#define TRANS2_REPORT_DFS_INCOSISTENCY 0x11
+
+/* SMB Transact (Named Pipe) subcommand codes */
+#define TRANS_SET_NMPIPE_STATE      0x0001
+#define TRANS_RAW_READ_NMPIPE       0x0011
+#define TRANS_QUERY_NMPIPE_STATE    0x0021
+#define TRANS_QUERY_NMPIPE_INFO     0x0022
+#define TRANS_PEEK_NMPIPE           0x0023
+#define TRANS_TRANSACT_NMPIPE       0x0026
+#define TRANS_RAW_WRITE_NMPIPE      0x0031
+#define TRANS_READ_NMPIPE           0x0036
+#define TRANS_WRITE_NMPIPE          0x0037
+#define TRANS_WAIT_NMPIPE           0x0053
+#define TRANS_CALL_NMPIPE           0x0054
+
+/* NT Transact subcommand codes */
+#define NT_TRANSACT_CREATE            0x01
+#define NT_TRANSACT_IOCTL             0x02
+#define NT_TRANSACT_SET_SECURITY_DESC 0x03
+#define NT_TRANSACT_NOTIFY_CHANGE     0x04
+#define NT_TRANSACT_RENAME            0x05
+#define NT_TRANSACT_QUERY_SECURITY_DESC 0x06
+#define NT_TRANSACT_GET_USER_QUOTA    0x07
+#define NT_TRANSACT_SET_USER_QUOTA    0x08
+
+/*
+ * SMB flag definitions
+ */
+#define SMBFLG_EXTD_LOCK 0x01   /* server supports lock-read write-unlock smb */
+#define SMBFLG_RCV_POSTED 0x02  /* obsolete */
+#define SMBFLG_RSVD 0x04
+#define SMBFLG_CASELESS 0x08    /*
+				 * all pathnames treated as caseless (off
+				 * implies case sensitive file handling
+				 * request)
+				 */
+#define SMBFLG_CANONICAL_PATH_FORMAT 0x10       /* obsolete */
+#define SMBFLG_OLD_OPLOCK 0x20  /* obsolete */
+#define SMBFLG_OLD_OPLOCK_NOTIFY 0x40   /* obsolete */
+#define SMBFLG_RESPONSE 0x80    /* this PDU is a response from server */
+
+/*
+ * SMB flag2 definitions
+ */
+#define SMBFLG2_KNOWS_LONG_NAMES cpu_to_le16(1) /*
+						 * can send long (non-8.3)
+						 * path names in response
+						 */
+#define SMBFLG2_KNOWS_EAS cpu_to_le16(2)
+#define SMBFLG2_SECURITY_SIGNATURE cpu_to_le16(4)
+#define SMBFLG2_COMPRESSED (8)
+#define SMBFLG2_SECURITY_SIGNATURE_REQUIRED (0x10)
+#define SMBFLG2_IS_LONG_NAME cpu_to_le16(0x40)
+#define SMBFLG2_REPARSE_PATH (0x400)
+#define SMBFLG2_EXT_SEC cpu_to_le16(0x800)
+#define SMBFLG2_DFS cpu_to_le16(0x1000)
+#define SMBFLG2_PAGING_IO cpu_to_le16(0x2000)
+#define SMBFLG2_ERR_STATUS cpu_to_le16(0x4000)
+#define SMBFLG2_UNICODE cpu_to_le16(0x8000)
+
+#define SMB_COM_CREATE_DIRECTORY      0x00 /* trivial response */
+#define SMB_COM_DELETE_DIRECTORY      0x01 /* trivial response */
+#define SMB_COM_CLOSE                 0x04 /* triv req/rsp, timestamp ignored */
+#define SMB_COM_FLUSH                 0x05 /* triv req/rsp */
+#define SMB_COM_DELETE                0x06 /* trivial response */
+#define SMB_COM_RENAME                0x07 /* trivial response */
+#define SMB_COM_QUERY_INFORMATION     0x08 /* aka getattr */
+#define SMB_COM_SETATTR               0x09 /* trivial response */
+#define SMB_COM_WRITE                 0x0b
+#define SMB_COM_CHECK_DIRECTORY       0x10 /* trivial response */
+#define SMB_COM_PROCESS_EXIT          0x11 /* trivial response */
+#define SMB_COM_LOCKING_ANDX          0x24 /* trivial response */
+#define SMB_COM_TRANSACTION	      0x25
+#define SMB_COM_COPY                  0x29 /* trivial rsp, fail filename ignrd*/
+#define SMB_COM_ECHO                  0x2B /* echo request */
+#define SMB_COM_OPEN_ANDX             0x2D /* Legacy open for old servers */
+#define SMB_COM_READ_ANDX             0x2E
+#define SMB_COM_WRITE_ANDX            0x2F
+#define SMB_COM_TRANSACTION2          0x32
+#define SMB_COM_TRANSACTION2_SECONDARY 0x33
+#define SMB_COM_FIND_CLOSE2           0x34 /* trivial response */
+#define SMB_COM_TREE_DISCONNECT       0x71 /* trivial response */
+#define SMB_COM_NEGOTIATE             0x72
+#define SMB_COM_SESSION_SETUP_ANDX    0x73
+#define SMB_COM_LOGOFF_ANDX           0x74 /* trivial response */
+#define SMB_COM_TREE_CONNECT_ANDX     0x75
+#define SMB_COM_QUERY_INFORMATION_DISK 0x80
+#define SMB_COM_NT_TRANSACT           0xA0
+#define SMB_COM_NT_TRANSACT_SECONDARY 0xA1
+#define SMB_COM_NT_CREATE_ANDX        0xA2
+#define SMB_COM_NT_CANCEL             0xA4 /* no response */
+#define SMB_COM_NT_RENAME             0xA5 /* trivial response */
+
+/* Negotiate response Capabilities */
+#define CAP_RAW_MODE           0x00000001
+#define CAP_MPX_MODE           0x00000002
+#define CAP_UNICODE            0x00000004
+#define CAP_LARGE_FILES        0x00000008
+#define CAP_NT_SMBS            0x00000010       /* implies CAP_NT_FIND */
+#define CAP_RPC_REMOTE_APIS    0x00000020
+#define CAP_STATUS32           0x00000040
+#define CAP_LEVEL_II_OPLOCKS   0x00000080
+#define CAP_LOCK_AND_READ      0x00000100
+#define CAP_NT_FIND            0x00000200
+#define CAP_DFS                0x00001000
+#define CAP_INFOLEVEL_PASSTHRU 0x00002000
+#define CAP_LARGE_READ_X       0x00004000
+#define CAP_LARGE_WRITE_X      0x00008000
+#define CAP_LWIO               0x00010000 /* support fctl_srv_req_resume_key */
+#define CAP_UNIX               0x00800000
+#define CAP_COMPRESSED_DATA    0x02000000
+#define CAP_DYNAMIC_REAUTH     0x20000000
+#define CAP_PERSISTENT_HANDLES 0x40000000
+#define CAP_EXTENDED_SECURITY  0x80000000
+
+/* RFC 1002 session packet types */
+#define RFC1002_SESSION_MESSAGE 0x00
+#define RFC1002_SESSION_REQUEST  0x81
+#define RFC1002_POSITIVE_SESSION_RESPONSE 0x82
+#define RFC1002_NEGATIVE_SESSION_RESPONSE 0x83
+#define RFC1002_RETARGET_SESSION_RESPONSE 0x84
+#define RFC1002_SESSION_KEEP_ALIVE 0x85
+
+/* Action bits */
+#define GUEST_LOGIN 1
+
+struct smb_negotiate_rsp {
+	struct smb_hdr hdr;     /* wct = 17 */
+	__le16 DialectIndex; /* 0xFFFF = no dialect acceptable */
+	__u8 SecurityMode;
+	__le16 MaxMpxCount;
+	__le16 MaxNumberVcs;
+	__le32 MaxBufferSize;
+	__le32 MaxRawSize;
+	__le32 SessionKey;
+	__le32 Capabilities;    /* see below */
+	__le32 SystemTimeLow;
+	__le32 SystemTimeHigh;
+	__le16 ServerTimeZone;
+	__u8 EncryptionKeyLength;
+	__le16 ByteCount;
+	union {
+		unsigned char EncryptionKey[8]; /* cap extended security off */
+		/* followed by Domain name - if extended security is off */
+		/* followed by 16 bytes of server GUID */
+		/* then security blob if cap_extended_security negotiated */
+		struct {
+			unsigned char GUID[SMB1_CLIENT_GUID_SIZE];
+			unsigned char SecurityBlob[1];
+		} __packed extended_response;
+	} __packed u;
+} __packed;
+
+struct smb_com_read_req {
+	struct smb_hdr hdr;     /* wct = 12 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__u16 Fid;
+	__le32 OffsetLow;
+	__le16 MaxCount;
+	__le16 MinCount;                /* obsolete */
+	__le32 MaxCountHigh;
+	__le16 Remaining;
+	__le32 OffsetHigh;
+	__le16 ByteCount;
+} __packed;
+
+struct smb_com_read_rsp {
+	struct smb_hdr hdr;     /* wct = 12 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 Remaining;
+	__le16 DataCompactionMode;
+	__le16 Reserved;
+	__le16 DataLength;
+	__le16 DataOffset;
+	__le16 DataLengthHigh;
+	__u64 Reserved2;
+	__le16 ByteCount;
+	/* read response data immediately follows */
+} __packed;
+
+struct smb_com_write_req {
+	struct smb_hdr hdr;	/* wct = 14 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__u16 Fid;
+	__le32 OffsetLow;
+	__u32 Reserved;
+	__le16 WriteMode;
+	__le16 Remaining;
+	__le16 DataLengthHigh;
+	__le16 DataLengthLow;
+	__le16 DataOffset;
+	__le32 OffsetHigh;
+	__le16 ByteCount;
+	__u8 Pad;		/*
+				 * BB check for whether padded to DWORD
+				 * boundary and optimum performance here
+				 */
+	char Data[0];
+} __packed;
+
+struct smb_com_write_req_32bit {
+	struct smb_hdr hdr;	/* wct = 5 */
+	__u16 Fid;
+	__le16 Length;
+	__le32 Offset;
+	__u16 Estimate;
+	__le16 ByteCount;	/* must be greater than 2 */
+	__u8 BufferFormat;
+	__u16 DataLength;
+	char Data[0];
+} __packed;
+
+struct smb_com_write_rsp_32bit {
+	struct smb_hdr hdr;	/* wct = 1 */
+	__le16 Written;
+	__le16 ByteCount;	/* must be 0 */
+} __packed;
+
+struct smb_com_write_rsp {
+	struct smb_hdr hdr;	/* wct = 6 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 Count;
+	__le16 Remaining;
+	__le16 CountHigh;
+	__u16  Reserved;
+	__le16 ByteCount;
+} __packed;
+
+struct smb_com_rename_req {
+	struct smb_hdr hdr;     /* wct = 1 */
+	__le16 SearchAttributes;        /* target file attributes */
+	__le16 ByteCount;
+	__u8 BufferFormat;      /* 4 = ASCII or Unicode */
+	unsigned char OldFileName[1];
+	/* followed by __u8 BufferFormat2 */
+	/* followed by NewFileName */
+} __packed;
+
+struct smb_com_rename_rsp {
+	struct smb_hdr hdr;     /* wct = 0 */
+	__le16 ByteCount;        /* bct = 0 */
+} __packed;
+
+/* SecurityMode bits */
+#define SECMODE_USER          0x01      /* off indicates share level security */
+#define SECMODE_PW_ENCRYPT    0x02
+#define SECMODE_SIGN_ENABLED  0x04      /* SMB security signatures enabled */
+#define SECMODE_SIGN_REQUIRED 0x08      /* SMB security signatures required */
+
+struct smb_com_session_setup_req {	/* request format */
+	struct smb_hdr hdr;	/* wct = 12 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 MaxBufferSize;
+	__le16 MaxMpxCount;
+	__le16 VcNumber;
+	__u32 SessionKey;
+	__le16 SecurityBlobLength;
+	__u32 Reserved;
+	__le32 Capabilities;	/* see below */
+	__le16 ByteCount;
+	unsigned char SecurityBlob[1];	/* followed by */
+	/* STRING NativeOS */
+	/* STRING NativeLanMan */
+} __packed;	/* NTLM request format (with extended security) */
+
+struct smb_com_session_setup_req_no_secext {	/* request format */
+	struct smb_hdr hdr;	/* we will handle this :: wct = 13 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 MaxBufferSize;
+	__le16 MaxMpxCount;
+	__le16 VcNumber;
+	__u32 SessionKey;
+	__le16 CaseInsensitivePasswordLength;	/* ASCII password len */
+	__le16 CaseSensitivePasswordLength;	/* Unicode password length*/
+	__u32 Reserved;	/* see below */
+	__le32 Capabilities;
+	__le16 ByteCount;
+	unsigned char CaseInsensitivePassword[0];	/* followed by: */
+	/* unsigned char * CaseSensitivePassword; */
+	/* STRING AccountName */
+	/* STRING PrimaryDomain */
+	/* STRING NativeOS */
+	/* STRING NativeLanMan */
+} __packed;	/* NTLM request format (without extended security */
+
+struct smb_com_session_setup_resp {	/* default (NTLM) response format */
+	struct smb_hdr hdr;	/* wct = 4 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 Action;	/* see below */
+	__le16 SecurityBlobLength;
+	__le16 ByteCount;
+	unsigned char SecurityBlob[1];	/* followed by */
+	/*      unsigned char  * NativeOS;      */
+	/*      unsigned char  * NativeLanMan;  */
+	/*      unsigned char  * PrimaryDomain; */
+} __packed;	/* NTLM response (with or without extended sec) */
+
+struct smb_com_session_setup_old_resp { /* default (NTLM) response format */
+	struct smb_hdr hdr;	/* wct = 3 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 Action;	/* see below */
+	__le16 ByteCount;
+	unsigned char NativeOS[1];	/* followed by */
+	/*      unsigned char * NativeLanMan; */
+	/*      unsigned char * PrimaryDomain; */
+} __packed;	/* pre-NTLM (LANMAN2.1) response */
+
+union smb_com_session_setup_andx {
+	struct smb_com_session_setup_req req;
+	struct smb_com_session_setup_req_no_secext req_no_secext;
+	struct smb_com_session_setup_resp resp;
+	struct smb_com_session_setup_old_resp old_resp;
+} __packed;
+
+struct smb_com_tconx_req {
+	__u8 WordCount;  /* wct = 4, it could be ANDX */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 Flags;           /* see below */
+	__le16 PasswordLength;
+	__le16 ByteCount;
+	unsigned char Password[1];      /* followed by */
+	/* STRING Path    *//* \\server\share name */
+	/* STRING Service */
+} __packed;
+
+struct smb_com_tconx_rsp {
+	__u8 WordCount;     /* wct = 3 , not extended response */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 OptionalSupport; /* see below */
+	__le16 ByteCount;
+	unsigned char Service[1];       /* always ASCII, not Unicode */
+	/* STRING NativeFileSystem */
+} __packed;
+
+struct smb_com_tconx_rsp_ext {
+	__u8 WordCount;	/* wct = 7, extended response */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 OptionalSupport; /* see below */
+	__le32 MaximalShareAccessRights;
+	__le32 GuestMaximalShareAccessRights;
+	__le16 ByteCount;
+	unsigned char Service[1];       /* always ASCII, not Unicode */
+	/* STRING NativeFileSystem */
+} __packed;
+
+struct andx_block {
+	__u8 WordCount;
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+} __packed;
+
+struct locking_andx_range64 {
+	__le16 Pid;
+	__le16 Pad;
+	__le32 OffsetHigh;
+	__le32 OffsetLow;
+	__le32 LengthHigh;
+	__le32 LengthLow;
+} __packed;
+
+struct locking_andx_range32 {
+	__le16 Pid;
+	__le32 Offset;
+	__le32 Length;
+} __packed;
+
+#define LOCKING_ANDX_SHARED_LOCK     0x01
+#define LOCKING_ANDX_OPLOCK_RELEASE  0x02
+#define LOCKING_ANDX_CHANGE_LOCKTYPE 0x04
+#define LOCKING_ANDX_CANCEL_LOCK     0x08
+#define LOCKING_ANDX_LARGE_FILES     0x10       /* always on for us */
+
+struct smb_com_lock_req {
+	struct smb_hdr hdr;	/* wct = 8 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__u16 Fid;
+	__u8 LockType;
+	__u8 OplockLevel;
+	__le32 Timeout;
+	__le16 NumberOfUnlocks;
+	__le16 NumberOfLocks;
+	__le16 ByteCount;
+	char *Locks[1];
+} __packed;
+
+struct smb_com_lock_rsp {
+	struct smb_hdr hdr;     /* wct = 2 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 ByteCount;
+} __packed;
+
+struct smb_com_query_information_disk_rsp {
+	struct smb_hdr hdr;     /* wct = 5 */
+	__le16 TotalUnits;
+	__le16 BlocksPerUnit;
+	__le16 BlockSize;
+	__le16 FreeUnits;
+	__le16 Pad;
+	__le16 ByteCount;
+} __packed;
+
+/* tree connect Flags */
+#define DISCONNECT_TID          0x0001
+#define TCON_EXTENDED_SIGNATURES 0x0004
+#define TCON_EXTENDED_SECINFO   0x0008
+
+/* OptionalSupport bits */
+#define SMB_SUPPORT_SEARCH_BITS 0x0001  /*
+					 * "must have" directory search bits
+					 * (exclusive searches supported)
+					 */
+#define SMB_SHARE_IS_IN_DFS     0x0002
+#define SMB_CSC_MASK               0x000C
+/* CSC flags defined as follows */
+#define SMB_CSC_CACHE_MANUAL_REINT 0x0000
+#define SMB_CSC_CACHE_AUTO_REINT   0x0004
+#define SMB_CSC_CACHE_VDO          0x0008
+#define SMB_CSC_NO_CACHING         0x000C
+#define SMB_UNIQUE_FILE_NAME    0x0010
+#define SMB_EXTENDED_SIGNATURES 0x0020
+
+/* OpenFlags */
+#define REQ_MORE_INFO      0x00000001  /* legacy (OPEN_AND_X) only */
+#define REQ_OPLOCK         0x00000002
+#define REQ_BATCHOPLOCK    0x00000004
+#define REQ_OPENDIRONLY    0x00000008
+#define REQ_EXTENDED_INFO  0x00000010
+
+/* File type */
+#define DISK_TYPE               0x0000
+#define BYTE_PIPE_TYPE          0x0001
+#define MESSAGE_PIPE_TYPE       0x0002
+#define PRINTER_TYPE            0x0003
+#define COMM_DEV_TYPE           0x0004
+#define UNKNOWN_TYPE            0xFFFF
+
+/* Device Type or File Status Flags */
+#define NO_EAS                  0x0001
+#define NO_SUBSTREAMS           0x0002
+#define NO_REPARSETAG           0x0004
+/* following flags can apply if pipe */
+#define ICOUNT_MASK             0x00FF
+#define PIPE_READ_MODE          0x0100
+#define NAMED_PIPE_TYPE         0x0400
+#define PIPE_END_POINT          0x4000
+#define BLOCKING_NAMED_PIPE     0x8000
+
+/* ShareAccess flags */
+#define FILE_NO_SHARE     0x00000000
+#define FILE_SHARE_READ   0x00000001
+#define FILE_SHARE_WRITE  0x00000002
+#define FILE_SHARE_DELETE 0x00000004
+#define FILE_SHARE_ALL    0x00000007
+
+/* CreateDisposition flags, similar to CreateAction as well */
+#define FILE_SUPERSEDE    0x00000000
+#define FILE_OPEN         0x00000001
+#define FILE_CREATE       0x00000002
+#define FILE_OPEN_IF      0x00000003
+#define FILE_OVERWRITE    0x00000004
+#define FILE_OVERWRITE_IF 0x00000005
+
+/* ImpersonationLevel flags */
+#define SECURITY_ANONYMOUS      0
+#define SECURITY_IDENTIFICATION 1
+#define SECURITY_IMPERSONATION  2
+#define SECURITY_DELEGATION     3
+
+/* SecurityFlags */
+#define SECURITY_CONTEXT_TRACKING 0x01
+#define SECURITY_EFFECTIVE_ONLY   0x02
+
+struct smb_com_open_req {       /* also handles create */
+	struct smb_hdr hdr;     /* wct = 24 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__u8 Reserved;          /* Must Be Zero */
+	__le16 NameLength;
+	__le32 OpenFlags;
+	__u32  RootDirectoryFid;
+	__le32 DesiredAccess;
+	__le64 AllocationSize;
+	__le32 FileAttributes;
+	__le32 ShareAccess;
+	__le32 CreateDisposition;
+	__le32 CreateOptions;
+	__le32 ImpersonationLevel;
+	__u8 SecurityFlags;
+	__le16 ByteCount;
+	char fileName[1];
+} __packed;
+
+/* open response for CreateAction shifted left */
+#define CIFS_CREATE_ACTION 0x20000 /* file created */
+
+/* Basic file attributes */
+#define SMB_FILE_ATTRIBUTE_NORMAL	0x0000
+#define SMB_FILE_ATTRIBUTE_READONLY	0x0001
+#define SMB_FILE_ATTRIBUTE_HIDDEN	0x0002
+#define SMB_FILE_ATTRIBUTE_SYSTEM	0x0004
+#define SMB_FILE_ATTRIBUTE_VOLUME	0x0008
+#define SMB_FILE_ATTRIBUTE_DIRECTORY	0x0010
+#define SMB_FILE_ATTRIBUTE_ARCHIVE	0x0020
+#define SMB_SEARCH_ATTRIBUTE_READONLY	0x0100
+#define SMB_SEARCH_ATTRIBUTE_HIDDEN	0x0200
+#define SMB_SEARCH_ATTRIBUTE_SYSTEM	0x0400
+#define SMB_SEARCH_ATTRIBUTE_DIRECTORY	0x1000
+#define SMB_SEARCH_ATTRIBUTE_ARCHIVE	0x2000
+
+struct smb_com_open_rsp {
+	struct smb_hdr hdr;     /* wct = 34 BB */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__u8 OplockLevel;
+	__u16 Fid;
+	__le32 CreateAction;
+	__le64 CreationTime;
+	__le64 LastAccessTime;
+	__le64 LastWriteTime;
+	__le64 ChangeTime;
+	__le32 FileAttributes;
+	__le64 AllocationSize;
+	__le64 EndOfFile;
+	__le16 FileType;
+	__le16 DeviceState;
+	__u8 DirectoryFlag;
+	__le16 ByteCount;        /* bct = 0 */
+} __packed;
+
+struct smb_com_open_ext_rsp {
+	struct smb_hdr hdr;     /* wct = 42 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__u8 OplockLevel;
+	__u16 Fid;
+	__le32 CreateAction;
+	__le64 CreationTime;
+	__le64 LastAccessTime;
+	__le64 LastWriteTime;
+	__le64 ChangeTime;
+	__le32 FileAttributes;
+	__le64 AllocationSize;
+	__le64 EndOfFile;
+	__le16 FileType;
+	__le16 DeviceState;
+	__u8 DirectoryFlag;
+	__u8 VolId[16];
+	__u64 fid;
+	__le32 MaxAccess;
+	__le32 GuestAccess;
+	__le16 ByteCount;        /* bct = 0 */
+} __packed;
+
+struct smb_com_close_req {
+	struct smb_hdr hdr;     /* wct = 3 */
+	__u16 FileID;
+	__le32 LastWriteTime;    /* should be zero or -1 */
+	__le16  ByteCount;        /* 0 */
+} __packed;
+
+struct smb_com_close_rsp {
+	struct smb_hdr hdr;     /* wct = 0 */
+	__le16 ByteCount;        /* bct = 0 */
+} __packed;
+
+struct smb_com_echo_req {
+	struct  smb_hdr hdr;
+	__le16  EchoCount;
+	__le16  ByteCount;
+	char    Data[1];
+} __packed;
+
+struct smb_com_echo_rsp {
+	struct  smb_hdr hdr;
+	__le16  SequenceNumber;
+	__le16  ByteCount;
+	char    Data[1];
+} __packed;
+
+struct smb_com_flush_req {
+	struct smb_hdr hdr;     /* wct = 1 */
+	__u16 FileID;
+	__le16 ByteCount;        /* 0 */
+} __packed;
+
+struct smb_com_flush_rsp {
+	struct smb_hdr hdr;     /* wct = 0 */
+	__le16 ByteCount;        /* bct = 0 */
+} __packed;
+
+/* SMB_COM_TRANSACTION */
+struct smb_com_trans_req {
+	struct smb_hdr hdr;
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__le16 MaxParameterCount;
+	__le16 MaxDataCount;
+	__u8 MaxSetupCount;
+	__u8 Reserved;
+	__le16 Flags;
+	__le32 Timeout;
+	__u16 Reserved2;
+	__le16 ParameterCount;
+	__le16 ParameterOffset;
+	__le16 DataCount;
+	__le16 DataOffset;
+	__u8 SetupCount;
+	__u8 Reserved3;
+	__le16 SubCommand;
+	__u8  Pad;
+	__u8 Data[1];
+} __packed;
+
+struct smb_com_trans_pipe_req {
+	struct smb_hdr hdr;
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__le16 MaxParameterCount;
+	__le16 MaxDataCount;
+	__u8 MaxSetupCount;
+	__u8 Reserved;
+	__le16 Flags;
+	__le32 Timeout;
+	__u16 Reserved2;
+	__le16 ParameterCount;
+	__le16 ParameterOffset;
+	__le16 DataCount;
+	__le16 DataOffset;
+	__u8 SetupCount;
+	__u8 Reserved3;
+	__u16 SubCommand;
+	__u16 fid;
+	__le16 ByteCount;
+	__u8  Pad;
+	__u8 Data[1];
+} __packed;
+
+struct smb_com_trans_rsp {
+	struct smb_hdr hdr;     /* wct = 10+ */
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__u16 Reserved;
+	__le16 ParameterCount;
+	__le16 ParameterOffset;
+	__le16 ParameterDisplacement;
+	__le16 DataCount;
+	__le16 DataOffset;
+	__le16 DataDisplacement;
+	__u8 SetupCount;
+	__u8 Reserved1;
+	__le16 ByteCount;
+	__u8 Pad;
+} __packed;
+
+/* SMB_COM_TRANSACTION subcommands */
+
+#define TRANSACT_DCERPCCMD	0x26
+
+/*****************************************************************************
+ * TRANS2 command implementation functions
+ *****************************************************************************/
+#define NO_CHANGE_64          0xFFFFFFFFFFFFFFFFULL
+
+/* QFSInfo Levels */
+#define SMB_INFO_ALLOCATION         1
+#define SMB_INFO_VOLUME             2
+#define SMB_QUERY_FS_VOLUME_INFO    0x102
+#define SMB_QUERY_FS_SIZE_INFO      0x103
+#define SMB_QUERY_FS_DEVICE_INFO    0x104
+#define SMB_QUERY_FS_ATTRIBUTE_INFO 0x105
+#define SMB_QUERY_CIFS_UNIX_INFO    0x200
+#define SMB_QUERY_POSIX_FS_INFO     0x201
+#define SMB_QUERY_POSIX_WHO_AM_I    0x202
+#define SMB_REQUEST_TRANSPORT_ENCRYPTION 0x203
+#define SMB_QUERY_FS_PROXY          0x204 /*
+					   * WAFS enabled. Returns structure
+					   * FILE_SYSTEM__UNIX_INFO to tell
+					   * whether new NTIOCTL available
+					   * (0xACE) for WAN friendly SMB
+					   * operations to be carried
+					   */
+#define SMB_QUERY_LABEL_INFO        0x3ea
+#define SMB_QUERY_FS_QUOTA_INFO     0x3ee
+#define SMB_QUERY_FS_FULL_SIZE_INFO 0x3ef
+#define SMB_QUERY_OBJECTID_INFO     0x3f0
+
+struct trans2_resp {
+	/* struct smb_hdr hdr precedes. Note wct = 10 + setup count */
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__u16 Reserved;
+	__le16 ParameterCount;
+	__le16 ParameterOffset;
+	__le16 ParameterDisplacement;
+	__le16 DataCount;
+	__le16 DataOffset;
+	__le16 DataDisplacement;
+	__u8 SetupCount;
+	__u8 Reserved1;
+	/*
+	 * SetupWords[SetupCount];
+	 * __u16 ByteCount;
+	 * __u16 Reserved2;
+	 */
+	/* data area follows */
+} __packed;
+
+struct smb_com_trans2_req {
+	struct smb_hdr hdr;
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__le16 MaxParameterCount;
+	__le16 MaxDataCount;
+	__u8 MaxSetupCount;
+	__u8 Reserved;
+	__le16 Flags;
+	__le32 Timeout;
+	__u16 Reserved2;
+	__le16 ParameterCount;
+	__le16 ParameterOffset;
+	__le16 DataCount;
+	__le16 DataOffset;
+	__u8 SetupCount;
+	__u8 Reserved3;
+	__le16 SubCommand;      /* one setup word */
+} __packed;
+
+struct smb_com_trans2_qfsi_req {
+	struct smb_hdr hdr;     /* wct = 14+ */
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__le16 MaxParameterCount;
+	__le16 MaxDataCount;
+	__u8 MaxSetupCount;
+	__u8 Reserved;
+	__le16 Flags;
+	__le32 Timeout;
+	__u16 Reserved2;
+	__le16 ParameterCount;
+	__le16 ParameterOffset;
+	__le16 DataCount;
+	__le16 DataOffset;
+	__u8 SetupCount;
+	__u8 Reserved3;
+	__le16 SubCommand;      /* one setup word */
+	__le16 ByteCount;
+	__u8 Pad;
+	__le16 InformationLevel;
+} __packed;
+
+struct smb_com_trans2_qfsi_req_params {
+	__le16 InformationLevel;
+} __packed;
+
+#define CIFS_SEARCH_CLOSE_ALWAYS	0x0001
+#define CIFS_SEARCH_CLOSE_AT_END	0x0002
+#define CIFS_SEARCH_RETURN_RESUME	0x0004
+#define CIFS_SEARCH_CONTINUE_FROM_LAST	0x0008
+#define CIFS_SEARCH_BACKUP_SEARCH	0x0010
+
+struct smb_com_trans2_ffirst_req_params {
+	__le16 SearchAttributes;
+	__le16 SearchCount;
+	__le16 SearchFlags;
+	__le16 InformationLevel;
+	__le32 SearchStorageType;
+	char FileName[1];
+} __packed;
+
+struct smb_com_trans2_ffirst_rsp_parms {
+	__u16 SearchHandle;
+	__le16 SearchCount;
+	__le16 EndofSearch;
+	__le16 EAErrorOffset;
+	__le16 LastNameOffset;
+} __packed;
+
+struct smb_com_trans2_fnext_req_params {
+	__u16 SearchHandle;
+	__le16 SearchCount;
+	__le16 InformationLevel;
+	__u32 ResumeKey;
+	__le16 SearchFlags;
+	char ResumeFileName[1];
+} __packed;
+
+struct smb_com_trans2_fnext_rsp_params {
+	__le16 SearchCount;
+	__le16 EndofSearch;
+	__le16 EAErrorOffset;
+	__le16 LastNameOffset;
+} __packed;
+
+struct smb_com_trans2_rsp {
+	struct smb_hdr hdr;     /* wct = 10 + SetupCount */
+	struct trans2_resp t2;
+	__le16 ByteCount;
+	__u8 Pad;       /* may be three bytes? *//* followed by data area */
+	__u8 Buffer[0];
+} __packed;
+
+struct file_internal_info {
+	__le64  UniqueId; /* inode number */
+} __packed;      /* level 0x3ee */
+
+/* DeviceType Flags */
+#define FILE_DEVICE_CD_ROM              0x00000002
+#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
+#define FILE_DEVICE_DFS                 0x00000006
+#define FILE_DEVICE_DISK                0x00000007
+#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
+#define FILE_DEVICE_FILE_SYSTEM         0x00000009
+#define FILE_DEVICE_NAMED_PIPE          0x00000011
+#define FILE_DEVICE_NETWORK             0x00000012
+#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
+#define FILE_DEVICE_NULL                0x00000015
+#define FILE_DEVICE_PARALLEL_PORT       0x00000016
+#define FILE_DEVICE_PRINTER             0x00000018
+#define FILE_DEVICE_SERIAL_PORT         0x0000001b
+#define FILE_DEVICE_STREAMS             0x0000001e
+#define FILE_DEVICE_TAPE                0x0000001f
+#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
+#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
+#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
+
+/* Filesystem Attributes. */
+#define FILE_CASE_SENSITIVE_SEARCH      0x00000001
+#define FILE_CASE_PRESERVED_NAMES       0x00000002
+#define FILE_UNICODE_ON_DISK            0x00000004
+/* According to cifs9f, this is 4, not 8 */
+/* Acconding to testing, this actually sets the security attribute! */
+#define FILE_PERSISTENT_ACLS            0x00000008
+#define FILE_FILE_COMPRESSION           0x00000010
+#define FILE_VOLUME_QUOTAS              0x00000020
+#define FILE_SUPPORTS_SPARSE_FILES      0x00000040
+#define FILE_SUPPORTS_REPARSE_POINTS    0x00000080
+#define FILE_SUPPORTS_REMOTE_STORAGE    0x00000100
+#define FS_LFN_APIS                     0x00004000
+#define FILE_VOLUME_IS_COMPRESSED       0x00008000
+#define FILE_SUPPORTS_OBJECT_IDS        0x00010000
+#define FILE_SUPPORTS_ENCRYPTION        0x00020000
+#define FILE_NAMED_STREAMS              0x00040000
+#define FILE_READ_ONLY_VOLUME           0x00080000
+
+/* PathInfo/FileInfo infolevels */
+#define SMB_INFO_STANDARD                   1
+#define SMB_SET_FILE_EA                     2
+#define SMB_QUERY_FILE_EA_SIZE              2
+#define SMB_INFO_QUERY_EAS_FROM_LIST        3
+#define SMB_INFO_QUERY_ALL_EAS              4
+#define SMB_INFO_IS_NAME_VALID              6
+#define SMB_QUERY_FILE_BASIC_INFO       0x101
+#define SMB_QUERY_FILE_STANDARD_INFO    0x102
+#define SMB_QUERY_FILE_EA_INFO          0x103
+#define SMB_QUERY_FILE_NAME_INFO        0x104
+#define SMB_QUERY_FILE_ALLOCATION_INFO  0x105
+#define SMB_QUERY_FILE_END_OF_FILEINFO  0x106
+#define SMB_QUERY_FILE_ALL_INFO         0x107
+#define SMB_QUERY_ALT_NAME_INFO         0x108
+#define SMB_QUERY_FILE_STREAM_INFO      0x109
+#define SMB_QUERY_FILE_COMPRESSION_INFO 0x10B
+#define SMB_QUERY_FILE_UNIX_BASIC       0x200
+#define SMB_QUERY_FILE_UNIX_LINK        0x201
+#define SMB_QUERY_POSIX_ACL             0x204
+#define SMB_QUERY_XATTR                 0x205  /* e.g. system EA name space */
+#define SMB_QUERY_ATTR_FLAGS            0x206  /* append,immutable etc. */
+#define SMB_QUERY_POSIX_PERMISSION      0x207
+#define SMB_QUERY_POSIX_LOCK            0x208
+/* #define SMB_POSIX_OPEN               0x209 */
+/* #define SMB_POSIX_UNLINK             0x20a */
+#define SMB_QUERY_FILE__UNIX_INFO2      0x20b
+#define SMB_QUERY_FILE_INTERNAL_INFO    0x3ee
+#define SMB_QUERY_FILE_ACCESS_INFO      0x3f0
+#define SMB_QUERY_FILE_NAME_INFO2       0x3f1 /* 0x30 bytes */
+#define SMB_QUERY_FILE_POSITION_INFO    0x3f6
+#define SMB_QUERY_FILE_MODE_INFO        0x3f8
+#define SMB_QUERY_FILE_ALGN_INFO        0x3f9
+
+
+#define SMB_SET_FILE_BASIC_INFO         0x101
+#define SMB_SET_FILE_DISPOSITION_INFO   0x102
+#define SMB_SET_FILE_ALLOCATION_INFO    0x103
+#define SMB_SET_FILE_END_OF_FILE_INFO   0x104
+#define SMB_SET_FILE_UNIX_BASIC         0x200
+#define SMB_SET_FILE_UNIX_LINK          0x201
+#define SMB_SET_FILE_UNIX_HLINK         0x203
+#define SMB_SET_POSIX_ACL               0x204
+#define SMB_SET_XATTR                   0x205
+#define SMB_SET_ATTR_FLAGS              0x206  /* append, immutable etc. */
+#define SMB_SET_POSIX_LOCK              0x208
+#define SMB_POSIX_OPEN                  0x209
+#define SMB_POSIX_UNLINK                0x20a
+#define SMB_SET_FILE_UNIX_INFO2         0x20b
+#define SMB_SET_FILE_BASIC_INFO2        0x3ec
+#define SMB_SET_FILE_RENAME_INFORMATION 0x3f2 /* BB check if qpathinfo too */
+#define SMB_SET_FILE_DISPOSITION_INFORMATION   0x3f5   /* alias for 0x102 */
+#define SMB_FILE_ALL_INFO2              0x3fa
+#define SMB_SET_FILE_ALLOCATION_INFO2   0x3fb
+#define SMB_SET_FILE_END_OF_FILE_INFO2  0x3fc
+#define SMB_FILE_MOVE_CLUSTER_INFO      0x407
+#define SMB_FILE_QUOTA_INFO             0x408
+#define SMB_FILE_REPARSEPOINT_INFO      0x409
+#define SMB_FILE_MAXIMUM_INFO           0x40d
+
+/* Find File infolevels */
+#define SMB_FIND_FILE_INFO_STANDARD       0x001
+#define SMB_FIND_FILE_QUERY_EA_SIZE       0x002
+#define SMB_FIND_FILE_QUERY_EAS_FROM_LIST 0x003
+#define SMB_FIND_FILE_DIRECTORY_INFO      0x101
+#define SMB_FIND_FILE_FULL_DIRECTORY_INFO 0x102
+#define SMB_FIND_FILE_NAMES_INFO          0x103
+#define SMB_FIND_FILE_BOTH_DIRECTORY_INFO 0x104
+#define SMB_FIND_FILE_ID_FULL_DIR_INFO    0x105
+#define SMB_FIND_FILE_ID_BOTH_DIR_INFO    0x106
+#define SMB_FIND_FILE_UNIX                0x202
+
+struct smb_com_trans2_qpi_req {
+	struct smb_hdr hdr;     /* wct = 14+ */
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__le16 MaxParameterCount;
+	__le16 MaxDataCount;
+	__u8 MaxSetupCount;
+	__u8 Reserved;
+	__le16 Flags;
+	__le32 Timeout;
+	__u16 Reserved2;
+	__le16 ParameterCount;
+	__le16 ParameterOffset;
+	__le16 DataCount;
+	__le16 DataOffset;
+	__u8 SetupCount;
+	__u8 Reserved3;
+	__le16 SubCommand;      /* one setup word */
+	__le16 ByteCount;
+	__u8 Pad;
+	__le16 InformationLevel;
+	__u32 Reserved4;
+	char FileName[1];
+} __packed;
+
+struct trans2_qpi_req_params {
+	__le16 InformationLevel;
+	__u32 Reserved4;
+	char FileName[1];
+} __packed;
+
+/******************************************************************************/
+/* QueryFileInfo/QueryPathinfo (also for SetPath/SetFile) data buffer formats */
+/******************************************************************************/
+struct file_basic_info {
+	__le64 CreationTime;
+	__le64 LastAccessTime;
+	__le64 LastWriteTime;
+	__le64 ChangeTime;
+	__le32 Attributes;
+	__u32 Pad;
+} __packed;      /* size info, level 0x101 */
+
+struct file_standard_info {
+	__le64 AllocationSize;
+	__le64 EndOfFile;
+	__le32 NumberOfLinks;
+	__u8 DeletePending;
+	__u8 Directory;
+	__le16 Reserved;
+} __packed;
+
+struct file_ea_info {
+	__le32 EaSize;
+} __packed;
+
+struct alt_name_info {
+	__le32 FileNameLength;
+	char FileName[1];
+} __packed;
+
+struct file_name_info {
+	__le32 FileNameLength;
+	char FileName[1];
+} __packed;
+
+/* data block encoding of response to level 263 QPathInfo */
+struct file_all_info {
+	__le64 CreationTime;
+	__le64 LastAccessTime;
+	__le64 LastWriteTime;
+	__le64 ChangeTime;
+	__le32 Attributes;
+	__u32 Pad1;
+	__le64 AllocationSize;
+	__le64 EndOfFile;       /* size ie offset to first free byte in file */
+	__le32 NumberOfLinks;   /* hard links */
+	__u8 DeletePending;
+	__u8 Directory;
+	__u16 Pad2;
+	__le32 EASize;
+	__le32 FileNameLength;
+	char FileName[1];
+} __packed; /* level 0x107 QPathInfo */
+
+/* set path info/open file */
+/* defines for enumerating possible values of the Unix type field below */
+#define UNIX_FILE      0
+#define UNIX_DIR       1
+#define UNIX_SYMLINK   2
+#define UNIX_CHARDEV   3
+#define UNIX_BLOCKDEV  4
+#define UNIX_FIFO      5
+#define UNIX_SOCKET    6
+#define UNIX_UNKNOWN   0xFFFFFFFF
+
+struct file_unix_basic_info {
+	__le64 EndOfFile;
+	__le64 NumOfBytes;
+	__le64 LastStatusChange; /*SNIA specs DCE time for the 3 time fields */
+	__le64 LastAccessTime;
+	__le64 LastModificationTime;
+	__le64 Uid;
+	__le64 Gid;
+	__le32 Type;
+	__le64 DevMajor;
+	__le64 DevMinor;
+	__le64 UniqueId;
+	__le64 Permissions;
+	__le64 Nlinks;
+} __packed; /* level 0x200 QPathInfo */
+
+struct smb_com_trans2_spi_req {
+	struct smb_hdr hdr;     /* wct = 15 */
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__le16 MaxParameterCount;
+	__le16 MaxDataCount;
+	__u8 MaxSetupCount;
+	__u8 Reserved;
+	__le16 Flags;
+	__le32 Timeout;
+	__u16 Reserved2;
+	__le16 ParameterCount;
+	__le16 ParameterOffset;
+	__le16 DataCount;
+	__le16 DataOffset;
+	__u8 SetupCount;
+	__u8 Reserved3;
+	__le16 SubCommand;      /* one setup word */
+	__le16 ByteCount;
+	__u8 Pad;
+	__u16 Pad1;
+	__le16 InformationLevel;
+	__u32 Reserved4;
+	char FileName[1];
+} __packed;
+
+struct smb_com_trans2_spi_rsp {
+	struct smb_hdr hdr;     /* wct = 10 + SetupCount */
+	struct trans2_resp t2;
+	__le16 ByteCount;
+	__u16 Reserved2; /* parameter word is present for infolevels > 100 */
+} __packed;
+
+/* POSIX Open Flags */
+#define SMB_O_RDONLY     0x1
+#define SMB_O_WRONLY    0x2
+#define SMB_O_RDWR      0x4
+#define SMB_O_CREAT     0x10
+#define SMB_O_EXCL      0x20
+#define SMB_O_TRUNC     0x40
+#define SMB_O_APPEND    0x80
+#define SMB_O_SYNC      0x100
+#define SMB_O_DIRECTORY 0x200
+#define SMB_O_NOFOLLOW  0x400
+#define SMB_O_DIRECT    0x800
+#define SMB_ACCMODE	0x7
+
+/* info level response for SMB_POSIX_PATH_OPEN */
+#define SMB_NO_INFO_LEVEL_RESPONSE 0xFFFF
+
+struct open_psx_req {
+	__le32 OpenFlags; /* same as NT CreateX */
+	__le32 PosixOpenFlags;
+	__le64 Permissions;
+	__le16 Level; /* reply level requested (see QPathInfo levels) */
+} __packed; /* level 0x209 SetPathInfo data */
+
+struct open_psx_rsp {
+	__le16 OplockFlags;
+	__u16 Fid;
+	__le32 CreateAction;
+	__le16 ReturnedLevel;
+	__le16 Pad;
+	/* struct following varies based on requested level */
+} __packed; /* level 0x209 SetPathInfo data */
+
+struct unlink_psx_rsp {
+	__le16 EAErrorOffset;
+} __packed; /* level 0x209 SetPathInfo data*/
+
+/* Version numbers for CIFS UNIX major and minor. */
+#define CIFS_UNIX_MAJOR_VERSION 1
+#define CIFS_UNIX_MINOR_VERSION 0
+
+struct filesystem_unix_info {
+	__le16 MajorVersionNumber;
+	__le16 MinorVersionNumber;
+	__le64 Capability;
+} __packed; /* Unix extension level 0x200*/
+
+/* Linux/Unix extensions capability flags */
+#define CIFS_UNIX_FCNTL_CAP             0x00000001 /* support for fcntl locks */
+#define CIFS_UNIX_POSIX_ACL_CAP         0x00000002 /* support getfacl/setfacl */
+#define CIFS_UNIX_XATTR_CAP             0x00000004 /* support new namespace   */
+#define CIFS_UNIX_EXTATTR_CAP           0x00000008 /* support chattr/chflag   */
+#define CIFS_UNIX_POSIX_PATHNAMES_CAP   0x00000010 /* Allow POSIX path chars  */
+#define CIFS_UNIX_POSIX_PATH_OPS_CAP    0x00000020 /*
+						    * Allow new POSIX path based
+						    * calls including posix open
+						    * and posix unlink
+						    */
+#define CIFS_UNIX_LARGE_READ_CAP        0x00000040 /*
+						    * support reads >128K (up
+						    * to 0xFFFF00
+						    */
+#define CIFS_UNIX_LARGE_WRITE_CAP       0x00000080
+#define CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP 0x00000100 /* can do SPNEGO crypt */
+#define CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP  0x00000200 /* must do  */
+#define CIFS_UNIX_PROXY_CAP             0x00000400 /*
+						    * Proxy cap: 0xACE ioctl and
+						    * QFS PROXY call
+						    */
+#ifdef CONFIG_CIFS_POSIX
+/* presumably don't need the 0x20 POSIX_PATH_OPS_CAP since we never send
+ * LockingX instead of posix locking call on unix sess (and we do not expect
+ * LockingX to use different (ie Windows) semantics than posix locking on
+ * the same session (if WINE needs to do this later, we can add this cap
+ * back in later
+ */
+
+/* #define CIFS_UNIX_CAP_MASK              0x000000fb */
+#define CIFS_UNIX_CAP_MASK              0x000003db
+#else
+#define CIFS_UNIX_CAP_MASK              0x00000013
+#endif /* CONFIG_CIFS_POSIX */
+
+
+#define CIFS_POSIX_EXTENSIONS           0x00000010 /* support for new QFSInfo */
+
+/* Our server caps */
+
+#define SMB_UNIX_CAPS	(CIFS_UNIX_FCNTL_CAP | CIFS_UNIX_POSIX_ACL_CAP | \
+		CIFS_UNIX_XATTR_CAP | CIFS_UNIX_POSIX_PATHNAMES_CAP| \
+		CIFS_UNIX_POSIX_PATH_OPS_CAP | CIFS_UNIX_LARGE_READ_CAP | \
+		CIFS_UNIX_LARGE_WRITE_CAP)
+
+#define SMB_SET_CIFS_UNIX_INFO    0x200
+/* Level 0x200 request structure follows */
+struct smb_com_trans2_setfsi_req {
+	struct smb_hdr hdr;     /* wct = 15 */
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__le16 MaxParameterCount;
+	__le16 MaxDataCount;
+	__u8 MaxSetupCount;
+	__u8 Reserved;
+	__le16 Flags;
+	__le32 Timeout;
+	__u16 Reserved2;
+	__le16 ParameterCount;  /* 4 */
+	__le16 ParameterOffset;
+	__le16 DataCount;       /* 12 */
+	__le16 DataOffset;
+	__u8 SetupCount;        /* one */
+	__u8 Reserved3;
+	__le16 SubCommand;      /* TRANS2_SET_FS_INFORMATION */
+	__le16 ByteCount;
+	__u8 Pad;
+	__u16 FileNum;          /* Parameters start. */
+	__le16 InformationLevel;/* Parameters end. */
+	__le16 ClientUnixMajor; /* Data start. */
+	__le16 ClientUnixMinor;
+	__le64 ClientUnixCap;   /* Data end */
+} __packed;
+
+/* response for setfsinfo levels 0x200 and 0x203 */
+struct smb_com_trans2_setfsi_rsp {
+	struct smb_hdr hdr;     /* wct = 10 */
+	struct trans2_resp t2;
+	__le16 ByteCount;
+} __packed;
+
+struct smb_com_trans2_setfsi_req_params {
+	__u16 FileNum;
+	__le16 InformationLevel;
+	__le16 ClientUnixMajor; /* Data start. */
+	__le16 ClientUnixMinor;
+	__le64 ClientUnixCap;   /* Data end */
+} __packed;
+
+struct smb_trans2_qfi_req_params {
+	__u16   Fid;
+	__le16  InformationLevel;
+} __packed;
+
+/* FIND FIRST2 and FIND NEXT2 INFORMATION Level Codes*/
+
+struct find_info_standard {
+	__le16 CreationDate; /* SMB Date see above */
+	__le16 CreationTime; /* SMB Time */
+	__le16 LastAccessDate;
+	__le16 LastAccessTime;
+	__le16 LastWriteDate;
+	__le16 LastWriteTime;
+	__le32 DataSize; /* File Size (EOF) */
+	__le32 AllocationSize;
+	__le16 Attributes; /* verify not u32 */
+	__le16 FileNameLength;
+	char FileName[1];
+} __packed;
+
+struct find_info_query_ea_size {
+	__le16 CreationDate; /* SMB Date see above */
+	__le16 CreationTime; /* SMB Time */
+	__le16 LastAccessDate;
+	__le16 LastAccessTime;
+	__le16 LastWriteDate;
+	__le16 LastWriteTime;
+	__le32 DataSize; /* File Size (EOF) */
+	__le32 AllocationSize;
+	__le16 Attributes; /* verify not u32 */
+	__le32 EASize;
+	__u8 FileNameLength;
+	char FileName[1];
+} __packed;
+
+struct file_unix_info {
+	__le32 NextEntryOffset;
+	__u32 ResumeKey; /* as with FileIndex - no need to convert */
+	struct file_unix_basic_info basic;
+	char FileName[1];
+} __packed; /* level 0x202 */
+
+struct smb_com_trans2_sfi_req {
+	struct smb_hdr hdr;     /* wct = 15 */
+	__le16 TotalParameterCount;
+	__le16 TotalDataCount;
+	__le16 MaxParameterCount;
+	__le16 MaxDataCount;
+	__u8 MaxSetupCount;
+	__u8 Reserved;
+	__le16 Flags;
+	__le32 Timeout;
+	__u16 Reserved2;
+	__le16 ParameterCount;
+	__le16 ParameterOffset;
+	__le16 DataCount;
+	__le16 DataOffset;
+	__u8 SetupCount;
+	__u8 Reserved3;
+	__le16 SubCommand;      /* one setup word */
+	__le16 ByteCount;
+	__u8 Pad;
+	__u16 Pad1;
+	__u16 Fid;
+	__le16 InformationLevel;
+	__u16 Reserved4;
+} __packed;
+
+struct smb_com_trans2_sfi_rsp {
+	struct smb_hdr hdr;     /* wct = 10 + SetupCount */
+	struct trans2_resp t2;
+	__le16 ByteCount;
+	__u16 Reserved2;        /*
+				 * parameter word reserved -
+				 * present for infolevels > 100
+				 */
+} __packed;
+
+struct file_end_of_file_info {
+	__le64 FileSize;                /* offset to end of file */
+} __packed; /* size info, level 0x104 for set, 0x106 for query */
+
+struct smb_com_create_directory_req {
+	struct smb_hdr hdr;	/* wct = 0 */
+	__le16 ByteCount;
+	__u8 BufferFormat;	/* 4 = ASCII */
+	unsigned char DirName[1];
+} __packed;
+
+struct smb_com_create_directory_rsp {
+	struct smb_hdr hdr;	/* wct = 0 */
+	__le16 ByteCount;	/* bct = 0 */
+} __packed;
+
+struct smb_com_check_directory_req {
+	struct smb_hdr hdr;	/* wct = 0 */
+	__le16 ByteCount;
+	__u8 BufferFormat;	/* 4 = ASCII */
+	unsigned char DirName[1];
+} __packed;
+
+struct smb_com_check_directory_rsp {
+	struct smb_hdr hdr;	/* wct = 0 */
+	__le16 ByteCount;	/* bct = 0 */
+} __packed;
+
+struct smb_com_process_exit_rsp {
+	struct smb_hdr hdr;	/* wct = 0 */
+	__le16 ByteCount;	/* bct = 0 */
+} __packed;
+
+struct smb_com_delete_directory_req {
+	struct smb_hdr hdr;     /* wct = 0 */
+	__le16 ByteCount;
+	__u8 BufferFormat;      /* 4 = ASCII */
+	unsigned char DirName[1];
+} __packed;
+
+struct smb_com_delete_directory_rsp {
+	struct smb_hdr hdr;     /* wct = 0 */
+	__le16 ByteCount;        /* bct = 0 */
+} __packed;
+
+struct smb_com_delete_file_req {
+	struct smb_hdr hdr;     /* wct = 1 */
+	__le16 SearchAttributes;
+	__le16 ByteCount;
+	__u8 BufferFormat;      /* 4 = ASCII */
+	unsigned char fileName[1];
+} __packed;
+
+struct smb_com_delete_file_rsp {
+	struct smb_hdr hdr;     /* wct = 0 */
+	__le16 ByteCount;        /* bct = 0 */
+} __packed;
+
+#define CREATE_HARD_LINK         0x103
+
+struct smb_com_nt_rename_req {  /* A5 - also used for create hardlink */
+	struct smb_hdr hdr;     /* wct = 4 */
+	__le16 SearchAttributes;        /* target file attributes */
+	__le16 Flags;           /* spec says Information Level */
+	__le32 ClusterCount;
+	__le16 ByteCount;
+	__u8 BufferFormat;      /* 4 = ASCII or Unicode */
+	unsigned char OldFileName[1];
+	/* followed by __u8 BufferFormat2 */
+	/* followed by NewFileName */
+} __packed;
+
+struct smb_com_query_information_req {
+	struct smb_hdr hdr;     /* wct = 0 */
+	__le16 ByteCount;       /* 1 + namelen + 1 */
+	__u8 BufferFormat;      /* 4 = ASCII */
+	unsigned char FileName[1];
+} __packed;
+
+struct smb_com_query_information_rsp {
+	struct smb_hdr hdr;     /* wct = 10 */
+	__le16 attr;
+	__le32  last_write_time;
+	__le32 size;
+	__u16  reserved[5];
+	__le16 ByteCount;       /* bcc = 0 */
+} __packed;
+
+struct smb_com_findclose_req {
+	struct smb_hdr hdr; /* wct = 1 */
+	__u16 FileID;
+	__le16 ByteCount;    /* 0 */
+} __packed;
+
+#define SMBOPEN_DISPOSITION_NONE        0
+#define SMBOPEN_LOCK_GRANTED            0x8000
+
+#define SMB_DA_ACCESS_READ              0
+#define SMB_DA_ACCESS_WRITE             0x0001
+#define SMB_DA_ACCESS_READ_WRITE        0x0002
+
+/*
+ * Flags on SMB open
+ */
+#define SMBOPEN_WRITE_THROUGH 0x4000
+#define SMBOPEN_DENY_ALL      0x0010
+#define SMBOPEN_DENY_WRITE    0x0020
+#define SMBOPEN_DENY_READ     0x0030
+#define SMBOPEN_DENY_NONE     0x0040
+#define SMBOPEN_SHARING_MODE  (SMBOPEN_DENY_ALL |	\
+				SMBOPEN_DENY_WRITE |	\
+				SMBOPEN_DENY_READ |	\
+				SMBOPEN_DENY_NONE)
+#define SMBOPEN_READ          0x0000
+#define SMBOPEN_WRITE         0x0001
+#define SMBOPEN_READWRITE     0x0002
+#define SMBOPEN_EXECUTE       0x0003
+
+#define SMBOPEN_OCREATE       0x0010
+#define SMBOPEN_OTRUNC        0x0002
+#define SMBOPEN_OAPPEND       0x0001
+
+/* format of legacy open request */
+struct smb_com_openx_req {
+	struct smb_hdr  hdr;    /* wct = 15 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__le16 OpenFlags;
+	__le16 Mode;
+	__le16 Sattr; /* search attributes */
+	__le16 FileAttributes;  /* dos attrs */
+	__le32 CreateTime; /* os2 format */
+	__le16 OpenFunction;
+	__le32 EndOfFile;
+	__le32 Timeout;
+	__le32 Reserved;
+	__le16  ByteCount;  /* file name follows */
+	char   fileName[1];
+} __packed;
+
+struct smb_com_openx_rsp {
+	struct smb_hdr  hdr;    /* wct = 15 */
+	__u8 AndXCommand;
+	__u8 AndXReserved;
+	__le16 AndXOffset;
+	__u16  Fid;
+	__le16 FileAttributes;
+	__le32 LastWriteTime; /* os2 format */
+	__le32 EndOfFile;
+	__le16 Access;
+	__le16 FileType;
+	__le16 IPCState;
+	__le16 Action;
+	__u32  FileId;
+	__u16  Reserved;
+	__le16 ByteCount;
+} __packed;
+
+struct filesystem_alloc_info {
+	__le32 fsid;
+	__le32 SectorsPerAllocationUnit;
+	__le32 TotalAllocationUnits;
+	__le32 FreeAllocationUnits;
+	__le16  BytesPerSector;
+} __packed;
+
+struct file_allocation_info {
+	__le64 AllocationSize; /* Note old Samba srvr rounds this up too much */
+} __packed;      /* size used on disk: 0x103 for set, 0x105 for query */
+
+struct file_info_standard {
+	__le16 CreationDate; /* SMB Date see above */
+	__le16 CreationTime; /* SMB Time */
+	__le16 LastAccessDate;
+	__le16 LastAccessTime;
+	__le16 LastWriteDate;
+	__le16 LastWriteTime;
+	__le32 DataSize; /* File Size (EOF) */
+	__le32 AllocationSize;
+	__le16 Attributes; /* verify not u32 */
+	__le32 EASize;
+} __packed;  /* level 1 SetPath/FileInfo */
+
+#define CIFS_MF_SYMLINK_LINK_MAXLEN (1024)
+
+struct set_file_rename {
+	__le32 overwrite;   /* 1 = overwrite dest */
+	__u32 root_fid;   /* zero */
+	__le32 target_name_len;
+	char  target_name[0];  /* Must be unicode */
+} __packed;
+
+struct fea {
+	unsigned char EA_flags;
+	__u8 name_len;
+	__le16 value_len;
+	char name[1];
+	/* optionally followed by value */
+} __packed;
+
+struct fealist {
+	__le32 list_len;
+	__u8 list[1];
+} __packed;
+
+/* POSIX ACL set/query path info structures */
+#define CIFS_ACL_VERSION 1
+struct cifs_posix_ace { /* access control entry (ACE) */
+	__u8  cifs_e_tag;
+	__u8  cifs_e_perm;
+	__le64 cifs_uid; /* or gid */
+} __packed;
+
+struct cifs_posix_acl { /* access conrol list  (ACL) */
+	__le16  version;
+	__le16  access_entry_count;  /* access ACL - count of entries */
+	__le16  default_entry_count; /* default ACL - count of entries */
+	struct cifs_posix_ace ace_array[0];
+	/*
+	 * followed by
+	 * struct cifs_posix_ace default_ace_arraay[]
+	 */
+} __packed;  /* level 0x204 */
+
+struct smb_com_setattr_req {
+	struct smb_hdr hdr; /* wct = 8 */
+	__le16 attr;
+	__le32 LastWriteTime;
+	__le16 reserved[5]; /* must be zero */
+	__le16 ByteCount;
+	__u8   BufferFormat; /* 4 = ASCII */
+	unsigned char fileName[1];
+} __packed;
+
+struct smb_com_setattr_rsp {
+	struct smb_hdr hdr;     /* wct = 0 */
+	__le16 ByteCount;        /* bct = 0 */
+} __packed;
+
+#ifdef CONFIG_SMB_INSECURE_SERVER
+extern int init_smb1_server(struct ksmbd_conn *conn);
+#endif
+
+/* function prototypes */
+extern int init_smb_rsp_hdr(struct ksmbd_work *work);
+extern u16 get_smb_cmd_val(struct ksmbd_work *work);
+extern void set_smb_rsp_status(struct ksmbd_work *work, __le32 err);
+extern int smb_allocate_rsp_buf(struct ksmbd_work *work);
+extern bool smb1_is_sign_req(struct ksmbd_work *work, unsigned int command);
+extern int smb1_check_sign_req(struct ksmbd_work *work);
+extern void smb1_set_sign_rsp(struct ksmbd_work *work);
+extern int smb_check_user_session(struct ksmbd_work *work);
+extern int smb_get_ksmbd_tcon(struct ksmbd_work *work);
+extern int ksmbd_smb1_check_message(struct ksmbd_work *work);
+
+/* smb1 command handlers */
+extern int smb_rename(struct ksmbd_work *work);
+extern int smb_negotiate_request(struct ksmbd_work *work);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+extern int smb_handle_negotiate(struct ksmbd_work *work);
+#endif
+extern int smb_session_setup_andx(struct ksmbd_work *work);
+extern int smb_tree_connect_andx(struct ksmbd_work *work);
+extern int smb_trans2(struct ksmbd_work *work);
+extern int smb_nt_create_andx(struct ksmbd_work *work);
+extern int smb_trans(struct ksmbd_work *work);
+extern int smb_locking_andx(struct ksmbd_work *work);
+extern int smb_close(struct ksmbd_work *work);
+extern int smb_read_andx(struct ksmbd_work *work);
+extern int smb_tree_disconnect(struct ksmbd_work *work);
+extern int smb_session_disconnect(struct ksmbd_work *work);
+extern int smb_write_andx(struct ksmbd_work *work);
+extern int smb_echo(struct ksmbd_work *work);
+extern int smb_flush(struct ksmbd_work *work);
+extern int smb_mkdir(struct ksmbd_work *work);
+extern int smb_rmdir(struct ksmbd_work *work);
+extern int smb_unlink(struct ksmbd_work *work);
+extern int smb_nt_cancel(struct ksmbd_work *work);
+extern int smb_nt_rename(struct ksmbd_work *work);
+extern int smb_query_info(struct ksmbd_work *work);
+extern int smb_closedir(struct ksmbd_work *work);
+extern int smb_open_andx(struct ksmbd_work *work);
+extern int smb_write(struct ksmbd_work *work);
+extern int smb_setattr(struct ksmbd_work *work);
+extern int smb_query_information_disk(struct ksmbd_work *work);
+extern int smb_checkdir(struct ksmbd_work *work);
+extern int smb_process_exit(struct ksmbd_work *work);
+#endif /* __SMB1PDU_H */
diff --git a/fs/ksmbd/smb2misc.c b/fs/ksmbd/smb2misc.c
index fbdde426dd01..25e981f447c0 100644
--- a/fs/ksmbd/smb2misc.c
+++ b/fs/ksmbd/smb2misc.c
@@ -6,6 +6,7 @@
 
 #include "glob.h"
 #include "nterr.h"
+#include "smb2pdu.h"
 #include "smb_common.h"
 #include "smbstatus.h"
 #include "mgmt/user_session.h"
@@ -351,9 +352,16 @@ int ksmbd_smb2_check_message(struct ksmbd_work *work)
 	int command;
 	__u32 clc_len;  /* calculated length */
 	__u32 len = get_rfc1002_len(work->request_buf);
+	__u32 req_struct_size, next_cmd = le32_to_cpu(hdr->NextCommand);
 
-	if (le32_to_cpu(hdr->NextCommand) > 0)
-		len = le32_to_cpu(hdr->NextCommand);
+	if ((u64)work->next_smb2_rcv_hdr_off + next_cmd > len) {
+		pr_err("next command(%u) offset exceeds smb msg size\n",
+				next_cmd);
+		return 1;
+	}
+
+	if (next_cmd > 0)
+		len = next_cmd;
 	else if (work->next_smb2_rcv_hdr_off)
 		len -= work->next_smb2_rcv_hdr_off;
 
@@ -373,25 +381,25 @@ int ksmbd_smb2_check_message(struct ksmbd_work *work)
 	}
 
 	if (smb2_req_struct_sizes[command] != pdu->StructureSize2) {
-		if (command != SMB2_OPLOCK_BREAK_HE &&
-		    (hdr->Status == 0 || pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) {
-			/* error packets have 9 byte structure size */
-			ksmbd_debug(SMB,
-				    "Illegal request size %u for command %d\n",
-				    le16_to_cpu(pdu->StructureSize2), command);
-			return 1;
-		} else if (command == SMB2_OPLOCK_BREAK_HE &&
-			   hdr->Status == 0 &&
-			   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 &&
-			   le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) {
+		if (!(command == SMB2_OPLOCK_BREAK_HE &&
+		    (le16_to_cpu(pdu->StructureSize2) == OP_BREAK_STRUCT_SIZE_20 ||
+		    le16_to_cpu(pdu->StructureSize2) == OP_BREAK_STRUCT_SIZE_21))) {
 			/* special case for SMB2.1 lease break message */
 			ksmbd_debug(SMB,
-				    "Illegal request size %d for oplock break\n",
-				    le16_to_cpu(pdu->StructureSize2));
+				"Illegal request size %u for command %d\n",
+				le16_to_cpu(pdu->StructureSize2), command);
 			return 1;
 		}
 	}
 
+	req_struct_size = le16_to_cpu(pdu->StructureSize2) +
+		__SMB2_HEADER_STRUCTURE_SIZE;
+	if (command == SMB2_LOCK_HE)
+		req_struct_size -= sizeof(struct smb2_lock_element);
+
+	if (req_struct_size > len + 1)
+		return 1;
+
 	if (smb2_calc_size(hdr, &clc_len))
 		return 1;
 
@@ -416,8 +424,11 @@ int ksmbd_smb2_check_message(struct ksmbd_work *work)
 
 		/*
 		 * Allow a message that padded to 8byte boundary.
+		 * Linux 4.19.217 with smb 3.0.2 are sometimes
+		 * sending messages where the cls_len is exactly
+		 * 8 bytes less than len.
 		 */
-		if (clc_len < len && (len - clc_len) < 8)
+		if (clc_len < len && (len - clc_len) <= 8)
 			goto validate_credit;
 
 		pr_err_ratelimited(
@@ -430,10 +441,8 @@ int ksmbd_smb2_check_message(struct ksmbd_work *work)
 
 validate_credit:
 	if ((work->conn->vals->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU) &&
-	    smb2_validate_credit_charge(work->conn, hdr)) {
-		work->conn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER);
+	    smb2_validate_credit_charge(work->conn, hdr))
 		return 1;
-	}
 
 	return 0;
 }
diff --git a/fs/ksmbd/smb2ops.c b/fs/ksmbd/smb2ops.c
index e401302478c3..f58edb5f44f6 100644
--- a/fs/ksmbd/smb2ops.c
+++ b/fs/ksmbd/smb2ops.c
@@ -6,12 +6,41 @@
 
 #include <linux/slab.h>
 #include "glob.h"
+#include "smb2pdu.h"
 
 #include "auth.h"
 #include "connection.h"
 #include "smb_common.h"
 #include "server.h"
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+static struct smb_version_values smb20_server_values = {
+	.version_string = SMB20_VERSION_STRING,
+	.protocol_id = SMB20_PROT_ID,
+	.capabilities = 0,
+	.max_read_size = CIFS_DEFAULT_IOSIZE,
+	.max_write_size = CIFS_DEFAULT_IOSIZE,
+	.max_trans_size = CIFS_DEFAULT_IOSIZE,
+	.max_credits = SMB2_MAX_CREDITS,
+	.large_lock_type = 0,
+	.exclusive_lock_type = SMB2_LOCKFLAG_EXCLUSIVE,
+	.shared_lock_type = SMB2_LOCKFLAG_SHARED,
+	.unlock_lock_type = SMB2_LOCKFLAG_UNLOCK,
+	.header_size = sizeof(struct smb2_hdr),
+	.max_header_size = MAX_SMB2_HDR_SIZE,
+	.read_rsp_size = sizeof(struct smb2_read_rsp) - 1,
+	.lock_cmd = SMB2_LOCK,
+	.cap_unix = 0,
+	.cap_nt_find = SMB2_NT_FIND,
+	.cap_large_files = SMB2_LARGE_FILES,
+	.create_lease_size = sizeof(struct create_lease),
+	.create_durable_size = sizeof(struct create_durable_rsp),
+	.create_mxac_size = sizeof(struct create_mxac_rsp),
+	.create_disk_id_size = sizeof(struct create_disk_id_rsp),
+	.create_posix_size = sizeof(struct create_posix_rsp),
+};
+#endif
+
 static struct smb_version_values smb21_server_values = {
 	.version_string = SMB21_VERSION_STRING,
 	.protocol_id = SMB21_PROT_ID,
@@ -190,6 +219,28 @@ static struct smb_version_cmds smb2_0_server_cmds[NUMBER_OF_SMB2_COMMANDS] = {
 	[SMB2_CHANGE_NOTIFY_HE]	=	{ .proc = smb2_notify},
 };
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+/**
+ * init_smb2_0_server() - initialize a smb server connection with smb2.0
+ *			command dispatcher
+ * @conn:	connection instance
+ */
+int init_smb2_0_server(struct ksmbd_conn *conn)
+{
+	conn->vals = &smb20_server_values;
+	conn->ops = &smb2_0_server_ops;
+	conn->cmds = smb2_0_server_cmds;
+	conn->max_cmds = ARRAY_SIZE(smb2_0_server_cmds);
+	conn->signing_algorithm = SIGNING_ALG_HMAC_SHA256;
+	return 0;
+}
+#else
+int init_smb2_0_server(struct ksmbd_conn *conn)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
 /**
  * init_smb2_1_server() - initialize a smb server connection with smb2.1
  *			command dispatcher
@@ -201,7 +252,7 @@ void init_smb2_1_server(struct ksmbd_conn *conn)
 	conn->ops = &smb2_0_server_ops;
 	conn->cmds = smb2_0_server_cmds;
 	conn->max_cmds = ARRAY_SIZE(smb2_0_server_cmds);
-	conn->signing_algorithm = SIGNING_ALG_HMAC_SHA256_LE;
+	conn->signing_algorithm = SIGNING_ALG_HMAC_SHA256;
 
 	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_LEASES)
 		conn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING;
@@ -218,13 +269,15 @@ void init_smb3_0_server(struct ksmbd_conn *conn)
 	conn->ops = &smb3_0_server_ops;
 	conn->cmds = smb2_0_server_cmds;
 	conn->max_cmds = ARRAY_SIZE(smb2_0_server_cmds);
-	conn->signing_algorithm = SIGNING_ALG_AES_CMAC_LE;
+	conn->signing_algorithm = SIGNING_ALG_AES_CMAC;
 
 	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_LEASES)
-		conn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING;
+		conn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING |
+			SMB2_GLOBAL_CAP_DIRECTORY_LEASING;
 
-	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION &&
-	    conn->cli_cap & SMB2_GLOBAL_CAP_ENCRYPTION)
+	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION ||
+	    (!(server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION_OFF) &&
+	     conn->cli_cap & SMB2_GLOBAL_CAP_ENCRYPTION))
 		conn->vals->capabilities |= SMB2_GLOBAL_CAP_ENCRYPTION;
 
 	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL)
@@ -242,10 +295,11 @@ void init_smb3_02_server(struct ksmbd_conn *conn)
 	conn->ops = &smb3_0_server_ops;
 	conn->cmds = smb2_0_server_cmds;
 	conn->max_cmds = ARRAY_SIZE(smb2_0_server_cmds);
-	conn->signing_algorithm = SIGNING_ALG_AES_CMAC_LE;
+	conn->signing_algorithm = SIGNING_ALG_AES_CMAC;
 
 	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_LEASES)
-		conn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING;
+		conn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING |
+			SMB2_GLOBAL_CAP_DIRECTORY_LEASING;
 
 	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION ||
 	    (!(server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION_OFF) &&
@@ -267,15 +321,11 @@ int init_smb3_11_server(struct ksmbd_conn *conn)
 	conn->ops = &smb3_11_server_ops;
 	conn->cmds = smb2_0_server_cmds;
 	conn->max_cmds = ARRAY_SIZE(smb2_0_server_cmds);
-	conn->signing_algorithm = SIGNING_ALG_AES_CMAC_LE;
+	conn->signing_algorithm = SIGNING_ALG_AES_CMAC;
 
 	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_LEASES)
-		conn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING;
-
-	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION ||
-	    (!(server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_ENCRYPTION_OFF) &&
-	     conn->cli_cap & SMB2_GLOBAL_CAP_ENCRYPTION))
-		conn->vals->capabilities |= SMB2_GLOBAL_CAP_ENCRYPTION;
+		conn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING |
+			SMB2_GLOBAL_CAP_DIRECTORY_LEASING;
 
 	if (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL)
 		conn->vals->capabilities |= SMB2_GLOBAL_CAP_MULTI_CHANNEL;
diff --git a/fs/ksmbd/smb2pdu.c b/fs/ksmbd/smb2pdu.c
index 53badff17efa..334e4a92524f 100644
--- a/fs/ksmbd/smb2pdu.c
+++ b/fs/ksmbd/smb2pdu.c
@@ -11,9 +11,16 @@
 #include <linux/statfs.h>
 #include <linux/ethtool.h>
 #include <linux/falloc.h>
+#include <linux/crc32.h>
 #include <linux/mount.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#include <linux/filelock.h>
+#endif
 
+#include "compat.h"
 #include "glob.h"
+#include "smb2pdu.h"
 #include "smbfsctl.h"
 #include "oplock.h"
 #include "smbacl.h"
@@ -86,11 +93,10 @@ struct channel *lookup_chann_list(struct ksmbd_session *sess, struct ksmbd_conn
  */
 int smb2_get_ksmbd_tcon(struct ksmbd_work *work)
 {
-	struct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);
+	struct smb2_hdr *req_hdr = ksmbd_req_buf_next(work);
 	unsigned int cmd = le16_to_cpu(req_hdr->Command);
-	int tree_id;
+	unsigned int tree_id;
 
-	work->tcon = NULL;
 	if (cmd == SMB2_TREE_CONNECT_HE ||
 	    cmd ==  SMB2_CANCEL_HE ||
 	    cmd ==  SMB2_LOGOFF_HE) {
@@ -104,10 +110,28 @@ int smb2_get_ksmbd_tcon(struct ksmbd_work *work)
 	}
 
 	tree_id = le32_to_cpu(req_hdr->Id.SyncId.TreeId);
+
+	/*
+	 * If request is not the first in Compound request,
+	 * Just validate tree id in header with work->tcon->id.
+	 */
+	if (work->next_smb2_rcv_hdr_off) {
+		if (!work->tcon) {
+			pr_err("The first operation in the compound does not have tcon\n");
+			return -EINVAL;
+		}
+		if (tree_id != UINT_MAX && work->tcon->id != tree_id) {
+			pr_err("tree id(%u) is different with id(%u) in first operation\n",
+					tree_id, work->tcon->id);
+			return -EINVAL;
+		}
+		return 1;
+	}
+
 	work->tcon = ksmbd_tree_conn_lookup(work->sess, tree_id);
 	if (!work->tcon) {
 		pr_err("Invalid tid %d\n", tree_id);
-		return -EINVAL;
+		return -ENOENT;
 	}
 
 	return 1;
@@ -127,12 +151,18 @@ void smb2_set_err_rsp(struct ksmbd_work *work)
 		err_rsp = smb2_get_msg(work->response_buf);
 
 	if (err_rsp->hdr.Status != STATUS_STOPPED_ON_SYMLINK) {
+		int err;
+
 		err_rsp->StructureSize = SMB2_ERROR_STRUCTURE_SIZE2_LE;
 		err_rsp->ErrorContextCount = 0;
 		err_rsp->Reserved = 0;
 		err_rsp->ByteCount = 0;
 		err_rsp->ErrorData[0] = 0;
-		inc_rfc1001_len(work->response_buf, SMB2_ERROR_STRUCTURE_SIZE2);
+		err = ksmbd_iov_pin_rsp(work, (void *)err_rsp,
+					__SMB2_HEADER_STRUCTURE_SIZE +
+					SMB2_ERROR_STRUCTURE_SIZE2);
+		if (err)
+			work->send_no_response = 1;
 	}
 }
 
@@ -207,11 +237,12 @@ void set_smb2_rsp_status(struct ksmbd_work *work, __le32 err)
 {
 	struct smb2_hdr *rsp_hdr;
 
-	if (work->next_smb2_rcv_hdr_off)
-		rsp_hdr = ksmbd_resp_buf_next(work);
-	else
-		rsp_hdr = smb2_get_msg(work->response_buf);
+	rsp_hdr = smb2_get_msg(work->response_buf);
 	rsp_hdr->Status = err;
+
+	work->iov_idx = 0;
+	work->iov_cnt = 0;
+	work->next_smb2_rcv_hdr_off = 0;
 	smb2_set_err_rsp(work);
 }
 
@@ -227,9 +258,7 @@ int init_smb2_neg_rsp(struct ksmbd_work *work)
 	struct smb2_hdr *rsp_hdr;
 	struct smb2_negotiate_rsp *rsp;
 	struct ksmbd_conn *conn = work->conn;
-
-	*(__be32 *)work->response_buf =
-		cpu_to_be32(conn->vals->header_size);
+	int err;
 
 	rsp_hdr = smb2_get_msg(work->response_buf);
 	memset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);
@@ -268,13 +297,13 @@ int init_smb2_neg_rsp(struct ksmbd_work *work)
 	rsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);
 	ksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +
 		le16_to_cpu(rsp->SecurityBufferOffset));
-	inc_rfc1001_len(work->response_buf,
-			sizeof(struct smb2_negotiate_rsp) -
-			sizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +
-			AUTH_GSS_LENGTH);
 	rsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;
 	if (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY)
 		rsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;
+	err = ksmbd_iov_pin_rsp(work, rsp, sizeof(struct smb2_negotiate_rsp) +
+				AUTH_GSS_LENGTH);
+	if (err)
+		return err;
 	conn->use_spnego = true;
 
 	ksmbd_conn_set_need_negotiate(conn);
@@ -326,13 +355,9 @@ int smb2_set_rsp_credits(struct ksmbd_work *work)
 	if (hdr->Command == SMB2_NEGOTIATE)
 		aux_max = 1;
 	else
-		aux_max = conn->vals->max_credits - credit_charge;
+		aux_max = conn->vals->max_credits - conn->total_credits;
 	credits_granted = min_t(unsigned short, credits_requested, aux_max);
 
-	if (conn->vals->max_credits - conn->total_credits < credits_granted)
-		credits_granted = conn->vals->max_credits -
-			conn->total_credits;
-
 	conn->total_credits += credits_granted;
 	work->credits_granted += credits_granted;
 
@@ -377,11 +402,12 @@ static void init_chained_smb2_rsp(struct ksmbd_work *work)
 	next_hdr_offset = le32_to_cpu(req->NextCommand);
 
 	new_len = ALIGN(len, 8);
-	inc_rfc1001_len(work->response_buf,
-			sizeof(struct smb2_hdr) + new_len - len);
+	work->iov[work->iov_idx].iov_len += (new_len - len);
+	inc_rfc1001_len(work->response_buf, new_len - len);
 	rsp->NextCommand = cpu_to_le32(new_len);
 
 	work->next_smb2_rcv_hdr_off += next_hdr_offset;
+	work->curr_smb2_rsp_hdr_off = work->next_smb2_rsp_hdr_off;
 	work->next_smb2_rsp_hdr_off += new_len;
 	ksmbd_debug(SMB,
 		    "Compound req new_len = %d rcv off = %d rsp off = %d\n",
@@ -457,10 +483,10 @@ bool is_chained_smb2_message(struct ksmbd_work *work)
 		len = len - get_rfc1002_len(work->response_buf);
 		if (len) {
 			ksmbd_debug(SMB, "padding len %u\n", len);
+			work->iov[work->iov_idx].iov_len += len;
 			inc_rfc1001_len(work->response_buf, len);
-			if (work->aux_payload_sz)
-				work->aux_payload_sz += len;
 		}
+		work->curr_smb2_rsp_hdr_off = work->next_smb2_rsp_hdr_off;
 	}
 	return false;
 }
@@ -475,11 +501,8 @@ int init_smb2_rsp_hdr(struct ksmbd_work *work)
 {
 	struct smb2_hdr *rsp_hdr = smb2_get_msg(work->response_buf);
 	struct smb2_hdr *rcv_hdr = smb2_get_msg(work->request_buf);
-	struct ksmbd_conn *conn = work->conn;
 
 	memset(rsp_hdr, 0, sizeof(struct smb2_hdr) + 2);
-	*(__be32 *)work->response_buf =
-		cpu_to_be32(conn->vals->header_size);
 	rsp_hdr->ProtocolId = rcv_hdr->ProtocolId;
 	rsp_hdr->StructureSize = SMB2_HEADER_STRUCTURE_SIZE;
 	rsp_hdr->Command = rcv_hdr->Command;
@@ -495,12 +518,6 @@ int init_smb2_rsp_hdr(struct ksmbd_work *work)
 	rsp_hdr->SessionId = rcv_hdr->SessionId;
 	memcpy(rsp_hdr->Signature, rcv_hdr->Signature, 16);
 
-	work->syncronous = true;
-	if (work->async_id) {
-		ksmbd_release_id(&conn->async_ida, work->async_id);
-		work->async_id = 0;
-	}
-
 	return 0;
 }
 
@@ -536,7 +553,7 @@ int smb2_allocate_rsp_buf(struct ksmbd_work *work)
 	if (le32_to_cpu(hdr->NextCommand) > 0)
 		sz = large_sz;
 
-	work->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);
+	work->response_buf = kvzalloc(sz, GFP_KERNEL);
 	if (!work->response_buf)
 		return -ENOMEM;
 
@@ -552,12 +569,11 @@ int smb2_allocate_rsp_buf(struct ksmbd_work *work)
  */
 int smb2_check_user_session(struct ksmbd_work *work)
 {
-	struct smb2_hdr *req_hdr = smb2_get_msg(work->request_buf);
+	struct smb2_hdr *req_hdr = ksmbd_req_buf_next(work);
 	struct ksmbd_conn *conn = work->conn;
-	unsigned int cmd = conn->ops->get_cmd_val(work);
+	unsigned int cmd = le16_to_cpu(req_hdr->Command);
 	unsigned long long sess_id;
 
-	work->sess = NULL;
 	/*
 	 * SMB2_ECHO, SMB2_NEGOTIATE, SMB2_SESSION_SETUP command do not
 	 * require a session id, so no need to validate user session's for
@@ -568,15 +584,33 @@ int smb2_check_user_session(struct ksmbd_work *work)
 		return 0;
 
 	if (!ksmbd_conn_good(conn))
-		return -EINVAL;
+		return -EIO;
 
 	sess_id = le64_to_cpu(req_hdr->SessionId);
+
+	/*
+	 * If request is not the first in Compound request,
+	 * Just validate session id in header with work->sess->id.
+	 */
+	if (work->next_smb2_rcv_hdr_off) {
+		if (!work->sess) {
+			pr_err("The first operation in the compound does not have sess\n");
+			return -EINVAL;
+		}
+		if (sess_id != ULLONG_MAX && work->sess->id != sess_id) {
+			pr_err("session id(%llu) is different with the first operation(%lld)\n",
+					sess_id, work->sess->id);
+			return -EINVAL;
+		}
+		return 1;
+	}
+
 	/* Check for validity of user session */
 	work->sess = ksmbd_session_lookup_all(conn, sess_id);
 	if (work->sess)
 		return 1;
 	ksmbd_debug(SMB, "Invalid user session, Uid %llu\n", sess_id);
-	return -EINVAL;
+	return -ENOENT;
 }
 
 static void destroy_previous_session(struct ksmbd_conn *conn,
@@ -629,21 +663,16 @@ smb2_get_name(const char *src, const int maxlen, struct nls_table *local_nls)
 
 int setup_async_work(struct ksmbd_work *work, void (*fn)(void **), void **arg)
 {
-	struct smb2_hdr *rsp_hdr;
 	struct ksmbd_conn *conn = work->conn;
 	int id;
 
-	rsp_hdr = smb2_get_msg(work->response_buf);
-	rsp_hdr->Flags |= SMB2_FLAGS_ASYNC_COMMAND;
-
 	id = ksmbd_acquire_async_msg_id(&conn->async_ida);
 	if (id < 0) {
 		pr_err("Failed to alloc async message id\n");
 		return id;
 	}
-	work->syncronous = false;
+	work->asynchronous = true;
 	work->async_id = id;
-	rsp_hdr->Id.AsyncId = cpu_to_le64(id);
 
 	ksmbd_debug(SMB,
 		    "Send interim Response to inform async request id : %d\n",
@@ -661,18 +690,47 @@ int setup_async_work(struct ksmbd_work *work, void (*fn)(void **), void **arg)
 	return 0;
 }
 
+void release_async_work(struct ksmbd_work *work)
+{
+	struct ksmbd_conn *conn = work->conn;
+
+	spin_lock(&conn->request_lock);
+	list_del_init(&work->async_request_entry);
+	spin_unlock(&conn->request_lock);
+
+	work->asynchronous = 0;
+	work->cancel_fn = NULL;
+	kfree(work->cancel_argv);
+	work->cancel_argv = NULL;
+	if (work->async_id) {
+		ksmbd_release_id(&conn->async_ida, work->async_id);
+		work->async_id = 0;
+	}
+}
+
 void smb2_send_interim_resp(struct ksmbd_work *work, __le32 status)
 {
 	struct smb2_hdr *rsp_hdr;
+	struct ksmbd_work *in_work = ksmbd_alloc_work_struct();
 
-	rsp_hdr = smb2_get_msg(work->response_buf);
-	smb2_set_err_rsp(work);
+	if (allocate_interim_rsp_buf(in_work)) {
+		pr_err("smb_allocate_rsp_buf failed!\n");
+		ksmbd_free_work_struct(in_work);
+		return;
+	}
+
+	in_work->conn = work->conn;
+	memcpy(smb2_get_msg(in_work->response_buf), ksmbd_resp_buf_next(work),
+	       __SMB2_HEADER_STRUCTURE_SIZE);
+
+	rsp_hdr = smb2_get_msg(in_work->response_buf);
+	rsp_hdr->Flags |= SMB2_FLAGS_ASYNC_COMMAND;
+	rsp_hdr->Id.AsyncId = cpu_to_le64(work->async_id);
+	smb2_set_err_rsp(in_work);
 	rsp_hdr->Status = status;
 
-	work->multiRsp = 1;
-	ksmbd_conn_write(work);
-	rsp_hdr->Status = 0;
-	work->multiRsp = 0;
+	ksmbd_conn_write(in_work);
+	ksmbd_free_work_struct(in_work);
 }
 
 static __le32 smb2_get_reparse_tag_special_file(umode_t mode)
@@ -706,17 +764,17 @@ static int smb2_get_dos_mode(struct kstat *stat, int attribute)
 	int attr = 0;
 
 	if (S_ISDIR(stat->mode)) {
-		attr = FILE_ATTRIBUTE_DIRECTORY |
-			(attribute & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM));
+		attr = ATTR_DIRECTORY |
+			(attribute & (ATTR_HIDDEN | ATTR_SYSTEM));
 	} else {
-		attr = (attribute & 0x00005137) | FILE_ATTRIBUTE_ARCHIVE;
-		attr &= ~(FILE_ATTRIBUTE_DIRECTORY);
+		attr = (attribute & 0x00005137) | ATTR_ARCHIVE;
+		attr &= ~(ATTR_DIRECTORY);
 		if (S_ISREG(stat->mode) && (server_conf.share_fake_fscaps &
 				FILE_SUPPORTS_SPARSE_FILES))
-			attr |= FILE_ATTRIBUTE_SPARSE_FILE;
+			attr |= ATTR_SPARSE;
 
 		if (smb2_get_reparse_tag_special_file(stat->mode))
-			attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+			attr |= ATTR_REPARSE;
 	}
 
 	return attr;
@@ -744,19 +802,6 @@ static void build_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt,
 	pneg_ctxt->Ciphers[0] = cipher_type;
 }
 
-static void build_compression_ctxt(struct smb2_compression_capabilities_context *pneg_ctxt,
-				   __le16 comp_algo)
-{
-	pneg_ctxt->ContextType = SMB2_COMPRESSION_CAPABILITIES;
-	pneg_ctxt->DataLength =
-		cpu_to_le16(sizeof(struct smb2_compression_capabilities_context)
-			- sizeof(struct smb2_neg_context));
-	pneg_ctxt->Reserved = cpu_to_le32(0);
-	pneg_ctxt->CompressionAlgorithmCount = cpu_to_le16(1);
-	pneg_ctxt->Flags = cpu_to_le32(0);
-	pneg_ctxt->CompressionAlgorithms[0] = comp_algo;
-}
-
 static void build_sign_cap_ctxt(struct smb2_signing_capabilities *pneg_ctxt,
 				__le16 sign_algo)
 {
@@ -792,11 +837,10 @@ static void build_posix_ctxt(struct smb2_posix_neg_context *pneg_ctxt)
 	pneg_ctxt->Name[15] = 0x7C;
 }
 
-static void assemble_neg_contexts(struct ksmbd_conn *conn,
-				  struct smb2_negotiate_rsp *rsp,
-				  void *smb2_buf_len)
+static unsigned int assemble_neg_contexts(struct ksmbd_conn *conn,
+				  struct smb2_negotiate_rsp *rsp)
 {
-	char *pneg_ctxt = (char *)rsp +
+	char * const pneg_ctxt = (char *)rsp +
 			le32_to_cpu(rsp->NegotiateContextOffset);
 	int neg_ctxt_cnt = 1;
 	int ctxt_size;
@@ -805,73 +849,58 @@ static void assemble_neg_contexts(struct ksmbd_conn *conn,
 		    "assemble SMB2_PREAUTH_INTEGRITY_CAPABILITIES context\n");
 	build_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt,
 			   conn->preauth_info->Preauth_HashId);
-	rsp->NegotiateContextCount = cpu_to_le16(neg_ctxt_cnt);
-	inc_rfc1001_len(smb2_buf_len, AUTH_GSS_PADDING);
 	ctxt_size = sizeof(struct smb2_preauth_neg_context);
-	/* Round to 8 byte boundary */
-	pneg_ctxt += round_up(sizeof(struct smb2_preauth_neg_context), 8);
 
 	if (conn->cipher_type) {
+		/* Round to 8 byte boundary */
 		ctxt_size = round_up(ctxt_size, 8);
 		ksmbd_debug(SMB,
 			    "assemble SMB2_ENCRYPTION_CAPABILITIES context\n");
-		build_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt,
+		build_encrypt_ctxt((struct smb2_encryption_neg_context *)
+				   (pneg_ctxt + ctxt_size),
 				   conn->cipher_type);
-		rsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);
+		neg_ctxt_cnt++;
 		ctxt_size += sizeof(struct smb2_encryption_neg_context) + 2;
-		/* Round to 8 byte boundary */
-		pneg_ctxt +=
-			round_up(sizeof(struct smb2_encryption_neg_context) + 2,
-				 8);
 	}
 
-	if (conn->compress_algorithm) {
-		ctxt_size = round_up(ctxt_size, 8);
-		ksmbd_debug(SMB,
-			    "assemble SMB2_COMPRESSION_CAPABILITIES context\n");
-		/* Temporarily set to SMB3_COMPRESS_NONE */
-		build_compression_ctxt((struct smb2_compression_capabilities_context *)pneg_ctxt,
-				       conn->compress_algorithm);
-		rsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);
-		ctxt_size += sizeof(struct smb2_compression_capabilities_context) + 2;
-		/* Round to 8 byte boundary */
-		pneg_ctxt += round_up(sizeof(struct smb2_compression_capabilities_context) + 2,
-				      8);
-	}
+	/* compression context not yet supported */
+	WARN_ON(conn->compress_algorithm != SMB3_COMPRESS_NONE);
 
 	if (conn->posix_ext_supported) {
 		ctxt_size = round_up(ctxt_size, 8);
 		ksmbd_debug(SMB,
 			    "assemble SMB2_POSIX_EXTENSIONS_AVAILABLE context\n");
-		build_posix_ctxt((struct smb2_posix_neg_context *)pneg_ctxt);
-		rsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);
+		build_posix_ctxt((struct smb2_posix_neg_context *)
+				 (pneg_ctxt + ctxt_size));
+		neg_ctxt_cnt++;
 		ctxt_size += sizeof(struct smb2_posix_neg_context);
-		/* Round to 8 byte boundary */
-		pneg_ctxt += round_up(sizeof(struct smb2_posix_neg_context), 8);
 	}
 
 	if (conn->signing_negotiated) {
 		ctxt_size = round_up(ctxt_size, 8);
 		ksmbd_debug(SMB,
 			    "assemble SMB2_SIGNING_CAPABILITIES context\n");
-		build_sign_cap_ctxt((struct smb2_signing_capabilities *)pneg_ctxt,
+		build_sign_cap_ctxt((struct smb2_signing_capabilities *)
+				    (pneg_ctxt + ctxt_size),
 				    conn->signing_algorithm);
-		rsp->NegotiateContextCount = cpu_to_le16(++neg_ctxt_cnt);
+		neg_ctxt_cnt++;
 		ctxt_size += sizeof(struct smb2_signing_capabilities) + 2;
 	}
 
-	inc_rfc1001_len(smb2_buf_len, ctxt_size);
+	rsp->NegotiateContextCount = cpu_to_le16(neg_ctxt_cnt);
+	return ctxt_size + AUTH_GSS_PADDING;
 }
 
 static __le32 decode_preauth_ctxt(struct ksmbd_conn *conn,
 				  struct smb2_preauth_neg_context *pneg_ctxt,
-				  int len_of_ctxts)
+				  int ctxt_len)
 {
 	/*
 	 * sizeof(smb2_preauth_neg_context) assumes SMB311_SALT_SIZE Salt,
 	 * which may not be present. Only check for used HashAlgorithms[1].
 	 */
-	if (len_of_ctxts < MIN_PREAUTH_CTXT_DATA_LEN)
+	if (ctxt_len <
+	    sizeof(struct smb2_neg_context) + MIN_PREAUTH_CTXT_DATA_LEN)
 		return STATUS_INVALID_PARAMETER;
 
 	if (pneg_ctxt->HashAlgorithms != SMB2_PREAUTH_INTEGRITY_SHA512)
@@ -883,15 +912,23 @@ static __le32 decode_preauth_ctxt(struct ksmbd_conn *conn,
 
 static void decode_encrypt_ctxt(struct ksmbd_conn *conn,
 				struct smb2_encryption_neg_context *pneg_ctxt,
-				int len_of_ctxts)
+				int ctxt_len)
 {
-	int cph_cnt = le16_to_cpu(pneg_ctxt->CipherCount);
-	int i, cphs_size = cph_cnt * sizeof(__le16);
+	int cph_cnt;
+	int i, cphs_size;
+
+	if (sizeof(struct smb2_encryption_neg_context) > ctxt_len) {
+		pr_err("Invalid SMB2_ENCRYPTION_CAPABILITIES context size\n");
+		return;
+	}
 
 	conn->cipher_type = 0;
 
+	cph_cnt = le16_to_cpu(pneg_ctxt->CipherCount);
+	cphs_size = cph_cnt * sizeof(__le16);
+
 	if (sizeof(struct smb2_encryption_neg_context) + cphs_size >
-	    len_of_ctxts) {
+	    ctxt_len) {
 		pr_err("Invalid cipher count(%d)\n", cph_cnt);
 		return;
 	}
@@ -932,29 +969,36 @@ bool smb3_encryption_negotiated(struct ksmbd_conn *conn)
 }
 
 static void decode_compress_ctxt(struct ksmbd_conn *conn,
-				 struct smb2_compression_capabilities_context *pneg_ctxt)
+				 struct smb2_compression_ctx *pneg_ctxt)
 {
 	conn->compress_algorithm = SMB3_COMPRESS_NONE;
 }
 
 static void decode_sign_cap_ctxt(struct ksmbd_conn *conn,
 				 struct smb2_signing_capabilities *pneg_ctxt,
-				 int len_of_ctxts)
+				 int ctxt_len)
 {
-	int sign_algo_cnt = le16_to_cpu(pneg_ctxt->SigningAlgorithmCount);
-	int i, sign_alos_size = sign_algo_cnt * sizeof(__le16);
+	int sign_algo_cnt;
+	int i, sign_alos_size;
+
+	if (sizeof(struct smb2_signing_capabilities) > ctxt_len) {
+		pr_err("Invalid SMB2_SIGNING_CAPABILITIES context length\n");
+		return;
+	}
 
 	conn->signing_negotiated = false;
+	sign_algo_cnt = le16_to_cpu(pneg_ctxt->SigningAlgorithmCount);
+	sign_alos_size = sign_algo_cnt * sizeof(__le16);
 
 	if (sizeof(struct smb2_signing_capabilities) + sign_alos_size >
-	    len_of_ctxts) {
+	    ctxt_len) {
 		pr_err("Invalid signing algorithm count(%d)\n", sign_algo_cnt);
 		return;
 	}
 
 	for (i = 0; i < sign_algo_cnt; i++) {
-		if (pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_HMAC_SHA256_LE ||
-		    pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_AES_CMAC_LE) {
+		if (pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_HMAC_SHA256 ||
+		    pneg_ctxt->SigningAlgorithms[i] == SIGNING_ALG_AES_CMAC) {
 			ksmbd_debug(SMB, "Signing Algorithm ID = 0x%x\n",
 				    pneg_ctxt->SigningAlgorithms[i]);
 			conn->signing_negotiated = true;
@@ -967,13 +1011,13 @@ static void decode_sign_cap_ctxt(struct ksmbd_conn *conn,
 
 static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,
 				      struct smb2_negotiate_req *req,
-				      int len_of_smb)
+				      unsigned int len_of_smb)
 {
 	/* +4 is to account for the RFC1001 len field */
 	struct smb2_neg_context *pctx = (struct smb2_neg_context *)req;
 	int i = 0, len_of_ctxts;
-	int offset = le32_to_cpu(req->NegotiateContextOffset);
-	int neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);
+	unsigned int offset = le32_to_cpu(req->NegotiateContextOffset);
+	unsigned int neg_ctxt_cnt = le16_to_cpu(req->NegotiateContextCount);
 	__le32 status = STATUS_INVALID_PARAMETER;
 
 	ksmbd_debug(SMB, "decoding %d negotiate contexts\n", neg_ctxt_cnt);
@@ -985,18 +1029,16 @@ static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,
 	len_of_ctxts = len_of_smb - offset;
 
 	while (i++ < neg_ctxt_cnt) {
-		int clen;
-
-		/* check that offset is not beyond end of SMB */
-		if (len_of_ctxts == 0)
-			break;
+		int clen, ctxt_len;
 
-		if (len_of_ctxts < sizeof(struct smb2_neg_context))
+		if (len_of_ctxts < (int)sizeof(struct smb2_neg_context))
 			break;
 
 		pctx = (struct smb2_neg_context *)((char *)pctx + offset);
 		clen = le16_to_cpu(pctx->DataLength);
-		if (clen + sizeof(struct smb2_neg_context) > len_of_ctxts)
+		ctxt_len = clen + sizeof(struct smb2_neg_context);
+
+		if (ctxt_len > len_of_ctxts)
 			break;
 
 		if (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES) {
@@ -1007,7 +1049,7 @@ static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,
 
 			status = decode_preauth_ctxt(conn,
 						     (struct smb2_preauth_neg_context *)pctx,
-						     len_of_ctxts);
+						     ctxt_len);
 			if (status != STATUS_SUCCESS)
 				break;
 		} else if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES) {
@@ -1018,7 +1060,7 @@ static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,
 
 			decode_encrypt_ctxt(conn,
 					    (struct smb2_encryption_neg_context *)pctx,
-					    len_of_ctxts);
+					    ctxt_len);
 		} else if (pctx->ContextType == SMB2_COMPRESSION_CAPABILITIES) {
 			ksmbd_debug(SMB,
 				    "deassemble SMB2_COMPRESSION_CAPABILITIES context\n");
@@ -1026,7 +1068,7 @@ static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,
 				break;
 
 			decode_compress_ctxt(conn,
-					     (struct smb2_compression_capabilities_context *)pctx);
+					     (struct smb2_compression_ctx *)pctx);
 		} else if (pctx->ContextType == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID) {
 			ksmbd_debug(SMB,
 				    "deassemble SMB2_NETNAME_NEGOTIATE_CONTEXT_ID context\n");
@@ -1037,15 +1079,15 @@ static __le32 deassemble_neg_contexts(struct ksmbd_conn *conn,
 		} else if (pctx->ContextType == SMB2_SIGNING_CAPABILITIES) {
 			ksmbd_debug(SMB,
 				    "deassemble SMB2_SIGNING_CAPABILITIES context\n");
+
 			decode_sign_cap_ctxt(conn,
 					     (struct smb2_signing_capabilities *)pctx,
-					     len_of_ctxts);
+					     ctxt_len);
 		}
 
 		/* offsets must be 8 byte aligned */
-		clen = (clen + 7) & ~0x7;
-		offset = clen + sizeof(struct smb2_neg_context);
-		len_of_ctxts -= clen + sizeof(struct smb2_neg_context);
+		offset = (ctxt_len + 7) & ~0x7;
+		len_of_ctxts -= offset;
 	}
 	return status;
 }
@@ -1062,7 +1104,7 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 	struct smb2_negotiate_req *req = smb2_get_msg(work->request_buf);
 	struct smb2_negotiate_rsp *rsp = smb2_get_msg(work->response_buf);
 	int rc = 0;
-	unsigned int smb2_buf_len, smb2_neg_size;
+	unsigned int smb2_buf_len, smb2_neg_size, neg_ctxt_len = 0;
 	__le32 status;
 
 	ksmbd_debug(SMB, "Received negotiate request\n");
@@ -1073,16 +1115,16 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 		return rc;
 	}
 
-	if (req->DialectCount == 0) {
-		pr_err("malformed packet\n");
+	smb2_buf_len = get_rfc1002_len(work->request_buf);
+	smb2_neg_size = offsetof(struct smb2_negotiate_req, Dialects);
+	if (smb2_neg_size > smb2_buf_len) {
 		rsp->hdr.Status = STATUS_INVALID_PARAMETER;
 		rc = -EINVAL;
 		goto err_out;
 	}
 
-	smb2_buf_len = get_rfc1002_len(work->request_buf);
-	smb2_neg_size = offsetof(struct smb2_negotiate_req, Dialects);
-	if (smb2_neg_size > smb2_buf_len) {
+	if (req->DialectCount == 0) {
+		pr_err("malformed packet\n");
 		rsp->hdr.Status = STATUS_INVALID_PARAMETER;
 		rc = -EINVAL;
 		goto err_out;
@@ -1155,7 +1197,7 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 						 conn->preauth_info->Preauth_HashValue);
 		rsp->NegotiateContextOffset =
 				cpu_to_le32(OFFSET_OF_NEG_CONTEXT);
-		assemble_neg_contexts(conn, rsp, work->response_buf);
+		neg_ctxt_len = assemble_neg_contexts(conn, rsp);
 		break;
 	case SMB302_PROT_ID:
 		init_smb3_02_server(conn);
@@ -1166,6 +1208,13 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 	case SMB21_PROT_ID:
 		init_smb2_1_server(conn);
 		break;
+	case SMB20_PROT_ID:
+		rc = init_smb2_0_server(conn);
+		if (rc) {
+			rsp->hdr.Status = STATUS_NOT_SUPPORTED;
+			goto err_out;
+		}
+		break;
 	case SMB2X_PROT_ID:
 	case BAD_PROT_ID:
 	default:
@@ -1184,9 +1233,11 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 	rsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);
 	rsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);
 
-	memcpy(conn->ClientGUID, req->ClientGUID,
-			SMB2_CLIENT_GUID_SIZE);
-	conn->cli_sec_mode = le16_to_cpu(req->SecurityMode);
+	if (conn->dialect > SMB20_PROT_ID) {
+		memcpy(conn->ClientGUID, req->ClientGUID,
+		       SMB2_CLIENT_GUID_SIZE);
+		conn->cli_sec_mode = le16_to_cpu(req->SecurityMode);
+	}
 
 	rsp->StructureSize = cpu_to_le16(65);
 	rsp->DialectRevision = cpu_to_le16(conn->dialect);
@@ -1205,9 +1256,6 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 	rsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);
 	ksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +
 				  le16_to_cpu(rsp->SecurityBufferOffset));
-	inc_rfc1001_len(work->response_buf, sizeof(struct smb2_negotiate_rsp) -
-			sizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +
-			 AUTH_GSS_LENGTH);
 	rsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;
 	conn->use_spnego = true;
 
@@ -1225,9 +1273,15 @@ int smb2_handle_negotiate(struct ksmbd_work *work)
 	ksmbd_conn_set_need_negotiate(conn);
 
 err_out:
+	if (rc)
+		rsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;
+
+	if (!rc)
+		rc = ksmbd_iov_pin_rsp(work, rsp,
+				       sizeof(struct smb2_negotiate_rsp) +
+					AUTH_GSS_LENGTH + neg_ctxt_len);
 	if (rc < 0)
 		smb2_set_err_rsp(work);
-
 	return rc;
 }
 
@@ -1295,9 +1349,8 @@ static int decode_negotiation_token(struct ksmbd_conn *conn,
 
 static int ntlm_negotiate(struct ksmbd_work *work,
 			  struct negotiate_message *negblob,
-			  size_t negblob_len)
+			  size_t negblob_len, struct smb2_sess_setup_rsp *rsp)
 {
-	struct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);
 	struct challenge_message *chgblob;
 	unsigned char *spnego_blob = NULL;
 	u16 spnego_blob_len;
@@ -1373,7 +1426,7 @@ static struct ksmbd_user *session_user(struct ksmbd_conn *conn,
 	struct authenticate_message *authblob;
 	struct ksmbd_user *user;
 	char *name;
-	unsigned int auth_msg_len, name_off, name_len, secbuf_len;
+	unsigned int name_off, name_len, secbuf_len;
 
 	secbuf_len = le16_to_cpu(req->SecurityBufferLength);
 	if (secbuf_len < sizeof(struct authenticate_message)) {
@@ -1383,9 +1436,8 @@ static struct ksmbd_user *session_user(struct ksmbd_conn *conn,
 	authblob = user_authblob(conn, req);
 	name_off = le32_to_cpu(authblob->UserName.BufferOffset);
 	name_len = le16_to_cpu(authblob->UserName.Length);
-	auth_msg_len = le16_to_cpu(req->SecurityBufferOffset) + secbuf_len;
 
-	if (auth_msg_len < (u64)name_off + name_len)
+	if (secbuf_len < (u64)name_off + name_len)
 		return NULL;
 
 	name = smb_strndup_from_utf16((const char *)authblob + name_off,
@@ -1403,10 +1455,10 @@ static struct ksmbd_user *session_user(struct ksmbd_conn *conn,
 	return user;
 }
 
-static int ntlm_authenticate(struct ksmbd_work *work)
+static int ntlm_authenticate(struct ksmbd_work *work,
+			     struct smb2_sess_setup_req *req,
+			     struct smb2_sess_setup_rsp *rsp)
 {
-	struct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);
-	struct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);
 	struct ksmbd_conn *conn = work->conn;
 	struct ksmbd_session *sess = work->sess;
 	struct channel *chann = NULL;
@@ -1429,7 +1481,6 @@ static int ntlm_authenticate(struct ksmbd_work *work)
 		memcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);
 		rsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);
 		kfree(spnego_blob);
-		inc_rfc1001_len(work->response_buf, spnego_blob_len - 1);
 	}
 
 	user = session_user(conn, req);
@@ -1532,18 +1583,20 @@ static int ntlm_authenticate(struct ksmbd_work *work)
 		}
 	}
 
-	if (!ksmbd_conn_lookup_dialect(conn)) {
-		pr_err("fail to verify the dialect\n");
-		return -ENOENT;
+	if (conn->dialect > SMB20_PROT_ID) {
+		if (!ksmbd_conn_lookup_dialect(conn)) {
+			pr_err("fail to verify the dialect\n");
+			return -ENOENT;
+		}
 	}
 	return 0;
 }
 
 #ifdef CONFIG_SMB_SERVER_KERBEROS5
-static int krb5_authenticate(struct ksmbd_work *work)
+static int krb5_authenticate(struct ksmbd_work *work,
+			     struct smb2_sess_setup_req *req,
+			     struct smb2_sess_setup_rsp *rsp)
 {
-	struct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);
-	struct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);
 	struct ksmbd_conn *conn = work->conn;
 	struct ksmbd_session *sess = work->sess;
 	char *in_blob, *out_blob;
@@ -1575,7 +1628,6 @@ static int krb5_authenticate(struct ksmbd_work *work)
 		return -EINVAL;
 	}
 	rsp->SecurityBufferLength = cpu_to_le16(out_len);
-	inc_rfc1001_len(work->response_buf, out_len - 1);
 
 	if ((conn->sign || server_conf.enforced_signing) ||
 	    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))
@@ -1614,14 +1666,18 @@ static int krb5_authenticate(struct ksmbd_work *work)
 		}
 	}
 
-	if (!ksmbd_conn_lookup_dialect(conn)) {
-		pr_err("fail to verify the dialect\n");
-		return -ENOENT;
+	if (conn->dialect > SMB20_PROT_ID) {
+		if (!ksmbd_conn_lookup_dialect(conn)) {
+			pr_err("fail to verify the dialect\n");
+			return -ENOENT;
+		}
 	}
 	return 0;
 }
 #else
-static int krb5_authenticate(struct ksmbd_work *work)
+static int krb5_authenticate(struct ksmbd_work *work,
+			     struct smb2_sess_setup_req *req,
+			     struct smb2_sess_setup_rsp *rsp)
 {
 	return -EOPNOTSUPP;
 }
@@ -1630,8 +1686,8 @@ static int krb5_authenticate(struct ksmbd_work *work)
 int smb2_sess_setup(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
-	struct smb2_sess_setup_req *req = smb2_get_msg(work->request_buf);
-	struct smb2_sess_setup_rsp *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_sess_setup_req *req;
+	struct smb2_sess_setup_rsp *rsp;
 	struct ksmbd_session *sess;
 	struct negotiate_message *negblob;
 	unsigned int negblob_len, negblob_off;
@@ -1639,11 +1695,12 @@ int smb2_sess_setup(struct ksmbd_work *work)
 
 	ksmbd_debug(SMB, "Received request for session setup\n");
 
+	WORK_BUFFERS(work, req, rsp);
+
 	rsp->StructureSize = cpu_to_le16(9);
 	rsp->SessionFlags = 0;
 	rsp->SecurityBufferOffset = cpu_to_le16(72);
 	rsp->SecurityBufferLength = 0;
-	inc_rfc1001_len(work->response_buf, 9);
 
 	ksmbd_conn_lock(conn);
 	if (!req->hdr.SessionId) {
@@ -1760,7 +1817,7 @@ int smb2_sess_setup(struct ksmbd_work *work)
 
 		if (conn->preferred_auth_mech &
 				(KSMBD_AUTH_KRB5 | KSMBD_AUTH_MSKRB5)) {
-			rc = krb5_authenticate(work);
+			rc = krb5_authenticate(work, req, rsp);
 			if (rc) {
 				rc = -EINVAL;
 				goto out_err;
@@ -1774,20 +1831,13 @@ int smb2_sess_setup(struct ksmbd_work *work)
 			sess->Preauth_HashValue = NULL;
 		} else if (conn->preferred_auth_mech == KSMBD_AUTH_NTLMSSP) {
 			if (negblob->MessageType == NtLmNegotiate) {
-				rc = ntlm_negotiate(work, negblob, negblob_len);
+				rc = ntlm_negotiate(work, negblob, negblob_len, rsp);
 				if (rc)
 					goto out_err;
 				rsp->hdr.Status =
 					STATUS_MORE_PROCESSING_REQUIRED;
-				/*
-				 * Note: here total size -1 is done as an
-				 * adjustment for 0 size blob
-				 */
-				inc_rfc1001_len(work->response_buf,
-						le16_to_cpu(rsp->SecurityBufferLength) - 1);
-
 			} else if (negblob->MessageType == NtLmAuthenticate) {
-				rc = ntlm_authenticate(work);
+				rc = ntlm_authenticate(work, req, rsp);
 				if (rc)
 					goto out_err;
 
@@ -1870,6 +1920,18 @@ int smb2_sess_setup(struct ksmbd_work *work)
 				ksmbd_conn_set_need_negotiate(conn);
 			}
 		}
+		smb2_set_err_rsp(work);
+	} else {
+		unsigned int iov_len;
+
+		if (rsp->SecurityBufferLength)
+			iov_len = offsetof(struct smb2_sess_setup_rsp, Buffer) +
+				le16_to_cpu(rsp->SecurityBufferLength);
+		else
+			iov_len = sizeof(struct smb2_sess_setup_rsp);
+		rc = ksmbd_iov_pin_rsp(work, rsp, iov_len);
+		if (rc)
+			rsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;
 	}
 
 	ksmbd_conn_unlock(conn);
@@ -1885,14 +1947,16 @@ int smb2_sess_setup(struct ksmbd_work *work)
 int smb2_tree_connect(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
-	struct smb2_tree_connect_req *req = smb2_get_msg(work->request_buf);
-	struct smb2_tree_connect_rsp *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_tree_connect_req *req;
+	struct smb2_tree_connect_rsp *rsp;
 	struct ksmbd_session *sess = work->sess;
 	char *treename = NULL, *name = NULL;
 	struct ksmbd_tree_conn_status status;
 	struct ksmbd_share_config *share;
 	int rc = -EINVAL;
 
+	WORK_BUFFERS(work, req, rsp);
+
 	treename = smb_strndup_from_utf16(req->Buffer,
 					  le16_to_cpu(req->PathLength), true,
 					  conn->local_nls);
@@ -1945,14 +2009,20 @@ int smb2_tree_connect(struct ksmbd_work *work)
 	if (conn->posix_ext_supported)
 		status.tree_conn->posix_extensions = true;
 
+	write_lock(&sess->tree_conns_lock);
+	status.tree_conn->t_state = TREE_CONNECTED;
+	write_unlock(&sess->tree_conns_lock);
 	rsp->StructureSize = cpu_to_le16(16);
-	inc_rfc1001_len(work->response_buf, 16);
 out_err1:
 	rsp->Capabilities = 0;
 	rsp->Reserved = 0;
 	/* default manual caching */
 	rsp->ShareFlags = SMB2_SHAREFLAG_MANUAL_CACHING;
 
+	rc = ksmbd_iov_pin_rsp(work, rsp, sizeof(struct smb2_tree_connect_rsp));
+	if (rc)
+		status.ret = KSMBD_TREE_CONN_STATUS_NOMEM;
+
 	if (!IS_ERR(treename))
 		kfree(treename);
 	if (!IS_ERR(name))
@@ -2061,30 +2131,60 @@ static int smb2_create_open_flags(bool file_present, __le32 access,
  */
 int smb2_tree_disconnect(struct ksmbd_work *work)
 {
-	struct smb2_tree_disconnect_rsp *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_tree_disconnect_rsp *rsp;
+	struct smb2_tree_disconnect_req *req;
 	struct ksmbd_session *sess = work->sess;
 	struct ksmbd_tree_connect *tcon = work->tcon;
+	int err;
 
-	rsp->StructureSize = cpu_to_le16(4);
-	inc_rfc1001_len(work->response_buf, 4);
+	WORK_BUFFERS(work, req, rsp);
 
 	ksmbd_debug(SMB, "request\n");
 
-	if (!tcon || test_and_set_bit(TREE_CONN_EXPIRE, &tcon->status)) {
-		struct smb2_tree_disconnect_req *req =
-			smb2_get_msg(work->request_buf);
-
+	if (!tcon) {
 		ksmbd_debug(SMB, "Invalid tid %d\n", req->hdr.Id.SyncId.TreeId);
 
 		rsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;
-		smb2_set_err_rsp(work);
-		return 0;
+		err = -ENOENT;
+		goto err_out;
 	}
 
 	ksmbd_close_tree_conn_fds(work);
-	ksmbd_tree_conn_disconnect(sess, tcon);
+
+	write_lock(&sess->tree_conns_lock);
+	if (tcon->t_state == TREE_DISCONNECTED) {
+		write_unlock(&sess->tree_conns_lock);
+		rsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;
+		err = -ENOENT;
+		goto err_out;
+	}
+
+	WARN_ON_ONCE(atomic_dec_and_test(&tcon->refcount));
+	tcon->t_state = TREE_DISCONNECTED;
+	write_unlock(&sess->tree_conns_lock);
+
+	err = ksmbd_tree_conn_disconnect(sess, tcon);
+	if (err) {
+		rsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;
+		goto err_out;
+	}
+
 	work->tcon = NULL;
+
+	rsp->StructureSize = cpu_to_le16(4);
+	err = ksmbd_iov_pin_rsp(work, rsp,
+				sizeof(struct smb2_tree_disconnect_rsp));
+	if (err) {
+		rsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;
+		goto err_out;
+	}
+
 	return 0;
+
+err_out:
+	smb2_set_err_rsp(work);
+	return err;
+
 }
 
 /**
@@ -2096,17 +2196,27 @@ int smb2_tree_disconnect(struct ksmbd_work *work)
 int smb2_session_logoff(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
-	struct smb2_logoff_rsp *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_logoff_req *req;
+	struct smb2_logoff_rsp *rsp;
 	struct ksmbd_session *sess;
-	struct smb2_logoff_req *req = smb2_get_msg(work->request_buf);
-	u64 sess_id = le64_to_cpu(req->hdr.SessionId);
+	u64 sess_id;
+	int err;
 
-	rsp->StructureSize = cpu_to_le16(4);
-	inc_rfc1001_len(work->response_buf, 4);
+	WORK_BUFFERS(work, req, rsp);
 
 	ksmbd_debug(SMB, "request\n");
 
+	ksmbd_conn_lock(conn);
+	if (!ksmbd_conn_good(conn)) {
+		ksmbd_conn_unlock(conn);
+		rsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;
+		smb2_set_err_rsp(work);
+		return -ENOENT;
+	}
+	sess_id = le64_to_cpu(req->hdr.SessionId);
 	ksmbd_all_conn_set_status(sess_id, KSMBD_SESS_NEED_RECONNECT);
+	ksmbd_conn_unlock(conn);
+
 	ksmbd_close_session_fds(work);
 	ksmbd_conn_wait_idle(conn, sess_id);
 
@@ -2119,7 +2229,7 @@ int smb2_session_logoff(struct ksmbd_work *work)
 		ksmbd_debug(SMB, "Invalid tid %d\n", req->hdr.Id.SyncId.TreeId);
 		rsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;
 		smb2_set_err_rsp(work);
-		return 0;
+		return -ENOENT;
 	}
 
 	ksmbd_destroy_file_table(&sess->file_table);
@@ -2128,6 +2238,14 @@ int smb2_session_logoff(struct ksmbd_work *work)
 	ksmbd_free_user(sess->user);
 	sess->user = NULL;
 	ksmbd_all_conn_set_status(sess_id, KSMBD_SESS_NEED_NEGOTIATE);
+
+	rsp->StructureSize = cpu_to_le16(4);
+	err = ksmbd_iov_pin_rsp(work, rsp, sizeof(struct smb2_logoff_rsp));
+	if (err) {
+		rsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;
+		smb2_set_err_rsp(work);
+		return err;
+	}
 	return 0;
 }
 
@@ -2139,12 +2257,14 @@ int smb2_session_logoff(struct ksmbd_work *work)
  */
 static noinline int create_smb2_pipe(struct ksmbd_work *work)
 {
-	struct smb2_create_rsp *rsp = smb2_get_msg(work->response_buf);
-	struct smb2_create_req *req = smb2_get_msg(work->request_buf);
+	struct smb2_create_rsp *rsp;
+	struct smb2_create_req *req;
 	int id;
 	int err;
 	char *name;
 
+	WORK_BUFFERS(work, req, rsp);
+
 	name = smb_strndup_from_utf16(req->Buffer, le16_to_cpu(req->NameLength),
 				      1, work->conn->local_nls);
 	if (IS_ERR(name)) {
@@ -2163,7 +2283,7 @@ static noinline int create_smb2_pipe(struct ksmbd_work *work)
 	rsp->hdr.Status = STATUS_SUCCESS;
 	rsp->StructureSize = cpu_to_le16(89);
 	rsp->OplockLevel = SMB2_OPLOCK_LEVEL_NONE;
-	rsp->Flags = 0;
+	rsp->Reserved = 0;
 	rsp->CreateAction = cpu_to_le32(FILE_OPENED);
 
 	rsp->CreationTime = cpu_to_le64(0);
@@ -2171,14 +2291,17 @@ static noinline int create_smb2_pipe(struct ksmbd_work *work)
 	rsp->ChangeTime = cpu_to_le64(0);
 	rsp->AllocationSize = cpu_to_le64(0);
 	rsp->EndofFile = cpu_to_le64(0);
-	rsp->FileAttributes = FILE_ATTRIBUTE_NORMAL_LE;
+	rsp->FileAttributes = ATTR_NORMAL_LE;
 	rsp->Reserved2 = 0;
 	rsp->VolatileFileId = id;
 	rsp->PersistentFileId = 0;
 	rsp->CreateContextsOffset = 0;
 	rsp->CreateContextsLength = 0;
 
-	inc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/
+	err = ksmbd_iov_pin_rsp(work, rsp, offsetof(struct smb2_create_rsp, Buffer));
+	if (err)
+		goto out;
+
 	kfree(name);
 	return 0;
 
@@ -2212,7 +2335,11 @@ static noinline int create_smb2_pipe(struct ksmbd_work *work)
 static int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,
 		       const struct path *path)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	char *attr_name = NULL, *value;
 	int rc = 0;
 	unsigned int next = 0;
@@ -2248,7 +2375,11 @@ static int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,
 		value = (char *)&eabuf->name + eabuf->EaNameLength + 1;
 
 		if (!eabuf->EaValueLength) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			rc = ksmbd_vfs_casexattr_len(idmap,
+#else
 			rc = ksmbd_vfs_casexattr_len(user_ns,
+#endif
 						     path->dentry,
 						     attr_name,
 						     XATTR_USER_PREFIX_LEN +
@@ -2256,8 +2387,12 @@ static int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,
 
 			/* delete the EA only when it exits */
 			if (rc > 0) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+				rc = ksmbd_vfs_remove_xattr(idmap,
+#else
 				rc = ksmbd_vfs_remove_xattr(user_ns,
-							    path->dentry,
+#endif
+							    path,
 							    attr_name);
 
 				if (rc < 0) {
@@ -2271,9 +2406,14 @@ static int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,
 			/* if the EA doesn't exist, just do nothing. */
 			rc = 0;
 		} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			rc = ksmbd_vfs_setxattr(idmap,
+#else
 			rc = ksmbd_vfs_setxattr(user_ns,
-						path->dentry, attr_name, value,
-						le16_to_cpu(eabuf->EaValueLength), 0);
+#endif
+						path, attr_name, value,
+						le16_to_cpu(eabuf->EaValueLength),
+						0, true);
 			if (rc < 0) {
 				ksmbd_debug(SMB,
 					    "ksmbd_vfs_setxattr is failed(%d)\n",
@@ -2288,9 +2428,16 @@ static int smb2_set_ea(struct smb2_ea_info *eabuf, unsigned int buf_len,
 			break;
 		buf_len -= next;
 		eabuf = (struct smb2_ea_info *)((char *)eabuf + next);
-		if (next < (u32)eabuf->EaNameLength + le16_to_cpu(eabuf->EaValueLength))
+		if (buf_len < sizeof(struct smb2_ea_info)) {
+			rc = -EINVAL;
 			break;
+		}
 
+		if (buf_len < sizeof(struct smb2_ea_info) + eabuf->EaNameLength +
+				le16_to_cpu(eabuf->EaValueLength)) {
+			rc = -EINVAL;
+			break;
+		}
 	} while (next != 0);
 
 	kfree(attr_name);
@@ -2301,7 +2448,11 @@ static noinline int smb2_set_stream_name_xattr(const struct path *path,
 					       struct ksmbd_file *fp,
 					       char *stream_name, int s_type)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	size_t xattr_stream_size;
 	char *xattr_stream_name;
 	int rc;
@@ -2317,7 +2468,11 @@ static noinline int smb2_set_stream_name_xattr(const struct path *path,
 	fp->stream.size = xattr_stream_size;
 
 	/* Check if there is stream prefix in xattr space */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_casexattr_len(idmap,
+#else
 	rc = ksmbd_vfs_casexattr_len(user_ns,
+#endif
 				     path->dentry,
 				     xattr_stream_name,
 				     xattr_stream_size);
@@ -2329,8 +2484,12 @@ static noinline int smb2_set_stream_name_xattr(const struct path *path,
 		return -EBADF;
 	}
 
-	rc = ksmbd_vfs_setxattr(user_ns, path->dentry,
-				xattr_stream_name, NULL, 0, 0);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_setxattr(idmap, path,
+#else
+	rc = ksmbd_vfs_setxattr(user_ns, path,
+#endif
+				xattr_stream_name, NULL, 0, 0, false);
 	if (rc < 0)
 		pr_err("Failed to store XATTR stream name :%d\n", rc);
 	return 0;
@@ -2338,7 +2497,11 @@ static noinline int smb2_set_stream_name_xattr(const struct path *path,
 
 static int smb2_remove_smb_xattrs(const struct path *path)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	char *name, *xattr_list = NULL;
 	ssize_t xattr_list_len;
 	int err = 0;
@@ -2358,8 +2521,11 @@ static int smb2_remove_smb_xattrs(const struct path *path)
 		if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&
 		    !strncmp(&name[XATTR_USER_PREFIX_LEN], STREAM_PREFIX,
 			     STREAM_PREFIX_LEN)) {
-			err = ksmbd_vfs_remove_xattr(user_ns, path->dentry,
-						     name);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			err = ksmbd_vfs_remove_xattr(idmap, path, name);
+#else
+			err = ksmbd_vfs_remove_xattr(user_ns, path, name);
+#endif
 			if (err)
 				ksmbd_debug(SMB, "remove xattr failed : %s\n",
 					    name);
@@ -2405,8 +2571,7 @@ static void smb2_new_xattrs(struct ksmbd_tree_connect *tcon, const struct path *
 	da.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |
 		XATTR_DOSINFO_ITIME;
 
-	rc = ksmbd_vfs_set_dos_attrib_xattr(mnt_user_ns(path->mnt),
-					    path->dentry, &da);
+	rc = compat_ksmbd_vfs_set_dos_attrib_xattr(path, &da, true);
 	if (rc)
 		ksmbd_debug(SMB, "failed to store file attribute into xattr\n");
 }
@@ -2417,15 +2582,14 @@ static void smb2_update_xattrs(struct ksmbd_tree_connect *tcon,
 	struct xattr_dos_attrib da;
 	int rc;
 
-	fp->f_ci->m_fattr &= ~(FILE_ATTRIBUTE_HIDDEN_LE | FILE_ATTRIBUTE_SYSTEM_LE);
+	fp->f_ci->m_fattr &= ~(ATTR_HIDDEN_LE | ATTR_SYSTEM_LE);
 
 	/* get FileAttributes from XATTR_NAME_DOS_ATTRIBUTE */
 	if (!test_share_config_flag(tcon->share_conf,
 				    KSMBD_SHARE_FLAG_STORE_DOS_ATTRS))
 		return;
 
-	rc = ksmbd_vfs_get_dos_attrib_xattr(mnt_user_ns(path->mnt),
-					    path->dentry, &da);
+	rc = compat_ksmbd_vfs_get_dos_attrib_xattr(path, path->dentry, &da);
 	if (rc > 0) {
 		fp->f_ci->m_fattr = cpu_to_le32(da.attr);
 		fp->create_time = da.create_time;
@@ -2433,8 +2597,14 @@ static void smb2_update_xattrs(struct ksmbd_tree_connect *tcon,
 	}
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static int smb2_creat(struct ksmbd_work *work, struct path *parent_path,
+		      struct path *path, char *name, int open_flags,
+		      umode_t posix_mode, bool is_dir)
+#else
 static int smb2_creat(struct ksmbd_work *work, struct path *path, char *name,
 		      int open_flags, umode_t posix_mode, bool is_dir)
+#endif
 {
 	struct ksmbd_tree_connect *tcon = work->tcon;
 	struct ksmbd_share_config *share = tcon->share_conf;
@@ -2461,7 +2631,11 @@ static int smb2_creat(struct ksmbd_work *work, struct path *path, char *name,
 			return rc;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	rc = ksmbd_vfs_kern_path_locked(work, name, 0, parent_path, path, 0);
+#else
 	rc = ksmbd_vfs_kern_path(work, name, 0, path, 0);
+#endif
 	if (rc) {
 		pr_err("cannot get linux path (%s), err = %d\n",
 		       name, rc);
@@ -2481,7 +2655,7 @@ static int smb2_create_sd_buffer(struct ksmbd_work *work,
 		return -ENOENT;
 
 	/* Parse SD BUFFER create contexts */
-	context = smb2_find_context_vals(req, SMB2_CREATE_SD_BUFFER);
+	context = smb2_find_context_vals(req, SMB2_CREATE_SD_BUFFER, 4);
 	if (!context)
 		return -ENOENT;
 	else if (IS_ERR(context))
@@ -2495,26 +2669,53 @@ static int smb2_create_sd_buffer(struct ksmbd_work *work,
 	    sizeof(struct create_sd_buf_req))
 		return -EINVAL;
 	return set_info_sec(work->conn, work->tcon, path, &sd_buf->ntsd,
-			    le32_to_cpu(sd_buf->ccontext.DataLength), true);
+			    le32_to_cpu(sd_buf->ccontext.DataLength), true, false);
 }
 
 static void ksmbd_acls_fattr(struct smb_fattr *fattr,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			     struct mnt_idmap *idmap,
+#else
 			     struct user_namespace *mnt_userns,
+#endif
 			     struct inode *inode)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);
+	vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);
+#else
 	vfsuid_t vfsuid = i_uid_into_vfsuid(mnt_userns, inode);
 	vfsgid_t vfsgid = i_gid_into_vfsgid(mnt_userns, inode);
+#endif
 
 	fattr->cf_uid = vfsuid_into_kuid(vfsuid);
 	fattr->cf_gid = vfsgid_into_kgid(vfsgid);
+#else
+	fattr->cf_uid = i_uid_into_mnt(mnt_userns, inode);
+	fattr->cf_gid = i_gid_into_mnt(mnt_userns, inode);
+#endif
+#else
+	fattr->cf_uid = inode->i_uid;
+	fattr->cf_gid = inode->i_gid;
+#endif
 	fattr->cf_mode = inode->i_mode;
 	fattr->cf_acls = NULL;
 	fattr->cf_dacls = NULL;
 
 	if (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
 		fattr->cf_acls = get_inode_acl(inode, ACL_TYPE_ACCESS);
+#else
+		fattr->cf_acls = get_acl(inode, ACL_TYPE_ACCESS);
+#endif
 		if (S_ISDIR(inode->i_mode))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
 			fattr->cf_dacls = get_inode_acl(inode, ACL_TYPE_DEFAULT);
+#else
+			fattr->cf_dacls = get_acl(inode, ACL_TYPE_DEFAULT);
+#endif
 	}
 }
 
@@ -2532,10 +2733,17 @@ int smb2_open(struct ksmbd_work *work)
 	struct smb2_create_req *req;
 	struct smb2_create_rsp *rsp;
 	struct path path;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	struct path parent_path;
+#endif
 	struct ksmbd_share_config *share = tcon->share_conf;
 	struct ksmbd_file *fp = NULL;
 	struct file *filp = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = NULL;
+#else
 	struct user_namespace *user_ns = NULL;
+#endif
 	struct kstat stat;
 	struct create_context *context;
 	struct lease_ctx_info *lc = NULL;
@@ -2555,6 +2763,7 @@ int smb2_open(struct ksmbd_work *work)
 	u64 time;
 	umode_t posix_mode = 0;
 	__le32 daccess, maximal_access = 0;
+	int iov_len = 0;
 
 	WORK_BUFFERS(work, req, rsp);
 
@@ -2576,7 +2785,7 @@ int smb2_open(struct ksmbd_work *work)
 		    *(char *)req->Buffer == '\\') {
 			pr_err("not allow directory name included leading slash\n");
 			rc = -EINVAL;
-			goto err_out1;
+			goto err_out2;
 		}
 
 		name = smb2_get_name(req->Buffer,
@@ -2587,7 +2796,7 @@ int smb2_open(struct ksmbd_work *work)
 			if (rc != -ENOMEM)
 				rc = -ENOENT;
 			name = NULL;
-			goto err_out1;
+			goto err_out2;
 		}
 
 		ksmbd_debug(SMB, "converted name = %s\n", name);
@@ -2595,48 +2804,44 @@ int smb2_open(struct ksmbd_work *work)
 			if (!test_share_config_flag(work->tcon->share_conf,
 						    KSMBD_SHARE_FLAG_STREAMS)) {
 				rc = -EBADF;
-				goto err_out1;
+				goto err_out2;
 			}
 			rc = parse_stream_name(name, &stream_name, &s_type);
 			if (rc < 0)
-				goto err_out1;
+				goto err_out2;
 		}
 
 		rc = ksmbd_validate_filename(name);
 		if (rc < 0)
-			goto err_out1;
+			goto err_out2;
 
 		if (ksmbd_share_veto_filename(share, name)) {
 			rc = -ENOENT;
 			ksmbd_debug(SMB, "Reject open(), vetoed file: %s\n",
 				    name);
-			goto err_out1;
+			goto err_out2;
 		}
 	} else {
 		name = kstrdup("", GFP_KERNEL);
 		if (!name) {
 			rc = -ENOMEM;
-			goto err_out1;
+			goto err_out2;
 		}
 	}
 
-	req_op_level = req->RequestedOplockLevel;
-	if (req_op_level == SMB2_OPLOCK_LEVEL_LEASE)
-		lc = parse_lease_state(req);
-
-	if (le32_to_cpu(req->ImpersonationLevel) > le32_to_cpu(IL_DELEGATE)) {
+	if (le32_to_cpu(req->ImpersonationLevel) > le32_to_cpu(IL_DELEGATE_LE)) {
 		pr_err("Invalid impersonationlevel : 0x%x\n",
 		       le32_to_cpu(req->ImpersonationLevel));
 		rc = -EIO;
 		rsp->hdr.Status = STATUS_BAD_IMPERSONATION_LEVEL;
-		goto err_out1;
+		goto err_out2;
 	}
 
-	if (req->CreateOptions && !(req->CreateOptions & CREATE_OPTIONS_MASK_LE)) {
+	if (req->CreateOptions && !(req->CreateOptions & CREATE_OPTIONS_MASK)) {
 		pr_err("Invalid create options : 0x%x\n",
 		       le32_to_cpu(req->CreateOptions));
 		rc = -EINVAL;
-		goto err_out1;
+		goto err_out2;
 	} else {
 		if (req->CreateOptions & FILE_SEQUENTIAL_ONLY_LE &&
 		    req->CreateOptions & FILE_RANDOM_ACCESS_LE)
@@ -2646,13 +2851,13 @@ int smb2_open(struct ksmbd_work *work)
 		    (FILE_OPEN_BY_FILE_ID_LE | CREATE_TREE_CONNECTION |
 		     FILE_RESERVE_OPFILTER_LE)) {
 			rc = -EOPNOTSUPP;
-			goto err_out1;
+			goto err_out2;
 		}
 
 		if (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {
 			if (req->CreateOptions & FILE_NON_DIRECTORY_FILE_LE) {
 				rc = -EINVAL;
-				goto err_out1;
+				goto err_out2;
 			} else if (req->CreateOptions & FILE_NO_COMPRESSION_LE) {
 				req->CreateOptions = ~(FILE_NO_COMPRESSION_LE);
 			}
@@ -2664,49 +2869,49 @@ int smb2_open(struct ksmbd_work *work)
 		pr_err("Invalid create disposition : 0x%x\n",
 		       le32_to_cpu(req->CreateDisposition));
 		rc = -EINVAL;
-		goto err_out1;
+		goto err_out2;
 	}
 
 	if (!(req->DesiredAccess & DESIRED_ACCESS_MASK)) {
 		pr_err("Invalid desired access : 0x%x\n",
 		       le32_to_cpu(req->DesiredAccess));
 		rc = -EACCES;
-		goto err_out1;
+		goto err_out2;
 	}
 
-	if (req->FileAttributes && !(req->FileAttributes & FILE_ATTRIBUTE_MASK_LE)) {
+	if (req->FileAttributes && !(req->FileAttributes & ATTR_MASK_LE)) {
 		pr_err("Invalid file attribute : 0x%x\n",
 		       le32_to_cpu(req->FileAttributes));
 		rc = -EINVAL;
-		goto err_out1;
+		goto err_out2;
 	}
 
 	if (req->CreateContextsOffset) {
 		/* Parse non-durable handle create contexts */
-		context = smb2_find_context_vals(req, SMB2_CREATE_EA_BUFFER);
+		context = smb2_find_context_vals(req, SMB2_CREATE_EA_BUFFER, 4);
 		if (IS_ERR(context)) {
 			rc = PTR_ERR(context);
-			goto err_out1;
+			goto err_out2;
 		} else if (context) {
 			ea_buf = (struct create_ea_buf_req *)context;
 			if (le16_to_cpu(context->DataOffset) +
 			    le32_to_cpu(context->DataLength) <
 			    sizeof(struct create_ea_buf_req)) {
 				rc = -EINVAL;
-				goto err_out1;
+				goto err_out2;
 			}
 			if (req->CreateOptions & FILE_NO_EA_KNOWLEDGE_LE) {
 				rsp->hdr.Status = STATUS_ACCESS_DENIED;
 				rc = -EACCES;
-				goto err_out1;
+				goto err_out2;
 			}
 		}
 
 		context = smb2_find_context_vals(req,
-						 SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST);
+						 SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST, 4);
 		if (IS_ERR(context)) {
 			rc = PTR_ERR(context);
-			goto err_out1;
+			goto err_out2;
 		} else if (context) {
 			ksmbd_debug(SMB,
 				    "get query maximal access context\n");
@@ -2714,22 +2919,22 @@ int smb2_open(struct ksmbd_work *work)
 		}
 
 		context = smb2_find_context_vals(req,
-						 SMB2_CREATE_TIMEWARP_REQUEST);
+						 SMB2_CREATE_TIMEWARP_REQUEST, 4);
 		if (IS_ERR(context)) {
 			rc = PTR_ERR(context);
-			goto err_out1;
+			goto err_out2;
 		} else if (context) {
 			ksmbd_debug(SMB, "get timewarp context\n");
 			rc = -EBADF;
-			goto err_out1;
+			goto err_out2;
 		}
 
 		if (tcon->posix_extensions) {
 			context = smb2_find_context_vals(req,
-							 SMB2_CREATE_TAG_POSIX);
+							 SMB2_CREATE_TAG_POSIX, 16);
 			if (IS_ERR(context)) {
 				rc = PTR_ERR(context);
-				goto err_out1;
+				goto err_out2;
 			} else if (context) {
 				struct create_posix *posix =
 					(struct create_posix *)context;
@@ -2737,7 +2942,7 @@ int smb2_open(struct ksmbd_work *work)
 				    le32_to_cpu(context->DataLength) <
 				    sizeof(struct create_posix) - 4) {
 					rc = -EINVAL;
-					goto err_out1;
+					goto err_out2;
 				}
 				ksmbd_debug(SMB, "get posix context\n");
 
@@ -2749,11 +2954,20 @@ int smb2_open(struct ksmbd_work *work)
 
 	if (ksmbd_override_fsids(work)) {
 		rc = -ENOMEM;
-		goto err_out1;
+		goto err_out2;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	rc = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					&parent_path, &path, 1);
+#else
 	rc = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, 1);
+#endif
 	if (!rc) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+		file_present = true;
+#endif
+
 		if (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE) {
 			/*
 			 * If file exists with under flags, return access
@@ -2762,7 +2976,9 @@ int smb2_open(struct ksmbd_work *work)
 			if (req->CreateDisposition == FILE_OVERWRITE_IF_LE ||
 			    req->CreateDisposition == FILE_OPEN_IF_LE) {
 				rc = -EACCES;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
 				path_put(&path);
+#endif
 				goto err_out;
 			}
 
@@ -2770,26 +2986,37 @@ int smb2_open(struct ksmbd_work *work)
 				ksmbd_debug(SMB,
 					    "User does not have write permission\n");
 				rc = -EACCES;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
 				path_put(&path);
+#endif
 				goto err_out;
 			}
 		} else if (d_is_symlink(path.dentry)) {
 			rc = -EACCES;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
 			path_put(&path);
+#endif
 			goto err_out;
 		}
-	}
 
-	if (rc) {
+		file_present = true;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		idmap = mnt_idmap(path.mnt);
+#else
+		user_ns = mnt_user_ns(path.mnt);
+#endif
+#else
+		user_ns = NULL;
+#endif
+	} else {
 		if (rc != -ENOENT)
 			goto err_out;
 		ksmbd_debug(SMB, "can not get linux path for %s, rc = %d\n",
 			    name, rc);
 		rc = 0;
-	} else {
-		file_present = true;
-		user_ns = mnt_user_ns(path.mnt);
 	}
+
 	if (stream_name) {
 		if (req->CreateOptions & FILE_DIRECTORY_FILE_LE) {
 			if (s_type == DATA_STREAM) {
@@ -2805,7 +3032,7 @@ int smb2_open(struct ksmbd_work *work)
 		}
 
 		if (req->CreateOptions & FILE_DIRECTORY_FILE_LE &&
-		    req->FileAttributes & FILE_ATTRIBUTE_NORMAL_LE) {
+		    req->FileAttributes & ATTR_NORMAL_LE) {
 			rsp->hdr.Status = STATUS_NOT_A_DIRECTORY;
 			rc = -EIO;
 		}
@@ -2851,11 +3078,17 @@ int smb2_open(struct ksmbd_work *work)
 		if (!file_present) {
 			daccess = cpu_to_le32(GENERIC_ALL_FLAGS);
 		} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			ksmbd_vfs_query_maximal_access(idmap,
+						       path.dentry,
+						       &daccess);
+#else
 			rc = ksmbd_vfs_query_maximal_access(user_ns,
 							    path.dentry,
 							    &daccess);
 			if (rc)
 				goto err_out;
+#endif
 			already_permitted = true;
 		}
 		maximal_access = daccess;
@@ -2876,7 +3109,12 @@ int smb2_open(struct ksmbd_work *work)
 
 	/*create file if not present */
 	if (!file_present) {
-		rc = smb2_creat(work, &path, name, open_flags, posix_mode,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+		rc = smb2_creat(work, &parent_path, &path, name, open_flags,
+#else
+		rc = smb2_creat(work, &path, name, open_flags,
+#endif
+				posix_mode,
 				req->CreateOptions & FILE_DIRECTORY_FILE_LE);
 		if (rc) {
 			if (rc == -ENOENT) {
@@ -2887,7 +3125,11 @@ int smb2_open(struct ksmbd_work *work)
 		}
 
 		created = true;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		idmap = mnt_idmap(path.mnt);
+#else
 		user_ns = mnt_user_ns(path.mnt);
+#endif
 		if (ea_buf) {
 			if (le32_to_cpu(ea_buf->ccontext.DataLength) <
 			    sizeof(struct smb2_ea_info)) {
@@ -2909,23 +3151,41 @@ int smb2_open(struct ksmbd_work *work)
 		 * is already granted.
 		 */
 		if (daccess & ~(FILE_READ_ATTRIBUTES_LE | FILE_READ_CONTROL_LE)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			rc = inode_permission(idmap,
+#else
 			rc = inode_permission(user_ns,
+#endif
 					      d_inode(path.dentry),
 					      may_flags);
+#else
+			rc = inode_permission(d_inode(path.dentry), may_flags);
+#endif
 			if (rc)
 				goto err_out;
 
 			if ((daccess & FILE_DELETE_LE) ||
 			    (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+				rc = inode_permission(idmap,
+						      d_inode(path.dentry->d_parent),
+						      MAY_EXEC | MAY_WRITE);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+				rc = ksmbd_vfs_may_delete(idmap,
+#else
 				rc = ksmbd_vfs_may_delete(user_ns,
+#endif
 							  path.dentry);
+#endif
 				if (rc)
 					goto err_out;
 			}
 		}
 	}
 
-	rc = ksmbd_query_inode_status(d_inode(path.dentry->d_parent));
+	rc = ksmbd_query_inode_status(path.dentry->d_parent);
 	if (rc == KSMBD_INODE_STATUS_PENDING_DELETE) {
 		rc = -EBUSY;
 		goto err_out;
@@ -2980,9 +3240,15 @@ int smb2_open(struct ksmbd_work *work)
 		int posix_acl_rc;
 		struct inode *inode = d_inode(path.dentry);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		posix_acl_rc = ksmbd_vfs_inherit_posix_acl(idmap,
+							   &path,
+							   d_inode(path.dentry->d_parent));
+#else
 		posix_acl_rc = ksmbd_vfs_inherit_posix_acl(user_ns,
-							   path.dentry,
+							   &path,
 							   d_inode(path.dentry->d_parent));
+#endif
 		if (posix_acl_rc)
 			ksmbd_debug(SMB, "inherit posix acl failed : %d\n", posix_acl_rc);
 
@@ -2996,8 +3262,13 @@ int smb2_open(struct ksmbd_work *work)
 			rc = smb2_create_sd_buffer(work, req, &path);
 			if (rc) {
 				if (posix_acl_rc)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					ksmbd_vfs_set_init_posix_acl(idmap,
+								     &path);
+#else
 					ksmbd_vfs_set_init_posix_acl(user_ns,
-								     path.dentry);
+								     &path);
+#endif
 
 				if (test_share_config_flag(work->tcon->share_conf,
 							   KSMBD_SHARE_FLAG_ACL_XATTR)) {
@@ -3005,7 +3276,11 @@ int smb2_open(struct ksmbd_work *work)
 					struct smb_ntsd *pntsd;
 					int pntsd_size, ace_num = 0;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					ksmbd_acls_fattr(&fattr, idmap, inode);
+#else
 					ksmbd_acls_fattr(&fattr, user_ns, inode);
+#endif
 					if (fattr.cf_acls)
 						ace_num = fattr.cf_acls->a_count;
 					if (fattr.cf_dacls)
@@ -3022,7 +3297,11 @@ int smb2_open(struct ksmbd_work *work)
 						goto err_out;
 					}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					rc = build_sec_desc(idmap,
+#else
 					rc = build_sec_desc(user_ns,
+#endif
 							    pntsd, NULL, 0,
 							    OWNER_SECINFO |
 							    GROUP_SECINFO |
@@ -3036,10 +3315,15 @@ int smb2_open(struct ksmbd_work *work)
 					}
 
 					rc = ksmbd_vfs_set_sd_xattr(conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+								    idmap,
+#else
 								    user_ns,
-								    path.dentry,
+#endif
+								    &path,
 								    pntsd,
-								    pntsd_size);
+								    pntsd_size,
+								    false);
 					kfree(pntsd);
 					if (rc)
 						pr_err("failed to store ntacl in xattr : %d\n",
@@ -3062,11 +3346,6 @@ int smb2_open(struct ksmbd_work *work)
 
 	fp->attrib_only = !(req->DesiredAccess & ~(FILE_READ_ATTRIBUTES_LE |
 			FILE_WRITE_ATTRIBUTES_LE | FILE_SYNCHRONIZE_LE));
-	if (!S_ISDIR(file_inode(filp)->i_mode) && open_flags & O_TRUNC &&
-	    !fp->attrib_only && !stream_name) {
-		smb_break_all_oplock(work, fp);
-		need_truncate = 1;
-	}
 
 	/* fp should be searchable through ksmbd_inode.m_fp_list
 	 * after daccess, saccess, attrib_only, and stream are
@@ -3082,23 +3361,48 @@ int smb2_open(struct ksmbd_work *work)
 		goto err_out;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	if (file_present || created)
+		ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	if (file_present || created)
+		path_put(&path);
+#endif
+
+	if (!S_ISDIR(file_inode(filp)->i_mode) && open_flags & O_TRUNC &&
+	    !fp->attrib_only && !stream_name) {
+		smb_break_all_oplock(work, fp);
+		need_truncate = 1;
+	}
+
+	req_op_level = req->RequestedOplockLevel;
+	if (req_op_level == SMB2_OPLOCK_LEVEL_LEASE)
+		lc = parse_lease_state(req, S_ISDIR(file_inode(filp)->i_mode));
+
 	share_ret = ksmbd_smb_check_shared_mode(fp->filp, fp);
 	if (!test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_OPLOCKS) ||
 	    (req_op_level == SMB2_OPLOCK_LEVEL_LEASE &&
 	     !(conn->vals->capabilities & SMB2_GLOBAL_CAP_LEASING))) {
 		if (share_ret < 0 && !S_ISDIR(file_inode(fp->filp)->i_mode)) {
 			rc = share_ret;
-			goto err_out;
+			goto err_out1;
 		}
 	} else {
 		if (req_op_level == SMB2_OPLOCK_LEVEL_LEASE) {
+			/*
+			 * Compare parent lease using parent key. If there is no
+			 * a lease that has same parent key, Send lease break
+			 * notification.
+			 */
+			smb_send_parent_lease_break_noti(fp, lc);
+
 			req_op_level = smb2_map_lease_to_oplock(lc->req_state);
 			ksmbd_debug(SMB,
 				    "lease req for(%s) req oplock state 0x%x, lease state 0x%x\n",
 				    name, req_op_level, lc->req_state);
 			rc = find_same_lease_key(sess, fp->f_ci, lc);
 			if (rc)
-				goto err_out;
+				goto err_out1;
 		} else if (open_flags == O_RDONLY &&
 			   (req_op_level == SMB2_OPLOCK_LEVEL_BATCH ||
 			    req_op_level == SMB2_OPLOCK_LEVEL_EXCLUSIVE))
@@ -3109,26 +3413,26 @@ int smb2_open(struct ksmbd_work *work)
 				      le32_to_cpu(req->hdr.Id.SyncId.TreeId),
 				      lc, share_ret);
 		if (rc < 0)
-			goto err_out;
+			goto err_out1;
 	}
 
 	if (req->CreateOptions & FILE_DELETE_ON_CLOSE_LE)
 		ksmbd_fd_set_delete_on_close(fp, file_info);
 
 	if (need_truncate) {
-		rc = smb2_create_truncate(&path);
+		rc = smb2_create_truncate(&fp->filp->f_path);
 		if (rc)
-			goto err_out;
+			goto err_out1;
 	}
 
 	if (req->CreateContextsOffset) {
 		struct create_alloc_size_req *az_req;
 
 		az_req = (struct create_alloc_size_req *)smb2_find_context_vals(req,
-					SMB2_CREATE_ALLOCATION_SIZE);
+					SMB2_CREATE_ALLOCATION_SIZE, 4);
 		if (IS_ERR(az_req)) {
 			rc = PTR_ERR(az_req);
-			goto err_out;
+			goto err_out1;
 		} else if (az_req) {
 			loff_t alloc_size;
 			int err;
@@ -3137,7 +3441,7 @@ int smb2_open(struct ksmbd_work *work)
 			    le32_to_cpu(az_req->ccontext.DataLength) <
 			    sizeof(struct create_alloc_size_req)) {
 				rc = -EINVAL;
-				goto err_out;
+				goto err_out1;
 			}
 			alloc_size = le64_to_cpu(az_req->AllocationSize);
 			ksmbd_debug(SMB,
@@ -3152,10 +3456,10 @@ int smb2_open(struct ksmbd_work *work)
 					    err);
 		}
 
-		context = smb2_find_context_vals(req, SMB2_CREATE_QUERY_ON_DISK_ID);
+		context = smb2_find_context_vals(req, SMB2_CREATE_QUERY_ON_DISK_ID, 4);
 		if (IS_ERR(context)) {
 			rc = PTR_ERR(context);
-			goto err_out;
+			goto err_out1;
 		} else if (context) {
 			ksmbd_debug(SMB, "get query on disk id context\n");
 			query_disk_id = 1;
@@ -3164,7 +3468,7 @@ int smb2_open(struct ksmbd_work *work)
 
 	rc = ksmbd_vfs_getattr(&path, &stat);
 	if (rc)
-		goto err_out;
+		goto err_out1;
 
 	if (stat.result_mask & STATX_BTIME)
 		fp->create_time = ksmbd_UnixTimeToNT(stat.btime);
@@ -3186,7 +3490,7 @@ int smb2_open(struct ksmbd_work *work)
 	opinfo = rcu_dereference(fp->f_opinfo);
 	rsp->OplockLevel = opinfo != NULL ? opinfo->level : 0;
 	rcu_read_unlock();
-	rsp->Flags = 0;
+	rsp->Reserved = 0;
 	rsp->CreateAction = cpu_to_le32(file_info);
 	rsp->CreationTime = cpu_to_le64(fp->create_time);
 	time = ksmbd_UnixTimeToNT(stat.atime);
@@ -3207,7 +3511,7 @@ int smb2_open(struct ksmbd_work *work)
 
 	rsp->CreateContextsOffset = 0;
 	rsp->CreateContextsLength = 0;
-	inc_rfc1001_len(work->response_buf, 88); /* StructureSize - 1*/
+	iov_len = offsetof(struct smb2_create_rsp, Buffer);
 
 	/* If lease is request send lease context response */
 	if (opinfo && opinfo->is_lease) {
@@ -3222,8 +3526,7 @@ int smb2_open(struct ksmbd_work *work)
 		create_lease_buf(rsp->Buffer, opinfo->o_lease);
 		le32_add_cpu(&rsp->CreateContextsLength,
 			     conn->vals->create_lease_size);
-		inc_rfc1001_len(work->response_buf,
-				conn->vals->create_lease_size);
+		iov_len += conn->vals->create_lease_size;
 		next_ptr = &lease_ccontext->Next;
 		next_off = conn->vals->create_lease_size;
 	}
@@ -3232,7 +3535,11 @@ int smb2_open(struct ksmbd_work *work)
 		struct create_context *mxac_ccontext;
 
 		if (maximal_access == 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			ksmbd_vfs_query_maximal_access(idmap,
+#else
 			ksmbd_vfs_query_maximal_access(user_ns,
+#endif
 						       path.dentry,
 						       &maximal_access);
 		mxac_ccontext = (struct create_context *)(rsp->Buffer +
@@ -3243,8 +3550,7 @@ int smb2_open(struct ksmbd_work *work)
 				le32_to_cpu(maximal_access));
 		le32_add_cpu(&rsp->CreateContextsLength,
 			     conn->vals->create_mxac_size);
-		inc_rfc1001_len(work->response_buf,
-				conn->vals->create_mxac_size);
+		iov_len += conn->vals->create_mxac_size;
 		if (next_ptr)
 			*next_ptr = cpu_to_le32(next_off);
 		next_ptr = &mxac_ccontext->Next;
@@ -3262,8 +3568,7 @@ int smb2_open(struct ksmbd_work *work)
 				stat.ino, tcon->id);
 		le32_add_cpu(&rsp->CreateContextsLength,
 			     conn->vals->create_disk_id_size);
-		inc_rfc1001_len(work->response_buf,
-				conn->vals->create_disk_id_size);
+		iov_len += conn->vals->create_disk_id_size;
 		if (next_ptr)
 			*next_ptr = cpu_to_le32(next_off);
 		next_ptr = &disk_id_ccontext->Next;
@@ -3277,8 +3582,7 @@ int smb2_open(struct ksmbd_work *work)
 				fp);
 		le32_add_cpu(&rsp->CreateContextsLength,
 			     conn->vals->create_posix_size);
-		inc_rfc1001_len(work->response_buf,
-				conn->vals->create_posix_size);
+		iov_len += conn->vals->create_posix_size;
 		if (next_ptr)
 			*next_ptr = cpu_to_le32(next_off);
 	}
@@ -3289,10 +3593,20 @@ int smb2_open(struct ksmbd_work *work)
 	}
 
 err_out:
-	if (file_present || created)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	if (rc && (file_present || created))
+		ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	if (rc && (file_present || created))
 		path_put(&path);
-	ksmbd_revert_fsids(work);
+#endif
 err_out1:
+	ksmbd_revert_fsids(work);
+err_out2:
+	if (!rc) {
+		ksmbd_update_fstate(&work->sess->file_table, fp, FP_INITED);
+		rc = ksmbd_iov_pin_rsp(work, (void *)rsp, iov_len);
+	}
 	if (rc) {
 		if (rc == -EINVAL)
 			rsp->hdr.Status = STATUS_INVALID_PARAMETER;
@@ -3490,9 +3804,9 @@ static int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,
 		ffdinfo->EaSize =
 			smb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);
 		if (ffdinfo->EaSize)
-			ffdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;
+			ffdinfo->ExtFileAttributes = ATTR_REPARSE_POINT_LE;
 		if (d_info->hide_dot_file && d_info->name[0] == '.')
-			ffdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;
+			ffdinfo->ExtFileAttributes |= ATTR_HIDDEN_LE;
 		memcpy(ffdinfo->FileName, conv_name, conv_len);
 		ffdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
 		break;
@@ -3506,11 +3820,11 @@ static int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,
 		fbdinfo->EaSize =
 			smb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);
 		if (fbdinfo->EaSize)
-			fbdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;
+			fbdinfo->ExtFileAttributes = ATTR_REPARSE_POINT_LE;
 		fbdinfo->ShortNameLength = 0;
 		fbdinfo->Reserved = 0;
 		if (d_info->hide_dot_file && d_info->name[0] == '.')
-			fbdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;
+			fbdinfo->ExtFileAttributes |= ATTR_HIDDEN_LE;
 		memcpy(fbdinfo->FileName, conv_name, conv_len);
 		fbdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
 		break;
@@ -3522,7 +3836,7 @@ static int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,
 		fdinfo = (struct file_directory_info *)kstat;
 		fdinfo->FileNameLength = cpu_to_le32(conv_len);
 		if (d_info->hide_dot_file && d_info->name[0] == '.')
-			fdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;
+			fdinfo->ExtFileAttributes |= ATTR_HIDDEN_LE;
 		memcpy(fdinfo->FileName, conv_name, conv_len);
 		fdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
 		break;
@@ -3546,11 +3860,11 @@ static int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,
 		dinfo->EaSize =
 			smb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);
 		if (dinfo->EaSize)
-			dinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;
+			dinfo->ExtFileAttributes = ATTR_REPARSE_POINT_LE;
 		dinfo->Reserved = 0;
 		dinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);
 		if (d_info->hide_dot_file && d_info->name[0] == '.')
-			dinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;
+			dinfo->ExtFileAttributes |= ATTR_HIDDEN_LE;
 		memcpy(dinfo->FileName, conv_name, conv_len);
 		dinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
 		break;
@@ -3564,13 +3878,13 @@ static int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,
 		fibdinfo->EaSize =
 			smb2_get_reparse_tag_special_file(ksmbd_kstat->kstat->mode);
 		if (fibdinfo->EaSize)
-			fibdinfo->ExtFileAttributes = FILE_ATTRIBUTE_REPARSE_POINT_LE;
+			fibdinfo->ExtFileAttributes = ATTR_REPARSE_POINT_LE;
 		fibdinfo->UniqueId = cpu_to_le64(ksmbd_kstat->kstat->ino);
 		fibdinfo->ShortNameLength = 0;
 		fibdinfo->Reserved = 0;
 		fibdinfo->Reserved2 = cpu_to_le16(0);
 		if (d_info->hide_dot_file && d_info->name[0] == '.')
-			fibdinfo->ExtFileAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;
+			fibdinfo->ExtFileAttributes |= ATTR_HIDDEN_LE;
 		memcpy(fibdinfo->FileName, conv_name, conv_len);
 		fibdinfo->NextEntryOffset = cpu_to_le32(next_entry_offset);
 		break;
@@ -3596,14 +3910,13 @@ static int smb2_populate_readdir_entry(struct ksmbd_conn *conn, int info_level,
 		posix_info->Mode = cpu_to_le32(ksmbd_kstat->kstat->mode & 0777);
 		posix_info->Inode = cpu_to_le64(ksmbd_kstat->kstat->ino);
 		posix_info->DosAttributes =
-			S_ISDIR(ksmbd_kstat->kstat->mode) ?
-				FILE_ATTRIBUTE_DIRECTORY_LE : FILE_ATTRIBUTE_ARCHIVE_LE;
+			S_ISDIR(ksmbd_kstat->kstat->mode) ? ATTR_DIRECTORY_LE : ATTR_ARCHIVE_LE;
 		if (d_info->hide_dot_file && d_info->name[0] == '.')
-			posix_info->DosAttributes |= FILE_ATTRIBUTE_HIDDEN_LE;
+			posix_info->DosAttributes |= ATTR_HIDDEN_LE;
 		/*
 		 * SidBuffer(32) contain two sids(Domain sid(16), UNIX group sid(16)).
 		 * UNIX sid(16) = revision(1) + num_subauth(1) + authority(6) +
-		 *		  sub_auth(4 * 1(num_subauth)) + RID(4).
+		 * 		  sub_auth(4 * 1(num_subauth)) + RID(4).
 		 */
 		id_to_sid(from_kuid_munged(&init_user_ns, ksmbd_kstat->kstat->uid),
 			  SIDUNIX_USER, (struct smb_sid *)&posix_info->SidBuffer[0]);
@@ -3657,7 +3970,11 @@ static void unlock_dir(struct ksmbd_file *dir_fp)
 
 static int process_query_dir_entries(struct smb2_query_dir_private *priv)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap	*idmap = file_mnt_idmap(priv->dir_fp->filp);
+#else
 	struct user_namespace	*user_ns = file_mnt_user_ns(priv->dir_fp->filp);
+#endif
 	struct kstat		kstat;
 	struct ksmbd_kstat	ksmbd_kstat;
 	int			rc;
@@ -3670,9 +3987,19 @@ static int process_query_dir_entries(struct smb2_query_dir_private *priv)
 			return -EINVAL;
 
 		lock_dir(priv->dir_fp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		dent = lookup_one(idmap, priv->d_info->name,
+#else
 		dent = lookup_one(user_ns, priv->d_info->name,
+#endif
+				  priv->dir_fp->filp->f_path.dentry,
+				  priv->d_info->name_len);
+#else
+		dent = lookup_one_len(priv->d_info->name,
 				  priv->dir_fp->filp->f_path.dentry,
 				  priv->d_info->name_len);
+#endif
 		unlock_dir(priv->dir_fp);
 
 		if (IS_ERR(dent)) {
@@ -3691,7 +4018,12 @@ static int process_query_dir_entries(struct smb2_query_dir_private *priv)
 		ksmbd_kstat.kstat = &kstat;
 		if (priv->info_level != FILE_NAMES_INFORMATION)
 			ksmbd_vfs_fill_dentry_attrs(priv->work,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+						    idmap,
+#else
 						    user_ns,
+#endif
+
 						    dent,
 						    &ksmbd_kstat);
 
@@ -3813,7 +4145,11 @@ static int reserve_populate_dentry(struct ksmbd_dir_info *d_info,
 	return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 static bool __query_dir(struct dir_context *ctx, const char *name, int namlen,
+#else
+static int __query_dir(struct dir_context *ctx, const char *name, int namlen,
+#endif
 		       loff_t offset, u64 ino, unsigned int d_type)
 {
 	struct ksmbd_readdir_data	*buf;
@@ -3827,20 +4163,46 @@ static bool __query_dir(struct dir_context *ctx, const char *name, int namlen,
 
 	/* dot and dotdot entries are already reserved */
 	if (!strcmp(".", name) || !strcmp("..", name))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 		return true;
+#else
+		return 0;
+#endif
 	if (ksmbd_share_veto_filename(priv->work->tcon->share_conf, name))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 		return true;
+#else
+		return 0;
+#endif
 	if (!match_pattern(name, namlen, priv->search_pattern))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 		return true;
+#else
+		return 0;
+#endif
 
 	d_info->name		= name;
 	d_info->name_len	= namlen;
 	rc = reserve_populate_dentry(d_info, priv->info_level);
 	if (rc)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 		return false;
-	if (d_info->flags & SMB2_RETURN_SINGLE_ENTRY)
+#else
+		return rc;
+#endif
+	if (d_info->flags & SMB2_RETURN_SINGLE_ENTRY) {
 		d_info->out_buf_len = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
+		return true;
+#else
+		return 0;
+#endif
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 	return true;
+#else
+	return 0;
+#endif
 }
 
 static int verify_info_level(int info_level)
@@ -3920,10 +4282,19 @@ int smb2_query_dir(struct ksmbd_work *work)
 		goto err_out2;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 	if (!(dir_fp->daccess & FILE_LIST_DIRECTORY_LE) ||
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	    inode_permission(file_mnt_idmap(dir_fp->filp),
+#else
 	    inode_permission(file_mnt_user_ns(dir_fp->filp),
+#endif
 			     file_inode(dir_fp->filp),
 			     MAY_READ | MAY_EXEC)) {
+#else
+	if (!(dir_fp->daccess & FILE_LIST_DIRECTORY_LE) ||
+	    inode_permission(file_inode(dir_fp->filp), MAY_READ | MAY_EXEC)) {
+#endif
 		pr_err("no right to enumerate directory (%pD)\n", dir_fp->filp);
 		rc = -EACCES;
 		goto err_out2;
@@ -4018,7 +4389,10 @@ int smb2_query_dir(struct ksmbd_work *work)
 		rsp->OutputBufferOffset = cpu_to_le16(0);
 		rsp->OutputBufferLength = cpu_to_le32(0);
 		rsp->Buffer[0] = 0;
-		inc_rfc1001_len(work->response_buf, 9);
+		rc = ksmbd_iov_pin_rsp(work, (void *)rsp,
+				       sizeof(struct smb2_query_directory_rsp));
+		if (rc)
+			goto err_out;
 	} else {
 no_buf_len:
 		((struct file_directory_info *)
@@ -4030,7 +4404,11 @@ int smb2_query_dir(struct ksmbd_work *work)
 		rsp->StructureSize = cpu_to_le16(9);
 		rsp->OutputBufferOffset = cpu_to_le16(72);
 		rsp->OutputBufferLength = cpu_to_le32(d_info.data_count);
-		inc_rfc1001_len(work->response_buf, 8 + d_info.data_count);
+		rc = ksmbd_iov_pin_rsp(work, (void *)rsp,
+				       offsetof(struct smb2_query_directory_rsp, Buffer) +
+				       d_info.data_count);
+		if (rc)
+			goto err_out;
 	}
 
 	kfree(srch_ptr);
@@ -4071,27 +4449,18 @@ int smb2_query_dir(struct ksmbd_work *work)
  * @reqOutputBufferLength:	max buffer length expected in command response
  * @rsp:		query info response buffer contains output buffer length
  * @rsp_org:		base response buffer pointer in case of chained response
- * @infoclass_size:	query info class response buffer size
  *
  * Return:	0 on success, otherwise error
  */
 static int buffer_check_err(int reqOutputBufferLength,
 			    struct smb2_query_info_rsp *rsp,
-			    void *rsp_org, int infoclass_size)
+			    void *rsp_org)
 {
 	if (reqOutputBufferLength < le32_to_cpu(rsp->OutputBufferLength)) {
-		if (reqOutputBufferLength < infoclass_size) {
-			pr_err("Invalid Buffer Size Requested\n");
-			rsp->hdr.Status = STATUS_INFO_LENGTH_MISMATCH;
-			*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr));
-			return -EINVAL;
-		}
-
-		ksmbd_debug(SMB, "Buffer Overflow\n");
-		rsp->hdr.Status = STATUS_BUFFER_OVERFLOW;
-		*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr) +
-				reqOutputBufferLength);
-		rsp->OutputBufferLength = cpu_to_le32(reqOutputBufferLength);
+		pr_err("Invalid Buffer Size Requested\n");
+		rsp->hdr.Status = STATUS_INFO_LENGTH_MISMATCH;
+		*(__be32 *)rsp_org = cpu_to_be32(sizeof(struct smb2_hdr));
+		return -EINVAL;
 	}
 	return 0;
 }
@@ -4110,7 +4479,6 @@ static void get_standard_info_pipe(struct smb2_query_info_rsp *rsp,
 	sinfo->Directory = 0;
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_standard_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_standard_info));
 }
 
 static void get_internal_info_pipe(struct smb2_query_info_rsp *rsp, u64 num,
@@ -4124,7 +4492,6 @@ static void get_internal_info_pipe(struct smb2_query_info_rsp *rsp, u64 num,
 	file_info->IndexNumber = cpu_to_le64(num | (1ULL << 63));
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_internal_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));
 }
 
 static int smb2_get_info_file_pipe(struct ksmbd_session *sess,
@@ -4150,14 +4517,12 @@ static int smb2_get_info_file_pipe(struct ksmbd_session *sess,
 	case FILE_STANDARD_INFORMATION:
 		get_standard_info_pipe(rsp, rsp_org);
 		rc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),
-				      rsp, rsp_org,
-				      FILE_STANDARD_INFORMATION_SIZE);
+				      rsp, rsp_org);
 		break;
 	case FILE_INTERNAL_INFORMATION:
 		get_internal_info_pipe(rsp, id, rsp_org);
 		rc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),
-				      rsp, rsp_org,
-				      FILE_INTERNAL_INFORMATION_SIZE);
+				      rsp, rsp_org);
 		break;
 	default:
 		ksmbd_debug(SMB, "smb2_info_file_pipe for %u not supported\n",
@@ -4187,7 +4552,11 @@ static int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,
 	ssize_t buf_free_len, alignment_bytes, next_offset, rsp_data_cnt = 0;
 	struct smb2_ea_info_req *ea_req = NULL;
 	const struct path *path;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(fp->filp);
+#else
 	struct user_namespace *user_ns = file_mnt_user_ns(fp->filp);
+#endif
 
 	if (!(fp->daccess & FILE_READ_EA_LE)) {
 		pr_err("Not permitted to read ext attr : 0x%x\n",
@@ -4263,11 +4632,15 @@ static int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,
 		if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))
 			name_len -= XATTR_USER_PREFIX_LEN;
 
-		ptr = (char *)(&eainfo->name + name_len + 1);
+		ptr = eainfo->name + name_len + 1;
 		buf_free_len -= (offsetof(struct smb2_ea_info, name) +
 				name_len + 1);
 		/* bailout if xattr can't fit in buf_free_len */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		value_len = ksmbd_vfs_getxattr(idmap, path->dentry,
+#else
 		value_len = ksmbd_vfs_getxattr(user_ns, path->dentry,
+#endif
 					       name, &buf);
 		if (value_len <= 0) {
 			rc = -ENOENT;
@@ -4325,7 +4698,6 @@ static int smb2_get_ea(struct ksmbd_work *work, struct ksmbd_file *fp,
 	if (rsp_data_cnt == 0)
 		rsp->hdr.Status = STATUS_NO_EAS_ON_FILE;
 	rsp->OutputBufferLength = cpu_to_le32(rsp_data_cnt);
-	inc_rfc1001_len(rsp_org, rsp_data_cnt);
 out:
 	kvfree(xattr_list);
 	return rc;
@@ -4340,7 +4712,6 @@ static void get_file_access_info(struct smb2_query_info_rsp *rsp,
 	file_info->AccessFlags = fp->daccess;
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_access_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_access_info));
 }
 
 static int get_file_basic_info(struct smb2_query_info_rsp *rsp,
@@ -4357,8 +4728,22 @@ static int get_file_basic_info(struct smb2_query_info_rsp *rsp,
 	}
 
 	basic_info = (struct smb2_file_basic_info *)rsp->Buffer;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), STATX_BASIC_STATS,
+			file_inode(fp->filp), &stat);
+#else
+	generic_fillattr(file_mnt_idmap(fp->filp), file_inode(fp->filp),
+			 &stat);
+#endif
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),
 			 &stat);
+#endif
+#else
+	generic_fillattr(file_inode(fp->filp), &stat);
+#endif
 	basic_info->CreationTime = cpu_to_le64(fp->create_time);
 	time = ksmbd_UnixTimeToNT(stat.atime);
 	basic_info->LastAccessTime = cpu_to_le64(time);
@@ -4370,25 +4755,9 @@ static int get_file_basic_info(struct smb2_query_info_rsp *rsp,
 	basic_info->Pad1 = 0;
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_basic_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_basic_info));
 	return 0;
 }
 
-static unsigned long long get_allocation_size(struct inode *inode,
-					      struct kstat *stat)
-{
-	unsigned long long alloc_size = 0;
-
-	if (!S_ISDIR(stat->mode)) {
-		if ((inode->i_blocks << 9) <= stat->size)
-			alloc_size = stat->size;
-		else
-			alloc_size = inode->i_blocks << 9;
-	}
-
-	return alloc_size;
-}
-
 static void get_file_standard_info(struct smb2_query_info_rsp *rsp,
 				   struct ksmbd_file *fp, void *rsp_org)
 {
@@ -4398,20 +4767,30 @@ static void get_file_standard_info(struct smb2_query_info_rsp *rsp,
 	struct kstat stat;
 
 	inode = file_inode(fp->filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), STATX_BASIC_STATS, inode, &stat);
+#else
+	generic_fillattr(file_mnt_idmap(fp->filp), inode, &stat);
+#endif
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);
+#endif
+#else
+	generic_fillattr(inode, &stat);
+#endif
 
 	sinfo = (struct smb2_file_standard_info *)rsp->Buffer;
 	delete_pending = ksmbd_inode_pending_delete(fp);
 
-	sinfo->AllocationSize = cpu_to_le64(get_allocation_size(inode, &stat));
+	sinfo->AllocationSize = cpu_to_le64(inode->i_blocks << 9);
 	sinfo->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);
 	sinfo->NumberOfLinks = cpu_to_le32(get_nlink(&stat) - delete_pending);
 	sinfo->DeletePending = delete_pending;
 	sinfo->Directory = S_ISDIR(stat.mode) ? 1 : 0;
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_standard_info));
-	inc_rfc1001_len(rsp_org,
-			sizeof(struct smb2_file_standard_info));
 }
 
 static void get_file_alignment_info(struct smb2_query_info_rsp *rsp,
@@ -4423,8 +4802,6 @@ static void get_file_alignment_info(struct smb2_query_info_rsp *rsp,
 	file_info->AlignmentRequirement = 0;
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_alignment_info));
-	inc_rfc1001_len(rsp_org,
-			sizeof(struct smb2_file_alignment_info));
 }
 
 static int get_file_all_info(struct ksmbd_work *work,
@@ -4452,7 +4829,19 @@ static int get_file_all_info(struct ksmbd_work *work,
 		return PTR_ERR(filename);
 
 	inode = file_inode(fp->filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), STATX_BASIC_STATS, inode, &stat);
+#else
+	generic_fillattr(file_mnt_idmap(fp->filp), inode, &stat);
+#endif
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);
+#endif
+#else
+	generic_fillattr(inode, &stat);
+#endif
 
 	ksmbd_debug(SMB, "filename = %s\n", filename);
 	delete_pending = ksmbd_inode_pending_delete(fp);
@@ -4468,7 +4857,7 @@ static int get_file_all_info(struct ksmbd_work *work,
 	file_info->Attributes = fp->f_ci->m_fattr;
 	file_info->Pad1 = 0;
 	file_info->AllocationSize =
-		cpu_to_le64(get_allocation_size(inode, &stat));
+		cpu_to_le64(inode->i_blocks << 9);
 	file_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);
 	file_info->NumberOfLinks =
 			cpu_to_le32(get_nlink(&stat) - delete_pending);
@@ -4488,7 +4877,6 @@ static int get_file_all_info(struct ksmbd_work *work,
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_all_info) + conv_len - 1);
 	kfree(filename);
-	inc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));
 	return 0;
 }
 
@@ -4511,7 +4899,6 @@ static void get_file_alternate_info(struct ksmbd_work *work,
 	file_info->FileNameLength = cpu_to_le32(conv_len);
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_alt_name_info) + conv_len);
-	inc_rfc1001_len(rsp_org, le32_to_cpu(rsp->OutputBufferLength));
 }
 
 static void get_file_stream_info(struct ksmbd_work *work,
@@ -4529,8 +4916,22 @@ static void get_file_stream_info(struct ksmbd_work *work,
 	int buf_free_len;
 	struct smb2_query_info_req *req = ksmbd_req_buf_next(work);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), STATX_BASIC_STATS,
+			 file_inode(fp->filp), &stat);
+#else
+	generic_fillattr(file_mnt_idmap(fp->filp), file_inode(fp->filp),
+			 &stat);
+#endif
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),
 			 &stat);
+#endif
+#else
+	generic_fillattr(file_inode(fp->filp), &stat);
+#endif
 	file_info = (struct smb2_file_stream_info *)rsp->Buffer;
 
 	buf_free_len =
@@ -4611,7 +5012,6 @@ static void get_file_stream_info(struct ksmbd_work *work,
 	kvfree(xattr_list);
 
 	rsp->OutputBufferLength = cpu_to_le32(nbytes);
-	inc_rfc1001_len(rsp_org, nbytes);
 }
 
 static void get_file_internal_info(struct smb2_query_info_rsp *rsp,
@@ -4620,13 +5020,26 @@ static void get_file_internal_info(struct smb2_query_info_rsp *rsp,
 	struct smb2_file_internal_info *file_info;
 	struct kstat stat;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), STATX_BASIC_STATS,
+			 file_inode(fp->filp), &stat);
+#else
+	generic_fillattr(file_mnt_idmap(fp->filp), file_inode(fp->filp),
+			 &stat);
+#endif
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),
 			 &stat);
+#endif
+#else
+	generic_fillattr(file_inode(fp->filp), &stat);
+#endif
 	file_info = (struct smb2_file_internal_info *)rsp->Buffer;
 	file_info->IndexNumber = cpu_to_le64(stat.ino);
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_internal_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_internal_info));
 }
 
 static int get_file_network_open_info(struct smb2_query_info_rsp *rsp,
@@ -4646,7 +5059,19 @@ static int get_file_network_open_info(struct smb2_query_info_rsp *rsp,
 	file_info = (struct smb2_file_ntwrk_info *)rsp->Buffer;
 
 	inode = file_inode(fp->filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), STATX_BASIC_STATS, inode, &stat);
+#else
+	generic_fillattr(file_mnt_idmap(fp->filp), inode, &stat);
+#endif
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), inode, &stat);
+#endif
+#else
+	generic_fillattr(inode, &stat);
+#endif
 
 	file_info->CreationTime = cpu_to_le64(fp->create_time);
 	time = ksmbd_UnixTimeToNT(stat.atime);
@@ -4657,12 +5082,11 @@ static int get_file_network_open_info(struct smb2_query_info_rsp *rsp,
 	file_info->ChangeTime = cpu_to_le64(time);
 	file_info->Attributes = fp->f_ci->m_fattr;
 	file_info->AllocationSize =
-		cpu_to_le64(get_allocation_size(inode, &stat));
+		cpu_to_le64(inode->i_blocks << 9);
 	file_info->EndOfFile = S_ISDIR(stat.mode) ? 0 : cpu_to_le64(stat.size);
 	file_info->Reserved = cpu_to_le32(0);
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_ntwrk_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ntwrk_info));
 	return 0;
 }
 
@@ -4674,7 +5098,6 @@ static void get_file_ea_info(struct smb2_query_info_rsp *rsp, void *rsp_org)
 	file_info->EASize = 0;
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_ea_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_ea_info));
 }
 
 static void get_file_position_info(struct smb2_query_info_rsp *rsp,
@@ -4686,7 +5109,6 @@ static void get_file_position_info(struct smb2_query_info_rsp *rsp,
 	file_info->CurrentByteOffset = cpu_to_le64(fp->filp->f_pos);
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_pos_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_pos_info));
 }
 
 static void get_file_mode_info(struct smb2_query_info_rsp *rsp,
@@ -4698,7 +5120,6 @@ static void get_file_mode_info(struct smb2_query_info_rsp *rsp,
 	file_info->Mode = fp->coption & FILE_MODE_INFO_MASK;
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_mode_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_mode_info));
 }
 
 static void get_file_compression_info(struct smb2_query_info_rsp *rsp,
@@ -4707,8 +5128,22 @@ static void get_file_compression_info(struct smb2_query_info_rsp *rsp,
 	struct smb2_file_comp_info *file_info;
 	struct kstat stat;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	generic_fillattr(file_mnt_idmap(fp->filp), STATX_BASIC_STATS,
+			 file_inode(fp->filp), &stat);
+#else
+	generic_fillattr(file_mnt_idmap(fp->filp), file_inode(fp->filp),
+			 &stat);
+#endif
+#else
 	generic_fillattr(file_mnt_user_ns(fp->filp), file_inode(fp->filp),
 			 &stat);
+#endif
+#else
+	generic_fillattr(file_inode(fp->filp), &stat);
+#endif
 
 	file_info = (struct smb2_file_comp_info *)rsp->Buffer;
 	file_info->CompressedFileSize = cpu_to_le64(stat.blocks << 9);
@@ -4720,7 +5155,6 @@ static void get_file_compression_info(struct smb2_query_info_rsp *rsp,
 
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_comp_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_comp_info));
 }
 
 static int get_file_attribute_tag_info(struct smb2_query_info_rsp *rsp,
@@ -4739,28 +5173,49 @@ static int get_file_attribute_tag_info(struct smb2_query_info_rsp *rsp,
 	file_info->ReparseTag = 0;
 	rsp->OutputBufferLength =
 		cpu_to_le32(sizeof(struct smb2_file_attr_tag_info));
-	inc_rfc1001_len(rsp_org, sizeof(struct smb2_file_attr_tag_info));
 	return 0;
 }
 
-static int find_file_posix_info(struct smb2_query_info_rsp *rsp,
+static void find_file_posix_info(struct smb2_query_info_rsp *rsp,
 				struct ksmbd_file *fp, void *rsp_org)
 {
 	struct smb311_posix_qinfo *file_info;
 	struct inode *inode = file_inode(fp->filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(fp->filp);
+	vfsuid_t vfsuid = i_uid_into_vfsuid(idmap, inode);
+	vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
 	struct user_namespace *user_ns = file_mnt_user_ns(fp->filp);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	vfsuid_t vfsuid = i_uid_into_vfsuid(user_ns, inode);
 	vfsgid_t vfsgid = i_gid_into_vfsgid(user_ns, inode);
+#endif
+#endif
 	u64 time;
 	int out_buf_len = sizeof(struct smb311_posix_qinfo) + 32;
 
 	file_info = (struct smb311_posix_qinfo *)rsp->Buffer;
 	file_info->CreationTime = cpu_to_le64(fp->create_time);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
+	time = ksmbd_UnixTimeToNT(inode_get_atime(inode));
+#else
 	time = ksmbd_UnixTimeToNT(inode->i_atime);
+#endif
 	file_info->LastAccessTime = cpu_to_le64(time);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
+	time = ksmbd_UnixTimeToNT(inode_get_mtime(inode));
+#else
 	time = ksmbd_UnixTimeToNT(inode->i_mtime);
+#endif
 	file_info->LastWriteTime = cpu_to_le64(time);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	time = ksmbd_UnixTimeToNT(inode_get_ctime(inode));
+#else
 	time = ksmbd_UnixTimeToNT(inode->i_ctime);
+#endif
 	file_info->ChangeTime = cpu_to_le64(time);
 	file_info->DosAttributes = fp->f_ci->m_fattr;
 	file_info->Inode = cpu_to_le64(inode->i_ino);
@@ -4769,20 +5224,35 @@ static int find_file_posix_info(struct smb2_query_info_rsp *rsp,
 	file_info->HardLinks = cpu_to_le32(inode->i_nlink);
 	file_info->Mode = cpu_to_le32(inode->i_mode & 0777);
 	file_info->DeviceId = cpu_to_le32(inode->i_rdev);
-
 	/*
 	 * Sids(32) contain two sids(Domain sid(16), UNIX group sid(16)).
 	 * UNIX sid(16) = revision(1) + num_subauth(1) + authority(6) +
 	 *		  sub_auth(4 * 1(num_subauth)) + RID(4).
 	 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	id_to_sid(from_kuid_munged(&init_user_ns, vfsuid_into_kuid(vfsuid)),
+#else
+	id_to_sid(from_kuid_munged(&init_user_ns,
+				   i_uid_into_mnt(user_ns, inode)),
+#endif
+#else
+	id_to_sid(from_kuid_munged(&init_user_ns, inode->i_uid),
+#endif
 		  SIDUNIX_USER, (struct smb_sid *)&file_info->Sids[0]);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	id_to_sid(from_kgid_munged(&init_user_ns, vfsgid_into_kgid(vfsgid)),
+#else
+	id_to_sid(from_kgid_munged(&init_user_ns,
+				   i_gid_into_mnt(user_ns, inode)),
+#endif
+#else
+	id_to_sid(from_kgid_munged(&init_user_ns, inode->i_gid),
+#endif
 		  SIDUNIX_GROUP, (struct smb_sid *)&file_info->Sids[16]);
 
 	rsp->OutputBufferLength = cpu_to_le32(out_buf_len);
-	inc_rfc1001_len(rsp_org, out_buf_len);
-	return out_buf_len;
 }
 
 static int smb2_get_info_file(struct ksmbd_work *work,
@@ -4792,7 +5262,6 @@ static int smb2_get_info_file(struct ksmbd_work *work,
 	struct ksmbd_file *fp;
 	int fileinfoclass = 0;
 	int rc = 0;
-	int file_infoclass_size;
 	unsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;
 
 	if (test_share_config_flag(work->tcon->share_conf,
@@ -4825,85 +5294,69 @@ static int smb2_get_info_file(struct ksmbd_work *work,
 	switch (fileinfoclass) {
 	case FILE_ACCESS_INFORMATION:
 		get_file_access_info(rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_ACCESS_INFORMATION_SIZE;
 		break;
 
 	case FILE_BASIC_INFORMATION:
 		rc = get_file_basic_info(rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_BASIC_INFORMATION_SIZE;
 		break;
 
 	case FILE_STANDARD_INFORMATION:
 		get_file_standard_info(rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_STANDARD_INFORMATION_SIZE;
 		break;
 
 	case FILE_ALIGNMENT_INFORMATION:
 		get_file_alignment_info(rsp, work->response_buf);
-		file_infoclass_size = FILE_ALIGNMENT_INFORMATION_SIZE;
 		break;
 
 	case FILE_ALL_INFORMATION:
 		rc = get_file_all_info(work, rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_ALL_INFORMATION_SIZE;
 		break;
 
 	case FILE_ALTERNATE_NAME_INFORMATION:
 		get_file_alternate_info(work, rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_ALTERNATE_NAME_INFORMATION_SIZE;
 		break;
 
 	case FILE_STREAM_INFORMATION:
 		get_file_stream_info(work, rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_STREAM_INFORMATION_SIZE;
 		break;
 
 	case FILE_INTERNAL_INFORMATION:
 		get_file_internal_info(rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_INTERNAL_INFORMATION_SIZE;
 		break;
 
 	case FILE_NETWORK_OPEN_INFORMATION:
 		rc = get_file_network_open_info(rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_NETWORK_OPEN_INFORMATION_SIZE;
 		break;
 
 	case FILE_EA_INFORMATION:
 		get_file_ea_info(rsp, work->response_buf);
-		file_infoclass_size = FILE_EA_INFORMATION_SIZE;
 		break;
 
 	case FILE_FULL_EA_INFORMATION:
 		rc = smb2_get_ea(work, fp, req, rsp, work->response_buf);
-		file_infoclass_size = FILE_FULL_EA_INFORMATION_SIZE;
 		break;
 
 	case FILE_POSITION_INFORMATION:
 		get_file_position_info(rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_POSITION_INFORMATION_SIZE;
 		break;
 
 	case FILE_MODE_INFORMATION:
 		get_file_mode_info(rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_MODE_INFORMATION_SIZE;
 		break;
 
 	case FILE_COMPRESSION_INFORMATION:
 		get_file_compression_info(rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_COMPRESSION_INFORMATION_SIZE;
 		break;
 
 	case FILE_ATTRIBUTE_TAG_INFORMATION:
 		rc = get_file_attribute_tag_info(rsp, fp, work->response_buf);
-		file_infoclass_size = FILE_ATTRIBUTE_TAG_INFORMATION_SIZE;
 		break;
 	case SMB_FIND_FILE_POSIX_INFO:
 		if (!work->tcon->posix_extensions) {
 			pr_err("client doesn't negotiate with SMB3.1.1 POSIX Extensions\n");
 			rc = -EOPNOTSUPP;
 		} else {
-			file_infoclass_size = find_file_posix_info(rsp, fp,
-					work->response_buf);
+			find_file_posix_info(rsp, fp, work->response_buf);
 		}
 		break;
 	default:
@@ -4913,8 +5366,7 @@ static int smb2_get_info_file(struct ksmbd_work *work,
 	}
 	if (!rc)
 		rc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),
-				      rsp, work->response_buf,
-				      file_infoclass_size);
+				      rsp, work->response_buf);
 	ksmbd_fd_put(work, fp);
 	return rc;
 }
@@ -4930,7 +5382,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 	struct kstatfs stfs;
 	struct path path;
 	int rc = 0, len;
-	int fs_infoclass_size = 0;
 
 	if (!share->path)
 		return -EIO;
@@ -4960,8 +5411,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		info->DeviceType = cpu_to_le32(stfs.f_type);
 		info->DeviceCharacteristics = cpu_to_le32(0x00000020);
 		rsp->OutputBufferLength = cpu_to_le32(8);
-		inc_rfc1001_len(work->response_buf, 8);
-		fs_infoclass_size = FS_DEVICE_INFORMATION_SIZE;
 		break;
 	}
 	case FS_ATTRIBUTE_INFORMATION:
@@ -4990,8 +5439,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		info->FileSystemNameLen = cpu_to_le32(len);
 		sz = sizeof(struct filesystem_attribute_info) - 2 + len;
 		rsp->OutputBufferLength = cpu_to_le32(sz);
-		inc_rfc1001_len(work->response_buf, sz);
-		fs_infoclass_size = FS_ATTRIBUTE_INFORMATION_SIZE;
 		break;
 	}
 	case FS_VOLUME_INFORMATION:
@@ -5018,8 +5465,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		info->Reserved = 0;
 		sz = sizeof(struct filesystem_vol_info) - 2 + len;
 		rsp->OutputBufferLength = cpu_to_le32(sz);
-		inc_rfc1001_len(work->response_buf, sz);
-		fs_infoclass_size = FS_VOLUME_INFORMATION_SIZE;
 		break;
 	}
 	case FS_SIZE_INFORMATION:
@@ -5032,8 +5477,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		info->SectorsPerAllocationUnit = cpu_to_le32(1);
 		info->BytesPerSector = cpu_to_le32(stfs.f_bsize);
 		rsp->OutputBufferLength = cpu_to_le32(24);
-		inc_rfc1001_len(work->response_buf, 24);
-		fs_infoclass_size = FS_SIZE_INFORMATION_SIZE;
 		break;
 	}
 	case FS_FULL_SIZE_INFORMATION:
@@ -5049,8 +5492,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		info->SectorsPerAllocationUnit = cpu_to_le32(1);
 		info->BytesPerSector = cpu_to_le32(stfs.f_bsize);
 		rsp->OutputBufferLength = cpu_to_le32(32);
-		inc_rfc1001_len(work->response_buf, 32);
-		fs_infoclass_size = FS_FULL_SIZE_INFORMATION_SIZE;
 		break;
 	}
 	case FS_OBJECT_ID_INFORMATION:
@@ -5070,8 +5511,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		info->extended_info.rel_date = 0;
 		memcpy(info->extended_info.version_string, "1.1.0", strlen("1.1.0"));
 		rsp->OutputBufferLength = cpu_to_le32(64);
-		inc_rfc1001_len(work->response_buf, 64);
-		fs_infoclass_size = FS_OBJECT_ID_INFORMATION_SIZE;
 		break;
 	}
 	case FS_SECTOR_SIZE_INFORMATION:
@@ -5093,8 +5532,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		info->ByteOffsetForSectorAlignment = 0;
 		info->ByteOffsetForPartitionAlignment = 0;
 		rsp->OutputBufferLength = cpu_to_le32(28);
-		inc_rfc1001_len(work->response_buf, 28);
-		fs_infoclass_size = FS_SECTOR_SIZE_INFORMATION_SIZE;
 		break;
 	}
 	case FS_CONTROL_INFORMATION:
@@ -5115,8 +5552,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		info->DefaultQuotaLimit = cpu_to_le64(SMB2_NO_FID);
 		info->Padding = 0;
 		rsp->OutputBufferLength = cpu_to_le32(48);
-		inc_rfc1001_len(work->response_buf, 48);
-		fs_infoclass_size = FS_CONTROL_INFORMATION_SIZE;
 		break;
 	}
 	case FS_POSIX_INFORMATION:
@@ -5136,8 +5571,6 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 			info->TotalFileNodes = cpu_to_le64(stfs.f_files);
 			info->FreeFileNodes = cpu_to_le64(stfs.f_ffree);
 			rsp->OutputBufferLength = cpu_to_le32(56);
-			inc_rfc1001_len(work->response_buf, 56);
-			fs_infoclass_size = FS_POSIX_INFORMATION_SIZE;
 		}
 		break;
 	}
@@ -5146,8 +5579,7 @@ static int smb2_get_info_filesystem(struct ksmbd_work *work,
 		return -EOPNOTSUPP;
 	}
 	rc = buffer_check_err(le32_to_cpu(req->OutputBufferLength),
-			      rsp, work->response_buf,
-			      fs_infoclass_size);
+			      rsp, work->response_buf);
 	path_put(&path);
 	return rc;
 }
@@ -5157,7 +5589,11 @@ static int smb2_get_info_sec(struct ksmbd_work *work,
 			     struct smb2_query_info_rsp *rsp)
 {
 	struct ksmbd_file *fp;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct smb_ntsd *pntsd = (struct smb_ntsd *)rsp->Buffer, *ppntsd = NULL;
 	struct smb_fattr fattr = {{0}};
 	struct inode *inode;
@@ -5181,7 +5617,6 @@ static int smb2_get_info_sec(struct ksmbd_work *work,
 
 		secdesclen = sizeof(struct smb_ntsd);
 		rsp->OutputBufferLength = cpu_to_le32(secdesclen);
-		inc_rfc1001_len(work->response_buf, secdesclen);
 
 		return 0;
 	}
@@ -5204,19 +5639,35 @@ static int smb2_get_info_sec(struct ksmbd_work *work,
 	if (!fp)
 		return -ENOENT;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = file_mnt_idmap(fp->filp);
+#else
 	user_ns = file_mnt_user_ns(fp->filp);
+#endif
 	inode = file_inode(fp->filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ksmbd_acls_fattr(&fattr, idmap, inode);
+#else
 	ksmbd_acls_fattr(&fattr, user_ns, inode);
+#endif
 
 	if (test_share_config_flag(work->tcon->share_conf,
 				   KSMBD_SHARE_FLAG_ACL_XATTR))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		ppntsd_size = ksmbd_vfs_get_sd_xattr(work->conn, idmap,
+#else
 		ppntsd_size = ksmbd_vfs_get_sd_xattr(work->conn, user_ns,
+#endif
 						     fp->filp->f_path.dentry,
 						     &ppntsd);
 
 	/* Check if sd buffer size exceeds response buffer size */
 	if (smb2_resp_buf_len(work, 8) > ppntsd_size)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = build_sec_desc(idmap, pntsd, ppntsd, ppntsd_size,
+#else
 		rc = build_sec_desc(user_ns, pntsd, ppntsd, ppntsd_size,
+#endif
 				    addition_info, &secdesclen, &fattr);
 	posix_acl_release(fattr.cf_acls);
 	posix_acl_release(fattr.cf_dacls);
@@ -5226,7 +5677,6 @@ static int smb2_get_info_sec(struct ksmbd_work *work,
 		return rc;
 
 	rsp->OutputBufferLength = cpu_to_le32(secdesclen);
-	inc_rfc1001_len(work->response_buf, secdesclen);
 	return 0;
 }
 
@@ -5265,6 +5715,14 @@ int smb2_query_info(struct ksmbd_work *work)
 		rc = -EOPNOTSUPP;
 	}
 
+	if (!rc) {
+		rsp->StructureSize = cpu_to_le16(9);
+		rsp->OutputBufferOffset = cpu_to_le16(72);
+		rc = ksmbd_iov_pin_rsp(work, (void *)rsp,
+				       offsetof(struct smb2_query_info_rsp, Buffer) +
+					le32_to_cpu(rsp->OutputBufferLength));
+	}
+
 	if (rc < 0) {
 		if (rc == -EACCES)
 			rsp->hdr.Status = STATUS_ACCESS_DENIED;
@@ -5272,6 +5730,8 @@ int smb2_query_info(struct ksmbd_work *work)
 			rsp->hdr.Status = STATUS_FILE_CLOSED;
 		else if (rc == -EIO)
 			rsp->hdr.Status = STATUS_UNEXPECTED_IO_ERROR;
+		else if (rc == -ENOMEM)
+			rsp->hdr.Status = STATUS_INSUFFICIENT_RESOURCES;
 		else if (rc == -EOPNOTSUPP || rsp->hdr.Status == 0)
 			rsp->hdr.Status = STATUS_INVALID_INFO_CLASS;
 		smb2_set_err_rsp(work);
@@ -5280,9 +5740,6 @@ int smb2_query_info(struct ksmbd_work *work)
 			    rc);
 		return rc;
 	}
-	rsp->StructureSize = cpu_to_le16(9);
-	rsp->OutputBufferOffset = cpu_to_le16(72);
-	inc_rfc1001_len(work->response_buf, 8);
 	return 0;
 }
 
@@ -5295,8 +5752,10 @@ int smb2_query_info(struct ksmbd_work *work)
 static noinline int smb2_close_pipe(struct ksmbd_work *work)
 {
 	u64 id;
-	struct smb2_close_req *req = smb2_get_msg(work->request_buf);
-	struct smb2_close_rsp *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_close_req *req;
+	struct smb2_close_rsp *rsp;
+
+	WORK_BUFFERS(work, req, rsp);
 
 	id = req->VolatileFileId;
 	ksmbd_session_rpc_close(work->sess, id);
@@ -5311,8 +5770,9 @@ static noinline int smb2_close_pipe(struct ksmbd_work *work)
 	rsp->AllocationSize = 0;
 	rsp->EndOfFile = 0;
 	rsp->Attributes = 0;
-	inc_rfc1001_len(work->response_buf, 60);
-	return 0;
+
+	return ksmbd_iov_pin_rsp(work, (void *)rsp,
+				 sizeof(struct smb2_close_rsp));
 }
 
 /**
@@ -5390,63 +5850,154 @@ int smb2_close(struct ksmbd_work *work)
 			goto out;
 		}
 
-		inode = file_inode(fp->filp);
-		rsp->Flags = SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB;
-		rsp->AllocationSize = S_ISDIR(inode->i_mode) ? 0 :
-			cpu_to_le64(inode->i_blocks << 9);
-		rsp->EndOfFile = cpu_to_le64(inode->i_size);
-		rsp->Attributes = fp->f_ci->m_fattr;
-		rsp->CreationTime = cpu_to_le64(fp->create_time);
-		time = ksmbd_UnixTimeToNT(inode->i_atime);
-		rsp->LastAccessTime = cpu_to_le64(time);
-		time = ksmbd_UnixTimeToNT(inode->i_mtime);
-		rsp->LastWriteTime = cpu_to_le64(time);
-		time = ksmbd_UnixTimeToNT(inode->i_ctime);
-		rsp->ChangeTime = cpu_to_le64(time);
-		ksmbd_fd_put(work, fp);
-	} else {
-		rsp->Flags = 0;
-		rsp->AllocationSize = 0;
-		rsp->EndOfFile = 0;
-		rsp->Attributes = 0;
-		rsp->CreationTime = 0;
-		rsp->LastAccessTime = 0;
-		rsp->LastWriteTime = 0;
-		rsp->ChangeTime = 0;
+		inode = file_inode(fp->filp);
+		rsp->Flags = SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB;
+		rsp->AllocationSize = S_ISDIR(inode->i_mode) ? 0 :
+			cpu_to_le64(inode->i_blocks << 9);
+		rsp->EndOfFile = cpu_to_le64(inode->i_size);
+		rsp->Attributes = fp->f_ci->m_fattr;
+		rsp->CreationTime = cpu_to_le64(fp->create_time);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
+		time = ksmbd_UnixTimeToNT(inode_get_atime(inode));
+#else
+		time = ksmbd_UnixTimeToNT(inode->i_atime);
+#endif
+		rsp->LastAccessTime = cpu_to_le64(time);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
+		time = ksmbd_UnixTimeToNT(inode_get_mtime(inode));
+#else
+		time = ksmbd_UnixTimeToNT(inode->i_mtime);
+#endif
+		rsp->LastWriteTime = cpu_to_le64(time);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+		time = ksmbd_UnixTimeToNT(inode_get_ctime(inode));
+#else
+		time = ksmbd_UnixTimeToNT(inode->i_ctime);
+#endif
+		rsp->ChangeTime = cpu_to_le64(time);
+		ksmbd_fd_put(work, fp);
+	} else {
+		rsp->Flags = 0;
+		rsp->AllocationSize = 0;
+		rsp->EndOfFile = 0;
+		rsp->Attributes = 0;
+		rsp->CreationTime = 0;
+		rsp->LastAccessTime = 0;
+		rsp->LastWriteTime = 0;
+		rsp->ChangeTime = 0;
+	}
+
+	err = ksmbd_close_fd(work, volatile_id);
+out:
+	if (!err)
+		err = ksmbd_iov_pin_rsp(work, (void *)rsp,
+					sizeof(struct smb2_close_rsp));
+
+	if (err) {
+		if (rsp->hdr.Status == 0)
+			rsp->hdr.Status = STATUS_FILE_CLOSED;
+		smb2_set_err_rsp(work);
+	}
+
+	return err;
+}
+
+/**
+ * smb2_echo() - handler for smb2 echo(ping) command
+ * @work:	smb work containing echo request buffer
+ *
+ * Return:	0
+ */
+int smb2_echo(struct ksmbd_work *work)
+{
+	struct smb2_echo_rsp *rsp = smb2_get_msg(work->response_buf);
+
+	if (work->next_smb2_rcv_hdr_off)
+		rsp = ksmbd_resp_buf_next(work);
+
+	rsp->StructureSize = cpu_to_le16(4);
+	rsp->Reserved = 0;
+	return ksmbd_iov_pin_rsp(work, rsp, sizeof(struct smb2_echo_rsp));
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static int smb2_rename(struct ksmbd_work *work,
+		       struct ksmbd_file *fp,
+		       struct smb2_file_rename_info *file_info,
+		       struct nls_table *local_nls)
+{
+	struct ksmbd_share_config *share = fp->tcon->share_conf;
+	char *new_name = NULL;
+	int rc, flags = 0;
+
+	ksmbd_debug(SMB, "setting FILE_RENAME_INFO\n");
+	new_name = smb2_get_name(file_info->FileName,
+				 le32_to_cpu(file_info->FileNameLength),
+				 local_nls);
+	if (IS_ERR(new_name))
+		return PTR_ERR(new_name);
+
+	if (strchr(new_name, ':')) {
+		int s_type;
+		char *xattr_stream_name, *stream_name = NULL;
+		size_t xattr_stream_size;
+		int len;
+
+		rc = parse_stream_name(new_name, &stream_name, &s_type);
+		if (rc < 0)
+			goto out;
+
+		len = strlen(new_name);
+		if (len > 0 && new_name[len - 1] != '/') {
+			pr_err("not allow base filename in rename\n");
+			rc = -ESHARE;
+			goto out;
+		}
+
+		rc = ksmbd_vfs_xattr_stream_name(stream_name,
+						 &xattr_stream_name,
+						 &xattr_stream_size,
+						 s_type);
+		if (rc)
+			goto out;
+
+		rc = ksmbd_vfs_setxattr(file_mnt_idmap(fp->filp),
+					&fp->filp->f_path,
+					xattr_stream_name,
+					NULL, 0, 0, true);
+		if (rc < 0) {
+			pr_err("failed to store stream name in xattr: %d\n",
+			       rc);
+			rc = -EINVAL;
+			goto out;
+		}
+
+		goto out;
 	}
 
-	err = ksmbd_close_fd(work, volatile_id);
-out:
-	if (err) {
-		if (rsp->hdr.Status == 0)
-			rsp->hdr.Status = STATUS_FILE_CLOSED;
-		smb2_set_err_rsp(work);
-	} else {
-		inc_rfc1001_len(work->response_buf, 60);
+	ksmbd_debug(SMB, "new name %s\n", new_name);
+	if (ksmbd_share_veto_filename(share, new_name)) {
+		rc = -ENOENT;
+		ksmbd_debug(SMB, "Can't rename vetoed file: %s\n", new_name);
+		goto out;
 	}
 
-	return 0;
-}
-
-/**
- * smb2_echo() - handler for smb2 echo(ping) command
- * @work:	smb work containing echo request buffer
- *
- * Return:	0
- */
-int smb2_echo(struct ksmbd_work *work)
-{
-	struct smb2_echo_rsp *rsp = smb2_get_msg(work->response_buf);
+	if (!file_info->ReplaceIfExists)
+		flags = RENAME_NOREPLACE;
 
-	rsp->StructureSize = cpu_to_le16(4);
-	rsp->Reserved = 0;
-	inc_rfc1001_len(work->response_buf, 4);
-	return 0;
+	rc = ksmbd_vfs_rename(work, &fp->filp->f_path, new_name, flags);
+out:
+	kfree(new_name);
+	return rc;
 }
-
+#else
 static int smb2_rename(struct ksmbd_work *work,
 		       struct ksmbd_file *fp,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		       struct mnt_idmap *idmap,
+#else
 		       struct user_namespace *user_ns,
+#endif
 		       struct smb2_file_rename_info *file_info,
 		       struct nls_table *local_nls)
 {
@@ -5509,10 +6060,14 @@ static int smb2_rename(struct ksmbd_work *work,
 		if (rc)
 			goto out;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = ksmbd_vfs_setxattr(idmap,
+#else
 		rc = ksmbd_vfs_setxattr(user_ns,
-					fp->filp->f_path.dentry,
+#endif
+					&fp->filp->f_path,
 					xattr_stream_name,
-					NULL, 0, 0);
+					NULL, 0, 0, true);
 		if (rc < 0) {
 			pr_err("failed to store stream name in xattr: %d\n",
 			       rc);
@@ -5567,6 +6122,7 @@ static int smb2_rename(struct ksmbd_work *work,
 		kfree(new_name);
 	return rc;
 }
+#endif
 
 static int smb2_create_link(struct ksmbd_work *work,
 			    struct ksmbd_share_config *share,
@@ -5576,7 +6132,10 @@ static int smb2_create_link(struct ksmbd_work *work,
 {
 	char *link_name = NULL, *target_name = NULL, *pathname = NULL;
 	struct path path;
-	bool file_present = true;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	struct path parent_path;
+#endif
+	bool file_present = false;
 	int rc;
 
 	if (buf_len < (u64)sizeof(struct smb2_file_link_info) +
@@ -5604,18 +6163,29 @@ static int smb2_create_link(struct ksmbd_work *work,
 	}
 
 	ksmbd_debug(SMB, "target name is %s\n", target_name);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	rc = ksmbd_vfs_kern_path_locked(work, link_name, LOOKUP_NO_SYMLINKS,
+					&parent_path, &path, 0);
+#else
 	rc = ksmbd_vfs_kern_path(work, link_name, LOOKUP_NO_SYMLINKS, &path, 0);
+#endif
 	if (rc) {
 		if (rc != -ENOENT)
 			goto out;
-		file_present = false;
 	} else {
+		file_present = true;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
 		path_put(&path);
+#endif
 	}
 
 	if (file_info->ReplaceIfExists) {
 		if (file_present) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+			rc = ksmbd_vfs_remove_file(work, &path);
+#else
 			rc = ksmbd_vfs_remove_file(work, link_name);
+#endif
 			if (rc) {
 				rc = -EINVAL;
 				ksmbd_debug(SMB, "cannot delete %s\n",
@@ -5635,6 +6205,10 @@ static int smb2_create_link(struct ksmbd_work *work,
 	if (rc)
 		rc = -EINVAL;
 out:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	if (file_present)
+		ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#endif
 	if (!IS_ERR(link_name))
 		kfree(link_name);
 	kfree(pathname);
@@ -5648,7 +6222,11 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 	struct iattr attrs;
 	struct file *filp;
 	struct inode *inode;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	int rc = 0;
 
 	if (!(fp->daccess & FILE_WRITE_ATTRIBUTES_LE))
@@ -5657,7 +6235,11 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 	attrs.ia_valid = 0;
 	filp = fp->filp;
 	inode = file_inode(filp);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = file_mnt_idmap(filp);
+#else
 	user_ns = file_mnt_user_ns(filp);
+#endif
 
 	if (file_info->CreationTime)
 		fp->create_time = le64_to_cpu(file_info->CreationTime);
@@ -5671,7 +6253,11 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 	if (file_info->ChangeTime)
 		attrs.ia_ctime = ksmbd_NTtimeToUnix(file_info->ChangeTime);
 	else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+		attrs.ia_ctime = inode_get_ctime(inode);
+#else
 		attrs.ia_ctime = inode->i_ctime;
+#endif
 
 	if (file_info->LastWriteTime) {
 		attrs.ia_mtime = ksmbd_NTtimeToUnix(file_info->LastWriteTime);
@@ -5680,14 +6266,14 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 
 	if (file_info->Attributes) {
 		if (!S_ISDIR(inode->i_mode) &&
-		    file_info->Attributes & FILE_ATTRIBUTE_DIRECTORY_LE) {
+		    file_info->Attributes & ATTR_DIRECTORY_LE) {
 			pr_err("can't change a file to a directory\n");
 			return -EINVAL;
 		}
 
-		if (!(S_ISDIR(inode->i_mode) && file_info->Attributes == FILE_ATTRIBUTE_NORMAL_LE))
+		if (!(S_ISDIR(inode->i_mode) && file_info->Attributes == ATTR_NORMAL_LE))
 			fp->f_ci->m_fattr = file_info->Attributes |
-				(fp->f_ci->m_fattr & FILE_ATTRIBUTE_DIRECTORY_LE);
+				(fp->f_ci->m_fattr & ATTR_DIRECTORY_LE);
 	}
 
 	if (test_share_config_flag(share, KSMBD_SHARE_FLAG_STORE_DOS_ATTRS) &&
@@ -5701,8 +6287,8 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 		da.flags = XATTR_DOSINFO_ATTRIB | XATTR_DOSINFO_CREATE_TIME |
 			XATTR_DOSINFO_ITIME;
 
-		rc = ksmbd_vfs_set_dos_attrib_xattr(user_ns,
-						    filp->f_path.dentry, &da);
+		rc = compat_ksmbd_vfs_set_dos_attrib_xattr(&filp->f_path, &da,
+				true);
 		if (rc)
 			ksmbd_debug(SMB,
 				    "failed to restore file attribute in EA\n");
@@ -5717,10 +6303,24 @@ static int set_file_basic_info(struct ksmbd_file *fp,
 			return -EACCES;
 
 		inode_lock(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+		inode_set_ctime_to_ts(inode, attrs.ia_ctime);
+#else
 		inode->i_ctime = attrs.ia_ctime;
+#endif
 		attrs.ia_valid &= ~ATTR_CTIME;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = notify_change(idmap, dentry, &attrs, NULL);
+#else
 		rc = notify_change(user_ns, dentry, &attrs, NULL);
+#endif
+#else
+		rc = notify_change(dentry, &attrs, NULL);
+#endif
 		inode_unlock(inode);
+		if (rc)
+			return -EINVAL;
 	}
 	return rc;
 }
@@ -5808,11 +6408,35 @@ static int set_end_of_file_info(struct ksmbd_work *work, struct ksmbd_file *fp,
 	return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+static int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,
+			   struct smb2_file_rename_info *rename_info,
+			   unsigned int buf_len)
+{
+	if (!(fp->daccess & FILE_DELETE_LE)) {
+		pr_err("no right to delete : 0x%x\n", fp->daccess);
+		return -EACCES;
+	}
+
+	if (buf_len < (u64)sizeof(struct smb2_file_rename_info) +
+			le32_to_cpu(rename_info->FileNameLength))
+		return -EINVAL;
+
+	if (!le32_to_cpu(rename_info->FileNameLength))
+		return -EINVAL;
+
+	return smb2_rename(work, fp, rename_info, work->conn->local_nls);
+}
+#else
 static int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,
 			   struct smb2_file_rename_info *rename_info,
 			   unsigned int buf_len)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct ksmbd_file *parent_fp;
 	struct dentry *parent;
 	struct dentry *dentry = fp->filp->f_path.dentry;
@@ -5827,18 +6451,26 @@ static int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,
 			le32_to_cpu(rename_info->FileNameLength))
 		return -EINVAL;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = file_mnt_idmap(fp->filp);
+#else
 	user_ns = file_mnt_user_ns(fp->filp);
+#endif
 	if (ksmbd_stream_fd(fp))
 		goto next;
 
 	parent = dget_parent(dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ret = ksmbd_vfs_lock_parent(idmap, parent, dentry);
+#else
 	ret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);
+#endif
 	if (ret) {
 		dput(parent);
 		return ret;
 	}
 
-	parent_fp = ksmbd_lookup_fd_inode(d_inode(parent));
+	parent_fp = ksmbd_lookup_fd_inode(parent);
 	inode_unlock(d_inode(parent));
 	dput(parent);
 
@@ -5851,9 +6483,14 @@ static int set_rename_info(struct ksmbd_work *work, struct ksmbd_file *fp,
 		ksmbd_fd_put(work, parent_fp);
 	}
 next:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	return smb2_rename(work, fp, idmap, rename_info,
+#else
 	return smb2_rename(work, fp, user_ns, rename_info,
+#endif
 			   work->conn->local_nls);
 }
+#endif
 
 static int set_file_disposition_info(struct ksmbd_file *fp,
 				     struct smb2_file_disposition_info *file_info)
@@ -5907,7 +6544,9 @@ static int set_file_mode_info(struct ksmbd_file *fp,
 
 	mode = file_info->Mode;
 
-	if ((mode & ~FILE_MODE_INFO_MASK)) {
+	if ((mode & ~FILE_MODE_INFO_MASK) ||
+	    (mode & FILE_SYNCHRONOUS_IO_ALERT_LE &&
+	     mode & FILE_SYNCHRONOUS_IO_NONALERT_LE)) {
 		pr_err("Mode is not valid : 0x%x\n", le32_to_cpu(mode));
 		return -EINVAL;
 	}
@@ -6042,7 +6681,7 @@ static int smb2_set_info_sec(struct ksmbd_file *fp, int addition_info,
 	fp->saccess |= FILE_SHARE_DELETE_LE;
 
 	return set_info_sec(fp->conn, fp->tcon, &fp->filp->f_path, pntsd,
-			buf_len, false);
+			buf_len, false, true);
 }
 
 /**
@@ -6112,7 +6751,10 @@ int smb2_set_info(struct ksmbd_work *work)
 		goto err_out;
 
 	rsp->StructureSize = cpu_to_le16(2);
-	inc_rfc1001_len(work->response_buf, 2);
+	rc = ksmbd_iov_pin_rsp(work, (void *)rsp,
+			       sizeof(struct smb2_set_info_rsp));
+	if (rc)
+		goto err_out;
 	ksmbd_fd_put(work, fp);
 	return 0;
 
@@ -6152,33 +6794,43 @@ static noinline int smb2_read_pipe(struct ksmbd_work *work)
 	int nbytes = 0, err;
 	u64 id;
 	struct ksmbd_rpc_command *rpc_resp;
-	struct smb2_read_req *req = smb2_get_msg(work->request_buf);
-	struct smb2_read_rsp *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_read_req *req;
+	struct smb2_read_rsp *rsp;
+
+	WORK_BUFFERS(work, req, rsp);
 
 	id = req->VolatileFileId;
 
-	inc_rfc1001_len(work->response_buf, 16);
 	rpc_resp = ksmbd_rpc_read(work->sess, id);
 	if (rpc_resp) {
+		void *aux_payload_buf;
+
 		if (rpc_resp->flags != KSMBD_RPC_OK) {
 			err = -EINVAL;
 			goto out;
 		}
 
-		work->aux_payload_buf =
-			kvmalloc(rpc_resp->payload_sz, GFP_KERNEL | __GFP_ZERO);
-		if (!work->aux_payload_buf) {
+		aux_payload_buf =
+			kvmalloc(rpc_resp->payload_sz, GFP_KERNEL);
+		if (!aux_payload_buf) {
 			err = -ENOMEM;
 			goto out;
 		}
 
-		memcpy(work->aux_payload_buf, rpc_resp->payload,
-		       rpc_resp->payload_sz);
+		memcpy(aux_payload_buf, rpc_resp->payload, rpc_resp->payload_sz);
 
 		nbytes = rpc_resp->payload_sz;
-		work->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;
-		work->aux_payload_sz = nbytes;
+		err = ksmbd_iov_pin_rsp_read(work, (void *)rsp,
+					     offsetof(struct smb2_read_rsp, Buffer),
+					     aux_payload_buf, nbytes);
+		if (err)
+			goto out;
 		kvfree(rpc_resp);
+	} else {
+		err = ksmbd_iov_pin_rsp(work, (void *)rsp,
+					offsetof(struct smb2_read_rsp, Buffer));
+		if (err)
+			goto out;
 	}
 
 	rsp->StructureSize = cpu_to_le16(17);
@@ -6186,8 +6838,7 @@ static noinline int smb2_read_pipe(struct ksmbd_work *work)
 	rsp->Reserved = 0;
 	rsp->DataLength = cpu_to_le32(nbytes);
 	rsp->DataRemaining = 0;
-	rsp->Flags = 0;
-	inc_rfc1001_len(work->response_buf, nbytes);
+	rsp->Reserved2 = 0;
 	return 0;
 
 out:
@@ -6261,8 +6912,8 @@ int smb2_read(struct ksmbd_work *work)
 	int err = 0;
 	bool is_rdma_channel = false;
 	unsigned int max_read_size = conn->vals->max_read_size;
-
-	WORK_BUFFERS(work, req, rsp);
+	unsigned int id = KSMBD_NO_FID, pid = KSMBD_NO_FID;
+	void *aux_payload_buf;
 
 	if (test_share_config_flag(work->tcon->share_conf,
 				   KSMBD_SHARE_FLAG_PIPE)) {
@@ -6270,6 +6921,25 @@ int smb2_read(struct ksmbd_work *work)
 		return smb2_read_pipe(work);
 	}
 
+	if (work->next_smb2_rcv_hdr_off) {
+		req = ksmbd_req_buf_next(work);
+		rsp = ksmbd_resp_buf_next(work);
+		if (!has_file_id(req->VolatileFileId)) {
+			ksmbd_debug(SMB, "Compound request set FID = %llu\n",
+					work->compound_fid);
+			id = work->compound_fid;
+			pid = work->compound_pfid;
+		}
+	} else {
+		req = smb2_get_msg(work->request_buf);
+		rsp = smb2_get_msg(work->response_buf);
+	}
+
+	if (!has_file_id(id)) {
+		id = req->VolatileFileId;
+		pid = req->PersistentFileId;
+	}
+
 	if (req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE ||
 	    req->Channel == SMB2_CHANNEL_RDMA_V1) {
 		is_rdma_channel = true;
@@ -6292,7 +6962,7 @@ int smb2_read(struct ksmbd_work *work)
 			goto out;
 	}
 
-	fp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);
+	fp = ksmbd_lookup_fd_slow(work, id, pid);
 	if (!fp) {
 		err = -ENOENT;
 		goto out;
@@ -6318,21 +6988,20 @@ int smb2_read(struct ksmbd_work *work)
 	ksmbd_debug(SMB, "filename %pD, offset %lld, len %zu\n",
 		    fp->filp, offset, length);
 
-	work->aux_payload_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);
-	if (!work->aux_payload_buf) {
+	aux_payload_buf = kvzalloc(length, GFP_KERNEL);
+	if (!aux_payload_buf) {
 		err = -ENOMEM;
 		goto out;
 	}
 
-	nbytes = ksmbd_vfs_read(work, fp, length, &offset);
+	nbytes = ksmbd_vfs_read(work, fp, length, &offset, aux_payload_buf);
 	if (nbytes < 0) {
 		err = nbytes;
 		goto out;
 	}
 
 	if ((nbytes == 0 && length != 0) || nbytes < mincount) {
-		kvfree(work->aux_payload_buf);
-		work->aux_payload_buf = NULL;
+		kvfree(aux_payload_buf);
 		rsp->hdr.Status = STATUS_END_OF_FILE;
 		smb2_set_err_rsp(work);
 		ksmbd_fd_put(work, fp);
@@ -6345,11 +7014,10 @@ int smb2_read(struct ksmbd_work *work)
 	if (is_rdma_channel == true) {
 		/* write data to the client using rdma channel */
 		remain_bytes = smb2_read_rdma_channel(work, req,
-						      work->aux_payload_buf,
+						      aux_payload_buf,
 						      nbytes);
-		kvfree(work->aux_payload_buf);
-		work->aux_payload_buf = NULL;
-
+		kvfree(aux_payload_buf);
+		aux_payload_buf = NULL;
 		nbytes = 0;
 		if (remain_bytes < 0) {
 			err = (int)remain_bytes;
@@ -6362,11 +7030,12 @@ int smb2_read(struct ksmbd_work *work)
 	rsp->Reserved = 0;
 	rsp->DataLength = cpu_to_le32(nbytes);
 	rsp->DataRemaining = cpu_to_le32(remain_bytes);
-	rsp->Flags = 0;
-	inc_rfc1001_len(work->response_buf, 16);
-	work->resp_hdr_sz = get_rfc1002_len(work->response_buf) + 4;
-	work->aux_payload_sz = nbytes;
-	inc_rfc1001_len(work->response_buf, nbytes);
+	rsp->Reserved2 = 0;
+	err = ksmbd_iov_pin_rsp_read(work, (void *)rsp,
+				     offsetof(struct smb2_read_rsp, Buffer),
+				     aux_payload_buf, nbytes);
+	if (err)
+		goto out;
 	ksmbd_fd_put(work, fp);
 	return 0;
 
@@ -6401,14 +7070,16 @@ int smb2_read(struct ksmbd_work *work)
  */
 static noinline int smb2_write_pipe(struct ksmbd_work *work)
 {
-	struct smb2_write_req *req = smb2_get_msg(work->request_buf);
-	struct smb2_write_rsp *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_write_req *req;
+	struct smb2_write_rsp *rsp;
 	struct ksmbd_rpc_command *rpc_resp;
 	u64 id = 0;
 	int err = 0, ret = 0;
 	char *data_buf;
 	size_t length;
 
+	WORK_BUFFERS(work, req, rsp);
+
 	length = le32_to_cpu(req->Length);
 	id = req->VolatileFileId;
 
@@ -6447,8 +7118,8 @@ static noinline int smb2_write_pipe(struct ksmbd_work *work)
 	rsp->DataLength = cpu_to_le32(length);
 	rsp->DataRemaining = 0;
 	rsp->Reserved2 = 0;
-	inc_rfc1001_len(work->response_buf, 16);
-	return 0;
+	err = ksmbd_iov_pin_rsp(work, (void *)rsp,
+				offsetof(struct smb2_write_rsp, Buffer));
 out:
 	if (err) {
 		rsp->hdr.Status = STATUS_INVALID_HANDLE;
@@ -6467,7 +7138,7 @@ static ssize_t smb2_write_rdma_channel(struct ksmbd_work *work,
 	int ret;
 	ssize_t nbytes;
 
-	data_buf = kvmalloc(length, GFP_KERNEL | __GFP_ZERO);
+	data_buf = kvzalloc(length, GFP_KERNEL);
 	if (!data_buf)
 		return -ENOMEM;
 
@@ -6604,7 +7275,9 @@ int smb2_write(struct ksmbd_work *work)
 	rsp->DataLength = cpu_to_le32(nbytes);
 	rsp->DataRemaining = 0;
 	rsp->Reserved2 = 0;
-	inc_rfc1001_len(work->response_buf, 16);
+	err = ksmbd_iov_pin_rsp(work, rsp, offsetof(struct smb2_write_rsp, Buffer));
+	if (err)
+		goto out;
 	ksmbd_fd_put(work, fp);
 	return 0;
 
@@ -6651,15 +7324,11 @@ int smb2_flush(struct ksmbd_work *work)
 
 	rsp->StructureSize = cpu_to_le16(4);
 	rsp->Reserved = 0;
-	inc_rfc1001_len(work->response_buf, 4);
-	return 0;
+	return ksmbd_iov_pin_rsp(work, rsp, sizeof(struct smb2_flush_rsp));
 
 out:
-	if (err) {
-		rsp->hdr.Status = STATUS_INVALID_HANDLE;
-		smb2_set_err_rsp(work);
-	}
-
+	rsp->hdr.Status = STATUS_INVALID_HANDLE;
+	smb2_set_err_rsp(work);
 	return err;
 }
 
@@ -6677,6 +7346,9 @@ int smb2_cancel(struct ksmbd_work *work)
 	struct ksmbd_work *iter;
 	struct list_head *command_list;
 
+	if (work->next_smb2_rcv_hdr_off)
+		hdr = ksmbd_resp_buf_next(work);
+
 	ksmbd_debug(SMB, "smb2 cancel called on mid %llu, async flags 0x%x\n",
 		    hdr->MessageId, hdr->Flags);
 
@@ -6836,8 +7508,8 @@ static inline bool lock_defer_pending(struct file_lock *fl)
  */
 int smb2_lock(struct ksmbd_work *work)
 {
-	struct smb2_lock_req *req = smb2_get_msg(work->request_buf);
-	struct smb2_lock_rsp *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_lock_req *req;
+	struct smb2_lock_rsp *rsp;
 	struct smb2_lock_element *lock_ele;
 	struct ksmbd_file *fp = NULL;
 	struct file_lock *flock = NULL;
@@ -6854,6 +7526,8 @@ int smb2_lock(struct ksmbd_work *work)
 	LIST_HEAD(rollback_list);
 	int prior_lock = 0;
 
+	WORK_BUFFERS(work, req, rsp);
+
 	ksmbd_debug(SMB, "Received lock request\n");
 	fp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId);
 	if (!fp) {
@@ -7059,10 +7733,6 @@ int smb2_lock(struct ksmbd_work *work)
 
 				ksmbd_debug(SMB,
 					    "would have to wait for getting lock\n");
-				spin_lock(&work->conn->llist_lock);
-				list_add_tail(&smb_lock->clist,
-					      &work->conn->lock_list);
-				spin_unlock(&work->conn->llist_lock);
 				list_add(&smb_lock->llist, &rollback_list);
 
 				argv = kmalloc(sizeof(void *), GFP_KERNEL);
@@ -7087,19 +7757,12 @@ int smb2_lock(struct ksmbd_work *work)
 
 				ksmbd_vfs_posix_lock_wait(flock);
 
-				spin_lock(&work->conn->request_lock);
 				spin_lock(&fp->f_lock);
 				list_del(&work->fp_entry);
-				work->cancel_fn = NULL;
-				kfree(argv);
 				spin_unlock(&fp->f_lock);
-				spin_unlock(&work->conn->request_lock);
 
 				if (work->state != KSMBD_WORK_ACTIVE) {
 					list_del(&smb_lock->llist);
-					spin_lock(&work->conn->llist_lock);
-					list_del(&smb_lock->clist);
-					spin_unlock(&work->conn->llist_lock);
 					locks_free_lock(flock);
 
 					if (work->state == KSMBD_WORK_CANCELLED) {
@@ -7111,8 +7774,7 @@ int smb2_lock(struct ksmbd_work *work)
 						work->send_no_response = 1;
 						goto out;
 					}
-					init_smb2_rsp_hdr(work);
-					smb2_set_err_rsp(work);
+
 					rsp->hdr.Status =
 						STATUS_RANGE_NOT_LOCKED;
 					kfree(smb_lock);
@@ -7120,19 +7782,16 @@ int smb2_lock(struct ksmbd_work *work)
 				}
 
 				list_del(&smb_lock->llist);
-				spin_lock(&work->conn->llist_lock);
-				list_del(&smb_lock->clist);
-				spin_unlock(&work->conn->llist_lock);
-
+				release_async_work(work);
 				goto retry;
 			} else if (!rc) {
+				list_add(&smb_lock->llist, &rollback_list);
 				spin_lock(&work->conn->llist_lock);
 				list_add_tail(&smb_lock->clist,
 					      &work->conn->lock_list);
 				list_add_tail(&smb_lock->flist,
 					      &fp->lock_list);
 				spin_unlock(&work->conn->llist_lock);
-				list_add(&smb_lock->llist, &rollback_list);
 				ksmbd_debug(SMB, "successful in taking lock\n");
 			} else {
 				goto out;
@@ -7147,7 +7806,10 @@ int smb2_lock(struct ksmbd_work *work)
 	ksmbd_debug(SMB, "successful in taking lock\n");
 	rsp->hdr.Status = STATUS_SUCCESS;
 	rsp->Reserved = 0;
-	inc_rfc1001_len(work->response_buf, 4);
+	err = ksmbd_iov_pin_rsp(work, rsp, sizeof(struct smb2_lock_rsp));
+	if (err)
+		goto out;
+
 	ksmbd_fd_put(work, fp);
 	return 0;
 
@@ -7561,34 +8223,34 @@ static inline int fsctl_set_sparse(struct ksmbd_work *work, u64 id,
 				   struct file_sparse *sparse)
 {
 	struct ksmbd_file *fp;
-	struct user_namespace *user_ns;
 	int ret = 0;
 	__le32 old_fattr;
 
 	fp = ksmbd_lookup_fd_fast(work, id);
 	if (!fp)
 		return -ENOENT;
-	user_ns = file_mnt_user_ns(fp->filp);
 
 	old_fattr = fp->f_ci->m_fattr;
 	if (sparse->SetSparse)
-		fp->f_ci->m_fattr |= FILE_ATTRIBUTE_SPARSE_FILE_LE;
+		fp->f_ci->m_fattr |= ATTR_SPARSE_FILE_LE;
 	else
-		fp->f_ci->m_fattr &= ~FILE_ATTRIBUTE_SPARSE_FILE_LE;
+		fp->f_ci->m_fattr &= ~ATTR_SPARSE_FILE_LE;
 
 	if (fp->f_ci->m_fattr != old_fattr &&
 	    test_share_config_flag(work->tcon->share_conf,
 				   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
 		struct xattr_dos_attrib da;
 
-		ret = ksmbd_vfs_get_dos_attrib_xattr(user_ns,
-						     fp->filp->f_path.dentry, &da);
+		ret = compat_ksmbd_vfs_get_dos_attrib_xattr(&fp->filp->f_path,
+							    fp->filp->f_path.dentry,
+							    &da);
 		if (ret <= 0)
 			goto out;
 
 		da.attr = le32_to_cpu(fp->f_ci->m_fattr);
-		ret = ksmbd_vfs_set_dos_attrib_xattr(user_ns,
-						     fp->filp->f_path.dentry, &da);
+		ret = compat_ksmbd_vfs_set_dos_attrib_xattr(&fp->filp->f_path,
+							    &da,
+							    true);
 		if (ret)
 			fp->f_ci->m_fattr = old_fattr;
 	}
@@ -7652,7 +8314,7 @@ int smb2_ioctl(struct ksmbd_work *work)
 		goto out;
 	}
 
-	cnt_code = le32_to_cpu(req->CtlCode);
+	cnt_code = le32_to_cpu(req->CntCode);
 	ret = smb2_calc_max_out_buf_len(work, 48,
 					le32_to_cpu(req->MaxOutputResponse));
 	if (ret < 0) {
@@ -7763,7 +8425,7 @@ int smb2_ioctl(struct ksmbd_work *work)
 		rsp->PersistentFileId = req->PersistentFileId;
 		fsctl_copychunk(work,
 				(struct copychunk_ioctl_req *)&req->Buffer[0],
-				le32_to_cpu(req->CtlCode),
+				le32_to_cpu(req->CntCode),
 				le32_to_cpu(req->InputCount),
 				req->VolatileFileId,
 				req->PersistentFileId,
@@ -7934,7 +8596,7 @@ int smb2_ioctl(struct ksmbd_work *work)
 		goto out;
 	}
 
-	rsp->CtlCode = cpu_to_le32(cnt_code);
+	rsp->CntCode = cpu_to_le32(cnt_code);
 	rsp->InputCount = cpu_to_le32(0);
 	rsp->InputOffset = cpu_to_le32(112);
 	rsp->OutputOffset = cpu_to_le32(112);
@@ -7943,9 +8605,9 @@ int smb2_ioctl(struct ksmbd_work *work)
 	rsp->Reserved = cpu_to_le16(0);
 	rsp->Flags = cpu_to_le32(0);
 	rsp->Reserved2 = cpu_to_le32(0);
-	inc_rfc1001_len(work->response_buf, 48 + nbytes);
-
-	return 0;
+	ret = ksmbd_iov_pin_rsp(work, rsp, sizeof(struct smb2_ioctl_rsp) + nbytes);
+	if (!ret)
+		return ret;
 
 out:
 	if (ret == -EACCES)
@@ -7970,8 +8632,8 @@ int smb2_ioctl(struct ksmbd_work *work)
  */
 static void smb20_oplock_break_ack(struct ksmbd_work *work)
 {
-	struct smb2_oplock_break *req = smb2_get_msg(work->request_buf);
-	struct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_oplock_break *req;
+	struct smb2_oplock_break *rsp;
 	struct ksmbd_file *fp;
 	struct oplock_info *opinfo = NULL;
 	__le32 err = 0;
@@ -7980,6 +8642,8 @@ static void smb20_oplock_break_ack(struct ksmbd_work *work)
 	char req_oplevel = 0, rsp_oplevel = 0;
 	unsigned int oplock_change_type;
 
+	WORK_BUFFERS(work, req, rsp);
+
 	volatile_id = req->VolatileFid;
 	persistent_id = req->PersistentFid;
 	req_oplevel = req->OplockLevel;
@@ -8067,10 +8731,10 @@ static void smb20_oplock_break_ack(struct ksmbd_work *work)
 		goto err_out;
 	}
 
-	opinfo_put(opinfo);
-	ksmbd_fd_put(work, fp);
 	opinfo->op_state = OPLOCK_STATE_NONE;
 	wake_up_interruptible_all(&opinfo->oplock_q);
+	opinfo_put(opinfo);
+	ksmbd_fd_put(work, fp);
 
 	rsp->StructureSize = cpu_to_le16(24);
 	rsp->OplockLevel = rsp_oplevel;
@@ -8078,8 +8742,9 @@ static void smb20_oplock_break_ack(struct ksmbd_work *work)
 	rsp->Reserved2 = 0;
 	rsp->VolatileFid = volatile_id;
 	rsp->PersistentFid = persistent_id;
-	inc_rfc1001_len(work->response_buf, 24);
-	return;
+	ret = ksmbd_iov_pin_rsp(work, rsp, sizeof(struct smb2_oplock_break));
+	if (!ret)
+		return;
 
 err_out:
 	opinfo->op_state = OPLOCK_STATE_NONE;
@@ -8114,8 +8779,8 @@ static int check_lease_state(struct lease *lease, __le32 req_state)
 static void smb21_lease_break_ack(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
-	struct smb2_lease_ack *req = smb2_get_msg(work->request_buf);
-	struct smb2_lease_ack *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_lease_ack *req;
+	struct smb2_lease_ack *rsp;
 	struct oplock_info *opinfo;
 	__le32 err = 0;
 	int ret = 0;
@@ -8123,6 +8788,8 @@ static void smb21_lease_break_ack(struct ksmbd_work *work)
 	__le32 lease_state;
 	struct lease *lease;
 
+	WORK_BUFFERS(work, req, rsp);
+
 	ksmbd_debug(OPLOCK, "smb21 lease break, lease state(0x%x)\n",
 		    le32_to_cpu(req->LeaseState));
 	opinfo = lookup_lease_in_table(conn, req->LeaseKey);
@@ -8209,6 +8876,11 @@ static void smb21_lease_break_ack(struct ksmbd_work *work)
 			    le32_to_cpu(req->LeaseState));
 	}
 
+	if (ret < 0) {
+		rsp->hdr.Status = err;
+		goto err_out;
+	}
+
 	lease_state = lease->state;
 	opinfo->op_state = OPLOCK_STATE_NONE;
 	wake_up_interruptible_all(&opinfo->oplock_q);
@@ -8216,22 +8888,17 @@ static void smb21_lease_break_ack(struct ksmbd_work *work)
 	wake_up_interruptible_all(&opinfo->oplock_brk);
 	opinfo_put(opinfo);
 
-	if (ret < 0) {
-		rsp->hdr.Status = err;
-		goto err_out;
-	}
-
 	rsp->StructureSize = cpu_to_le16(36);
 	rsp->Reserved = 0;
 	rsp->Flags = 0;
 	memcpy(rsp->LeaseKey, req->LeaseKey, 16);
 	rsp->LeaseState = lease_state;
 	rsp->LeaseDuration = 0;
-	inc_rfc1001_len(work->response_buf, 36);
-	return;
+	ret = ksmbd_iov_pin_rsp(work, rsp, sizeof(struct smb2_lease_ack));
+	if (!ret)
+		return;
 
 err_out:
-	opinfo->op_state = OPLOCK_STATE_NONE;
 	wake_up_interruptible_all(&opinfo->oplock_q);
 	atomic_dec(&opinfo->breaking_cnt);
 	wake_up_interruptible_all(&opinfo->oplock_brk);
@@ -8248,8 +8915,10 @@ static void smb21_lease_break_ack(struct ksmbd_work *work)
  */
 int smb2_oplock_break(struct ksmbd_work *work)
 {
-	struct smb2_oplock_break *req = smb2_get_msg(work->request_buf);
-	struct smb2_oplock_break *rsp = smb2_get_msg(work->response_buf);
+	struct smb2_oplock_break *req;
+	struct smb2_oplock_break *rsp;
+
+	WORK_BUFFERS(work, req, rsp);
 
 	switch (le16_to_cpu(req->StructureSize)) {
 	case OP_BREAK_STRUCT_SIZE_20:
@@ -8276,8 +8945,8 @@ int smb2_oplock_break(struct ksmbd_work *work)
  */
 int smb2_notify(struct ksmbd_work *work)
 {
-	struct smb2_change_notify_req *req;
-	struct smb2_change_notify_rsp *rsp;
+	struct smb2_notify_req *req;
+	struct smb2_notify_rsp *rsp;
 
 	WORK_BUFFERS(work, req, rsp);
 
@@ -8364,43 +9033,19 @@ int smb2_check_sign_req(struct ksmbd_work *work)
 void smb2_set_sign_rsp(struct ksmbd_work *work)
 {
 	struct smb2_hdr *hdr;
-	struct smb2_hdr *req_hdr;
 	char signature[SMB2_HMACSHA256_SIZE];
-	struct kvec iov[2];
-	size_t len;
+	struct kvec *iov;
 	int n_vec = 1;
 
-	hdr = smb2_get_msg(work->response_buf);
-	if (work->next_smb2_rsp_hdr_off)
-		hdr = ksmbd_resp_buf_next(work);
-
-	req_hdr = ksmbd_req_buf_next(work);
-
-	if (!work->next_smb2_rsp_hdr_off) {
-		len = get_rfc1002_len(work->response_buf);
-		if (req_hdr->NextCommand)
-			len = ALIGN(len, 8);
-	} else {
-		len = get_rfc1002_len(work->response_buf) -
-			work->next_smb2_rsp_hdr_off;
-		len = ALIGN(len, 8);
-	}
-
-	if (req_hdr->NextCommand)
-		hdr->NextCommand = cpu_to_le32(len);
-
+	hdr = ksmbd_resp_buf_curr(work);
 	hdr->Flags |= SMB2_FLAGS_SIGNED;
 	memset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);
 
-	iov[0].iov_base = (char *)&hdr->ProtocolId;
-	iov[0].iov_len = len;
-
-	if (work->aux_payload_sz) {
-		iov[0].iov_len -= work->aux_payload_sz;
-
-		iov[1].iov_base = work->aux_payload_buf;
-		iov[1].iov_len = work->aux_payload_sz;
+	if (hdr->Command == SMB2_READ) {
+		iov = &work->iov[work->iov_idx - 1];
 		n_vec++;
+	} else {
+		iov = &work->iov[work->iov_idx];
 	}
 
 	if (!ksmbd_sign_smb2_pdu(work->conn, work->sess->sess_key, iov, n_vec,
@@ -8476,29 +9121,14 @@ int smb3_check_sign_req(struct ksmbd_work *work)
 void smb3_set_sign_rsp(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
-	struct smb2_hdr *req_hdr, *hdr;
+	struct smb2_hdr *hdr;
 	struct channel *chann;
 	char signature[SMB2_CMACAES_SIZE];
-	struct kvec iov[2];
+	struct kvec *iov;
 	int n_vec = 1;
-	size_t len;
 	char *signing_key;
 
-	hdr = smb2_get_msg(work->response_buf);
-	if (work->next_smb2_rsp_hdr_off)
-		hdr = ksmbd_resp_buf_next(work);
-
-	req_hdr = ksmbd_req_buf_next(work);
-
-	if (!work->next_smb2_rsp_hdr_off) {
-		len = get_rfc1002_len(work->response_buf);
-		if (req_hdr->NextCommand)
-			len = ALIGN(len, 8);
-	} else {
-		len = get_rfc1002_len(work->response_buf) -
-			work->next_smb2_rsp_hdr_off;
-		len = ALIGN(len, 8);
-	}
+	hdr = ksmbd_resp_buf_curr(work);
 
 	if (conn->binding == false &&
 	    le16_to_cpu(hdr->Command) == SMB2_SESSION_SETUP_HE) {
@@ -8514,21 +9144,18 @@ void smb3_set_sign_rsp(struct ksmbd_work *work)
 	if (!signing_key)
 		return;
 
-	if (req_hdr->NextCommand)
-		hdr->NextCommand = cpu_to_le32(len);
-
 	hdr->Flags |= SMB2_FLAGS_SIGNED;
 	memset(hdr->Signature, 0, SMB2_SIGNATURE_SIZE);
-	iov[0].iov_base = (char *)&hdr->ProtocolId;
-	iov[0].iov_len = len;
-	if (work->aux_payload_sz) {
-		iov[0].iov_len -= work->aux_payload_sz;
-		iov[1].iov_base = work->aux_payload_buf;
-		iov[1].iov_len = work->aux_payload_sz;
+
+	if (hdr->Command == SMB2_READ) {
+		iov = &work->iov[work->iov_idx - 1];
 		n_vec++;
+	} else {
+		iov = &work->iov[work->iov_idx];
 	}
 
-	if (!ksmbd_sign_smb3_pdu(conn, signing_key, iov, n_vec, signature))
+	if (!ksmbd_sign_smb3_pdu(conn, signing_key, iov, n_vec,
+				 signature))
 		memcpy(hdr->Signature, signature, SMB2_SIGNATURE_SIZE);
 }
 
@@ -8579,10 +9206,10 @@ static void fill_transform_hdr(void *tr_buf, char *old_buf, __le16 cipher_type)
 	struct smb2_hdr *hdr = smb2_get_msg(old_buf);
 	unsigned int orig_len = get_rfc1002_len(old_buf);
 
-	/* tr_buf must be cleared by the caller */
+	memset(tr_buf, 0, sizeof(struct smb2_transform_hdr) + 4);
 	tr_hdr->ProtocolId = SMB2_TRANSFORM_PROTO_NUM;
 	tr_hdr->OriginalMessageSize = cpu_to_le32(orig_len);
-	tr_hdr->Flags = cpu_to_le16(TRANSFORM_FLAG_ENCRYPTED);
+	tr_hdr->Flags = cpu_to_le16(0x01);
 	if (cipher_type == SMB2_ENCRYPTION_AES128_GCM ||
 	    cipher_type == SMB2_ENCRYPTION_AES256_GCM)
 		get_random_bytes(&tr_hdr->Nonce, SMB3_AES_GCM_NONCE);
@@ -8595,45 +9222,22 @@ static void fill_transform_hdr(void *tr_buf, char *old_buf, __le16 cipher_type)
 
 int smb3_encrypt_resp(struct ksmbd_work *work)
 {
-	char *buf = work->response_buf;
-	struct kvec iov[3];
+	struct kvec *iov = work->iov;
 	int rc = -ENOMEM;
-	int buf_size = 0, rq_nvec = 2 + (work->aux_payload_sz ? 1 : 0);
-
-	if (ARRAY_SIZE(iov) < rq_nvec)
-		return -ENOMEM;
+	void *tr_buf;
 
-	work->tr_buf = kzalloc(sizeof(struct smb2_transform_hdr) + 4, GFP_KERNEL);
-	if (!work->tr_buf)
+	tr_buf = kzalloc(sizeof(struct smb2_transform_hdr) + 4, GFP_KERNEL);
+	if (!tr_buf)
 		return rc;
 
 	/* fill transform header */
-	fill_transform_hdr(work->tr_buf, buf, work->conn->cipher_type);
+	fill_transform_hdr(tr_buf, work->response_buf, work->conn->cipher_type);
 
-	iov[0].iov_base = work->tr_buf;
+	iov[0].iov_base = tr_buf;
 	iov[0].iov_len = sizeof(struct smb2_transform_hdr) + 4;
-	buf_size += iov[0].iov_len - 4;
+	work->tr_buf = tr_buf;
 
-	iov[1].iov_base = buf + 4;
-	iov[1].iov_len = get_rfc1002_len(buf);
-	if (work->aux_payload_sz) {
-		iov[1].iov_len = work->resp_hdr_sz - 4;
-
-		iov[2].iov_base = work->aux_payload_buf;
-		iov[2].iov_len = work->aux_payload_sz;
-		buf_size += iov[2].iov_len;
-	}
-	buf_size += iov[1].iov_len;
-	work->resp_hdr_sz = iov[1].iov_len;
-
-	rc = ksmbd_crypt_message(work, iov, rq_nvec, 1);
-	if (rc)
-		return rc;
-
-	memmove(buf, iov[1].iov_base, iov[1].iov_len);
-	*(__be32 *)work->tr_buf = cpu_to_be32(buf_size);
-
-	return rc;
+	return ksmbd_crypt_message(work, iov, work->iov_idx + 1, 1);
 }
 
 bool smb3_is_transform_hdr(void *buf)
@@ -8653,7 +9257,8 @@ int smb3_decrypt_req(struct ksmbd_work *work)
 	struct smb2_transform_hdr *tr_hdr = smb2_get_msg(buf);
 	int rc = 0;
 
-	if (buf_data_size < sizeof(struct smb2_hdr)) {
+	if (pdu_length < sizeof(struct smb2_transform_hdr) ||
+	    buf_data_size < sizeof(struct smb2_hdr)) {
 		pr_err("Transform message is too small (%u)\n",
 		       pdu_length);
 		return -ECONNABORTED;
diff --git a/fs/ksmbd/smb2pdu.h b/fs/ksmbd/smb2pdu.h
index df05c9b2504d..b8aac10af67c 100644
--- a/fs/ksmbd/smb2pdu.h
+++ b/fs/ksmbd/smb2pdu.h
@@ -10,24 +10,176 @@
 #include "ntlmssp.h"
 #include "smbacl.h"
 
+/*
+ * Note that, due to trying to use names similar to the protocol specifications,
+ * there are many mixed case field names in the structures below.  Although
+ * this does not match typical Linux kernel style, it is necessary to be
+ * able to match against the protocol specfication.
+ *
+ * SMB2 commands
+ * Some commands have minimal (wct=0,bcc=0), or uninteresting, responses
+ * (ie no useful data other than the SMB error code itself) and are marked such.
+ * Knowing this helps avoid response buffer allocations and copy in some cases.
+ */
+
+/* List of commands in host endian */
+#define SMB2_NEGOTIATE_HE	0x0000
+#define SMB2_SESSION_SETUP_HE	0x0001
+#define SMB2_LOGOFF_HE		0x0002 /* trivial request/resp */
+#define SMB2_TREE_CONNECT_HE	0x0003
+#define SMB2_TREE_DISCONNECT_HE	0x0004 /* trivial req/resp */
+#define SMB2_CREATE_HE		0x0005
+#define SMB2_CLOSE_HE		0x0006
+#define SMB2_FLUSH_HE		0x0007 /* trivial resp */
+#define SMB2_READ_HE		0x0008
+#define SMB2_WRITE_HE		0x0009
+#define SMB2_LOCK_HE		0x000A
+#define SMB2_IOCTL_HE		0x000B
+#define SMB2_CANCEL_HE		0x000C
+#define SMB2_ECHO_HE		0x000D
+#define SMB2_QUERY_DIRECTORY_HE	0x000E
+#define SMB2_CHANGE_NOTIFY_HE	0x000F
+#define SMB2_QUERY_INFO_HE	0x0010
+#define SMB2_SET_INFO_HE	0x0011
+#define SMB2_OPLOCK_BREAK_HE	0x0012
+
+/* The same list in little endian */
+#define SMB2_NEGOTIATE		cpu_to_le16(SMB2_NEGOTIATE_HE)
+#define SMB2_SESSION_SETUP	cpu_to_le16(SMB2_SESSION_SETUP_HE)
+#define SMB2_LOGOFF		cpu_to_le16(SMB2_LOGOFF_HE)
+#define SMB2_TREE_CONNECT	cpu_to_le16(SMB2_TREE_CONNECT_HE)
+#define SMB2_TREE_DISCONNECT	cpu_to_le16(SMB2_TREE_DISCONNECT_HE)
+#define SMB2_CREATE		cpu_to_le16(SMB2_CREATE_HE)
+#define SMB2_CLOSE		cpu_to_le16(SMB2_CLOSE_HE)
+#define SMB2_FLUSH		cpu_to_le16(SMB2_FLUSH_HE)
+#define SMB2_READ		cpu_to_le16(SMB2_READ_HE)
+#define SMB2_WRITE		cpu_to_le16(SMB2_WRITE_HE)
+#define SMB2_LOCK		cpu_to_le16(SMB2_LOCK_HE)
+#define SMB2_IOCTL		cpu_to_le16(SMB2_IOCTL_HE)
+#define SMB2_CANCEL		cpu_to_le16(SMB2_CANCEL_HE)
+#define SMB2_ECHO		cpu_to_le16(SMB2_ECHO_HE)
+#define SMB2_QUERY_DIRECTORY	cpu_to_le16(SMB2_QUERY_DIRECTORY_HE)
+#define SMB2_CHANGE_NOTIFY	cpu_to_le16(SMB2_CHANGE_NOTIFY_HE)
+#define SMB2_QUERY_INFO		cpu_to_le16(SMB2_QUERY_INFO_HE)
+#define SMB2_SET_INFO		cpu_to_le16(SMB2_SET_INFO_HE)
+#define SMB2_OPLOCK_BREAK	cpu_to_le16(SMB2_OPLOCK_BREAK_HE)
+
 /*Create Action Flags*/
 #define FILE_SUPERSEDED                0x00000000
 #define FILE_OPENED            0x00000001
 #define FILE_CREATED           0x00000002
 #define FILE_OVERWRITTEN       0x00000003
 
+/*
+ * Size of the session key (crypto key encrypted with the password
+ */
+#define SMB2_NTLMV2_SESSKEY_SIZE	16
+#define SMB2_SIGNATURE_SIZE		16
+#define SMB2_HMACSHA256_SIZE		32
+#define SMB2_CMACAES_SIZE		16
+#define SMB3_GCM128_CRYPTKEY_SIZE	16
+#define SMB3_GCM256_CRYPTKEY_SIZE	32
+
+/*
+ * Size of the smb3 encryption/decryption keys
+ */
+#define SMB3_ENC_DEC_KEY_SIZE		32
+
+/*
+ * Size of the smb3 signing key
+ */
+#define SMB3_SIGN_KEY_SIZE		16
+
+#define CIFS_CLIENT_CHALLENGE_SIZE	8
+#define SMB_SERVER_CHALLENGE_SIZE	8
+
 /* SMB2 Max Credits */
 #define SMB2_MAX_CREDITS		8192
 
+#define SMB2_CLIENT_GUID_SIZE		16
+#define SMB2_CREATE_GUID_SIZE		16
+
+/* Maximum buffer size value we can send with 1 credit */
+#define SMB2_MAX_BUFFER_SIZE 65536
+
+#define NUMBER_OF_SMB2_COMMANDS	0x0013
+
 /* BB FIXME - analyze following length BB */
 #define MAX_SMB2_HDR_SIZE 0x78 /* 4 len + 64 hdr + (2*24 wct) + 2 bct + 2 pad */
 
+#define SMB2_PROTO_NUMBER cpu_to_le32(0x424d53fe) /* 'B''M''S' */
+#define SMB2_TRANSFORM_PROTO_NUM cpu_to_le32(0x424d53fd)
+#define SMB2_COMPRESSION_TRANSFORM_ID cpu_to_le32(0x424d53fc)
+
 #define SMB21_DEFAULT_IOSIZE	(1024 * 1024)
+#define SMB3_DEFAULT_IOSIZE	(4 * 1024 * 1024)
 #define SMB3_DEFAULT_TRANS_SIZE	(1024 * 1024)
 #define SMB3_MIN_IOSIZE		(64 * 1024)
 #define SMB3_MAX_IOSIZE		(8 * 1024 * 1024)
 #define SMB3_MAX_MSGSIZE	(4 * 4096)
 
+/*
+ * SMB2 Header Definition
+ *
+ * "MBZ" :  Must be Zero
+ * "BB"  :  BugBug, Something to check/review/analyze later
+ * "PDU" :  "Protocol Data Unit" (ie a network "frame")
+ *
+ */
+
+#define __SMB2_HEADER_STRUCTURE_SIZE	64
+#define SMB2_HEADER_STRUCTURE_SIZE				\
+	cpu_to_le16(__SMB2_HEADER_STRUCTURE_SIZE)
+
+struct smb2_hdr {
+	__le32 ProtocolId;	/* 0xFE 'S' 'M' 'B' */
+	__le16 StructureSize;	/* 64 */
+	__le16 CreditCharge;	/* MBZ */
+	__le32 Status;		/* Error from server */
+	__le16 Command;
+	__le16 CreditRequest;	/* CreditResponse */
+	__le32 Flags;
+	__le32 NextCommand;
+	__le64 MessageId;
+	union {
+		struct {
+			__le32 ProcessId;
+			__le32  TreeId;
+		} __packed SyncId;
+		__le64  AsyncId;
+	} __packed Id;
+	__le64  SessionId;
+	__u8   Signature[16];
+} __packed;
+
+struct smb2_pdu {
+	struct smb2_hdr hdr;
+	__le16 StructureSize2; /* size of wct area (varies, request specific) */
+} __packed;
+
+#define SMB3_AES_CCM_NONCE 11
+#define SMB3_AES_GCM_NONCE 12
+
+struct smb2_transform_hdr {
+	__le32 ProtocolId;      /* 0xFD 'S' 'M' 'B' */
+	__u8   Signature[16];
+	__u8   Nonce[16];
+	__le32 OriginalMessageSize;
+	__u16  Reserved1;
+	__le16 Flags; /* EncryptionAlgorithm */
+	__le64  SessionId;
+} __packed;
+
+/*
+ *	SMB2 flag definitions
+ */
+#define SMB2_FLAGS_SERVER_TO_REDIR	cpu_to_le32(0x00000001)
+#define SMB2_FLAGS_ASYNC_COMMAND	cpu_to_le32(0x00000002)
+#define SMB2_FLAGS_RELATED_OPERATIONS	cpu_to_le32(0x00000004)
+#define SMB2_FLAGS_SIGNED		cpu_to_le32(0x00000008)
+#define SMB2_FLAGS_DFS_OPERATIONS	cpu_to_le32(0x10000000)
+#define SMB2_FLAGS_REPLAY_OPERATIONS	cpu_to_le32(0x20000000)
+
 /*
  *	Definitions for SMB2 Protocol Data Units (network frames)
  *
@@ -37,11 +189,60 @@
  *
  */
 
+#define SMB2_ERROR_STRUCTURE_SIZE2	9
+#define SMB2_ERROR_STRUCTURE_SIZE2_LE	cpu_to_le16(SMB2_ERROR_STRUCTURE_SIZE2)
+
+struct smb2_err_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;
+	__u8   ErrorContextCount;
+	__u8   Reserved;
+	__le32 ByteCount;  /* even if zero, at least one byte follows */
+	__u8   ErrorData[1];  /* variable length */
+} __packed;
+
+struct smb2_negotiate_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 36 */
+	__le16 DialectCount;
+	__le16 SecurityMode;
+	__le16 Reserved;	/* MBZ */
+	__le32 Capabilities;
+	__u8   ClientGUID[SMB2_CLIENT_GUID_SIZE];
+	/* In SMB3.02 and earlier next three were MBZ le64 ClientStartTime */
+	__le32 NegotiateContextOffset; /* SMB3.1.1 only. MBZ earlier */
+	__le16 NegotiateContextCount;  /* SMB3.1.1 only. MBZ earlier */
+	__le16 Reserved2;
+	__le16 Dialects[]; /* One dialect (vers=) at a time for now */
+} __packed;
+
+/* SecurityMode flags */
+#define SMB2_NEGOTIATE_SIGNING_ENABLED_LE	cpu_to_le16(0x0001)
+#define SMB2_NEGOTIATE_SIGNING_REQUIRED		0x0002
+#define SMB2_NEGOTIATE_SIGNING_REQUIRED_LE	cpu_to_le16(0x0002)
+/* Capabilities flags */
+#define SMB2_GLOBAL_CAP_DFS		0x00000001
+#define SMB2_GLOBAL_CAP_LEASING		0x00000002 /* Resp only New to SMB2.1 */
+#define SMB2_GLOBAL_CAP_LARGE_MTU	0X00000004 /* Resp only New to SMB2.1 */
+#define SMB2_GLOBAL_CAP_MULTI_CHANNEL	0x00000008 /* New to SMB3 */
+#define SMB2_GLOBAL_CAP_PERSISTENT_HANDLES 0x00000010 /* New to SMB3 */
+#define SMB2_GLOBAL_CAP_DIRECTORY_LEASING  0x00000020 /* New to SMB3 */
+#define SMB2_GLOBAL_CAP_ENCRYPTION	0x00000040 /* New to SMB3 */
+/* Internal types */
+#define SMB2_NT_FIND			0x00100000
+#define SMB2_LARGE_FILES		0x00200000
+
+#define SMB311_SALT_SIZE			32
+/* Hash Algorithm Types */
+#define SMB2_PREAUTH_INTEGRITY_SHA512	cpu_to_le16(0x0001)
+
+#define PREAUTH_HASHVALUE_SIZE		64
+
 struct preauth_integrity_info {
 	/* PreAuth integrity Hash ID */
 	__le16			Preauth_HashId;
 	/* PreAuth integrity Hash Value */
-	__u8			Preauth_HashValue[SMB2_PREAUTH_HASH_SIZE];
+	__u8			Preauth_HashValue[PREAUTH_HASHVALUE_SIZE];
 };
 
 /* offset is sizeof smb2_negotiate_rsp but rounded up to 8 bytes. */
@@ -57,12 +258,379 @@ struct preauth_integrity_info {
 #define OFFSET_OF_NEG_CONTEXT	0xd0
 #endif
 
+#define SMB2_PREAUTH_INTEGRITY_CAPABILITIES	cpu_to_le16(1)
+#define SMB2_ENCRYPTION_CAPABILITIES		cpu_to_le16(2)
+#define SMB2_COMPRESSION_CAPABILITIES		cpu_to_le16(3)
+#define SMB2_NETNAME_NEGOTIATE_CONTEXT_ID	cpu_to_le16(5)
+#define SMB2_SIGNING_CAPABILITIES		cpu_to_le16(8)
+#define SMB2_POSIX_EXTENSIONS_AVAILABLE		cpu_to_le16(0x100)
+
+struct smb2_neg_context {
+	__le16  ContextType;
+	__le16  DataLength;
+	__le32  Reserved;
+	/* Followed by array of data */
+} __packed;
+
+/*
+ * SaltLength that the server send can be zero, so the only three required
+ * fields (all __le16) end up six bytes total, so the minimum context data len
+ * in the response is six bytes which accounts for
+ *
+ *      HashAlgorithmCount, SaltLength, and 1 HashAlgorithm.
+ */
+#define MIN_PREAUTH_CTXT_DATA_LEN 6
+
+struct smb2_preauth_neg_context {
+	__le16	ContextType; /* 1 */
+	__le16	DataLength;
+	__le32	Reserved;
+	__le16	HashAlgorithmCount; /* 1 */
+	__le16	SaltLength;
+	__le16	HashAlgorithms; /* HashAlgorithms[0] since only one defined */
+	__u8	Salt[SMB311_SALT_SIZE];
+} __packed;
+
+/* Encryption Algorithms Ciphers */
+#define SMB2_ENCRYPTION_AES128_CCM	cpu_to_le16(0x0001)
+#define SMB2_ENCRYPTION_AES128_GCM	cpu_to_le16(0x0002)
+#define SMB2_ENCRYPTION_AES256_CCM	cpu_to_le16(0x0003)
+#define SMB2_ENCRYPTION_AES256_GCM	cpu_to_le16(0x0004)
+
+struct smb2_encryption_neg_context {
+	__le16	ContextType; /* 2 */
+	__le16	DataLength;
+	__le32	Reserved;
+	/* CipherCount usally 2, but can be 3 when AES256-GCM enabled */
+	__le16	CipherCount; /* AES-128-GCM and AES-128-CCM by default */
+	__le16	Ciphers[];
+} __packed;
+
+#define SMB3_COMPRESS_NONE	cpu_to_le16(0x0000)
+#define SMB3_COMPRESS_LZNT1	cpu_to_le16(0x0001)
+#define SMB3_COMPRESS_LZ77	cpu_to_le16(0x0002)
+#define SMB3_COMPRESS_LZ77_HUFF	cpu_to_le16(0x0003)
+
+struct smb2_compression_ctx {
+	__le16	ContextType; /* 3 */
+	__le16  DataLength;
+	__le32	Reserved;
+	__le16	CompressionAlgorithmCount;
+	__u16	Padding;
+	__le32	Reserved1;
+	__le16	CompressionAlgorithms[];
+} __packed;
+
+#define POSIX_CTXT_DATA_LEN     16
+struct smb2_posix_neg_context {
+	__le16	ContextType; /* 0x100 */
+	__le16	DataLength;
+	__le32	Reserved;
+	__u8	Name[16]; /* POSIX ctxt GUID 93AD25509CB411E7B42383DE968BCD7C */
+} __packed;
+
+struct smb2_netname_neg_context {
+	__le16	ContextType; /* 0x100 */
+	__le16	DataLength;
+	__le32	Reserved;
+	__le16	NetName[]; /* hostname of target converted to UCS-2 */
+} __packed;
+
+/* Signing algorithms */
+#define SIGNING_ALG_HMAC_SHA256		cpu_to_le16(0)
+#define SIGNING_ALG_AES_CMAC		cpu_to_le16(1)
+#define SIGNING_ALG_AES_GMAC		cpu_to_le16(2)
+
+struct smb2_signing_capabilities {
+	__le16	ContextType; /* 8 */
+	__le16	DataLength;
+	__le32	Reserved;
+	__le16	SigningAlgorithmCount;
+	__le16	SigningAlgorithms[];
+} __packed;
+
+struct smb2_negotiate_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 65 */
+	__le16 SecurityMode;
+	__le16 DialectRevision;
+	__le16 NegotiateContextCount; /* Prior to SMB3.1.1 was Reserved & MBZ */
+	__u8   ServerGUID[16];
+	__le32 Capabilities;
+	__le32 MaxTransactSize;
+	__le32 MaxReadSize;
+	__le32 MaxWriteSize;
+	__le64 SystemTime;	/* MBZ */
+	__le64 ServerStartTime;
+	__le16 SecurityBufferOffset;
+	__le16 SecurityBufferLength;
+	__le32 NegotiateContextOffset;	/* Pre:SMB3.1.1 was reserved/ignored */
+	__u8   Buffer[];	/* variable length GSS security buffer */
+} __packed;
+
+/* Flags */
+#define SMB2_SESSION_REQ_FLAG_BINDING		0x01
+#define SMB2_SESSION_REQ_FLAG_ENCRYPT_DATA	0x04
+
 #define SMB2_SESSION_EXPIRED		(0)
 #define SMB2_SESSION_IN_PROGRESS	BIT(0)
 #define SMB2_SESSION_VALID		BIT(1)
 
 #define SMB2_SESSION_TIMEOUT		(10 * HZ)
 
+/* Flags */
+#define SMB2_SESSION_REQ_FLAG_BINDING		0x01
+#define SMB2_SESSION_REQ_FLAG_ENCRYPT_DATA	0x04
+
+struct smb2_sess_setup_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 25 */
+	__u8   Flags;
+	__u8   SecurityMode;
+	__le32 Capabilities;
+	__le32 Channel;
+	__le16 SecurityBufferOffset;
+	__le16 SecurityBufferLength;
+	__le64 PreviousSessionId;
+	__u8   Buffer[1];	/* variable length GSS security buffer */
+} __packed;
+
+/* Flags/Reserved for SMB3.1.1 */
+#define SMB2_SHAREFLAG_CLUSTER_RECONNECT	0x0001
+
+/* Currently defined SessionFlags */
+#define SMB2_SESSION_FLAG_IS_GUEST_LE		cpu_to_le16(0x0001)
+#define SMB2_SESSION_FLAG_IS_NULL_LE		cpu_to_le16(0x0002)
+#define SMB2_SESSION_FLAG_ENCRYPT_DATA_LE	cpu_to_le16(0x0004)
+struct smb2_sess_setup_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 9 */
+	__le16 SessionFlags;
+	__le16 SecurityBufferOffset;
+	__le16 SecurityBufferLength;
+	__u8   Buffer[1];	/* variable length GSS security buffer */
+} __packed;
+
+struct smb2_logoff_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 4 */
+	__le16 Reserved;
+} __packed;
+
+struct smb2_logoff_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 4 */
+	__le16 Reserved;
+} __packed;
+
+struct smb2_tree_connect_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 9 */
+	__le16 Reserved;	/* Flags in SMB3.1.1 */
+	__le16 PathOffset;
+	__le16 PathLength;
+	__u8   Buffer[1];	/* variable length */
+} __packed;
+
+struct smb2_tree_connect_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 16 */
+	__u8   ShareType;  /* see below */
+	__u8   Reserved;
+	__le32 ShareFlags; /* see below */
+	__le32 Capabilities; /* see below */
+	__le32 MaximalAccess;
+} __packed;
+
+/* Possible ShareType values */
+#define SMB2_SHARE_TYPE_DISK	0x01
+#define SMB2_SHARE_TYPE_PIPE	0x02
+#define	SMB2_SHARE_TYPE_PRINT	0x03
+
+/*
+ * Possible ShareFlags - exactly one and only one of the first 4 caching flags
+ * must be set (any of the remaining, SHI1005, flags may be set individually
+ * or in combination.
+ */
+#define SMB2_SHAREFLAG_MANUAL_CACHING			0x00000000
+#define SMB2_SHAREFLAG_AUTO_CACHING			0x00000010
+#define SMB2_SHAREFLAG_VDO_CACHING			0x00000020
+#define SMB2_SHAREFLAG_NO_CACHING			0x00000030
+#define SHI1005_FLAGS_DFS				0x00000001
+#define SHI1005_FLAGS_DFS_ROOT				0x00000002
+#define SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS		0x00000100
+#define SHI1005_FLAGS_FORCE_SHARED_DELETE		0x00000200
+#define SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING		0x00000400
+#define SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM	0x00000800
+#define SHI1005_FLAGS_FORCE_LEVELII_OPLOCK		0x00001000
+#define SHI1005_FLAGS_ENABLE_HASH			0x00002000
+
+/* Possible share capabilities */
+#define SMB2_SHARE_CAP_DFS	cpu_to_le32(0x00000008)
+
+struct smb2_tree_disconnect_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 4 */
+	__le16 Reserved;
+} __packed;
+
+struct smb2_tree_disconnect_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 4 */
+	__le16 Reserved;
+} __packed;
+
+#define ATTR_READONLY_LE	cpu_to_le32(ATTR_READONLY)
+#define ATTR_HIDDEN_LE		cpu_to_le32(ATTR_HIDDEN)
+#define ATTR_SYSTEM_LE		cpu_to_le32(ATTR_SYSTEM)
+#define ATTR_DIRECTORY_LE	cpu_to_le32(ATTR_DIRECTORY)
+#define ATTR_ARCHIVE_LE		cpu_to_le32(ATTR_ARCHIVE)
+#define ATTR_NORMAL_LE		cpu_to_le32(ATTR_NORMAL)
+#define ATTR_TEMPORARY_LE	cpu_to_le32(ATTR_TEMPORARY)
+#define ATTR_SPARSE_FILE_LE	cpu_to_le32(ATTR_SPARSE)
+#define ATTR_REPARSE_POINT_LE	cpu_to_le32(ATTR_REPARSE)
+#define ATTR_COMPRESSED_LE	cpu_to_le32(ATTR_COMPRESSED)
+#define ATTR_OFFLINE_LE		cpu_to_le32(ATTR_OFFLINE)
+#define ATTR_NOT_CONTENT_INDEXED_LE	cpu_to_le32(ATTR_NOT_CONTENT_INDEXED)
+#define ATTR_ENCRYPTED_LE	cpu_to_le32(ATTR_ENCRYPTED)
+#define ATTR_INTEGRITY_STREAML_LE	cpu_to_le32(0x00008000)
+#define ATTR_NO_SCRUB_DATA_LE	cpu_to_le32(0x00020000)
+#define ATTR_MASK_LE		cpu_to_le32(0x00007FB7)
+
+/* Oplock levels */
+#define SMB2_OPLOCK_LEVEL_NONE		0x00
+#define SMB2_OPLOCK_LEVEL_II		0x01
+#define SMB2_OPLOCK_LEVEL_EXCLUSIVE	0x08
+#define SMB2_OPLOCK_LEVEL_BATCH		0x09
+#define SMB2_OPLOCK_LEVEL_LEASE		0xFF
+/* Non-spec internal type */
+#define SMB2_OPLOCK_LEVEL_NOCHANGE	0x99
+
+/* Desired Access Flags */
+#define FILE_READ_DATA_LE		cpu_to_le32(0x00000001)
+#define FILE_LIST_DIRECTORY_LE		cpu_to_le32(0x00000001)
+#define FILE_WRITE_DATA_LE		cpu_to_le32(0x00000002)
+#define FILE_ADD_FILE_LE		cpu_to_le32(0x00000002)
+#define FILE_APPEND_DATA_LE		cpu_to_le32(0x00000004)
+#define FILE_ADD_SUBDIRECTORY_LE	cpu_to_le32(0x00000004)
+#define FILE_READ_EA_LE			cpu_to_le32(0x00000008)
+#define FILE_WRITE_EA_LE		cpu_to_le32(0x00000010)
+#define FILE_EXECUTE_LE			cpu_to_le32(0x00000020)
+#define FILE_TRAVERSE_LE		cpu_to_le32(0x00000020)
+#define FILE_DELETE_CHILD_LE		cpu_to_le32(0x00000040)
+#define FILE_READ_ATTRIBUTES_LE		cpu_to_le32(0x00000080)
+#define FILE_WRITE_ATTRIBUTES_LE	cpu_to_le32(0x00000100)
+#define FILE_DELETE_LE			cpu_to_le32(0x00010000)
+#define FILE_READ_CONTROL_LE		cpu_to_le32(0x00020000)
+#define FILE_WRITE_DAC_LE		cpu_to_le32(0x00040000)
+#define FILE_WRITE_OWNER_LE		cpu_to_le32(0x00080000)
+#define FILE_SYNCHRONIZE_LE		cpu_to_le32(0x00100000)
+#define FILE_ACCESS_SYSTEM_SECURITY_LE	cpu_to_le32(0x01000000)
+#define FILE_MAXIMAL_ACCESS_LE		cpu_to_le32(0x02000000)
+#define FILE_GENERIC_ALL_LE		cpu_to_le32(0x10000000)
+#define FILE_GENERIC_EXECUTE_LE		cpu_to_le32(0x20000000)
+#define FILE_GENERIC_WRITE_LE		cpu_to_le32(0x40000000)
+#define FILE_GENERIC_READ_LE		cpu_to_le32(0x80000000)
+#define DESIRED_ACCESS_MASK		cpu_to_le32(0xF21F01FF)
+
+/* ShareAccess Flags */
+#define FILE_SHARE_READ_LE		cpu_to_le32(0x00000001)
+#define FILE_SHARE_WRITE_LE		cpu_to_le32(0x00000002)
+#define FILE_SHARE_DELETE_LE		cpu_to_le32(0x00000004)
+#define FILE_SHARE_ALL_LE		cpu_to_le32(0x00000007)
+
+/* CreateDisposition Flags */
+#define FILE_SUPERSEDE_LE		cpu_to_le32(0x00000000)
+#define FILE_OPEN_LE			cpu_to_le32(0x00000001)
+#define FILE_CREATE_LE			cpu_to_le32(0x00000002)
+#define	FILE_OPEN_IF_LE			cpu_to_le32(0x00000003)
+#define FILE_OVERWRITE_LE		cpu_to_le32(0x00000004)
+#define FILE_OVERWRITE_IF_LE		cpu_to_le32(0x00000005)
+#define FILE_CREATE_MASK_LE		cpu_to_le32(0x00000007)
+
+#define FILE_READ_DESIRED_ACCESS_LE	(FILE_READ_DATA_LE |		\
+					FILE_READ_EA_LE |		\
+					FILE_GENERIC_READ_LE)
+#define FILE_WRITE_DESIRE_ACCESS_LE	(FILE_WRITE_DATA_LE |		\
+					FILE_APPEND_DATA_LE |		\
+					FILE_WRITE_EA_LE |		\
+					FILE_WRITE_ATTRIBUTES_LE |	\
+					FILE_GENERIC_WRITE_LE)
+
+/* Impersonation Levels */
+#define IL_ANONYMOUS_LE		cpu_to_le32(0x00000000)
+#define IL_IDENTIFICATION_LE	cpu_to_le32(0x00000001)
+#define IL_IMPERSONATION_LE	cpu_to_le32(0x00000002)
+#define IL_DELEGATE_LE		cpu_to_le32(0x00000003)
+
+/* Create Context Values */
+#define SMB2_CREATE_EA_BUFFER			"ExtA" /* extended attributes */
+#define SMB2_CREATE_SD_BUFFER			"SecD" /* security descriptor */
+#define SMB2_CREATE_DURABLE_HANDLE_REQUEST	"DHnQ"
+#define SMB2_CREATE_DURABLE_HANDLE_RECONNECT	"DHnC"
+#define SMB2_CREATE_ALLOCATION_SIZE		"AlSi"
+#define SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST "MxAc"
+#define SMB2_CREATE_TIMEWARP_REQUEST		"TWrp"
+#define SMB2_CREATE_QUERY_ON_DISK_ID		"QFid"
+#define SMB2_CREATE_REQUEST_LEASE		"RqLs"
+#define SMB2_CREATE_DURABLE_HANDLE_REQUEST_V2   "DH2Q"
+#define SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 "DH2C"
+#define SMB2_CREATE_APP_INSTANCE_ID     "\x45\xBC\xA6\x6A\xEF\xA7\xF7\x4A\x90\x08\xFA\x46\x2E\x14\x4D\x74"
+ #define SMB2_CREATE_APP_INSTANCE_VERSION	"\xB9\x82\xD0\xB7\x3B\x56\x07\x4F\xA0\x7B\x52\x4A\x81\x16\xA0\x10"
+#define SVHDX_OPEN_DEVICE_CONTEXT       0x83CE6F1AD851E0986E34401CC9BCFCE9
+#define SMB2_CREATE_TAG_POSIX		"\x93\xAD\x25\x50\x9C\xB4\x11\xE7\xB4\x23\x83\xDE\x96\x8B\xCD\x7C"
+
+struct smb2_create_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 57 */
+	__u8   SecurityFlags;
+	__u8   RequestedOplockLevel;
+	__le32 ImpersonationLevel;
+	__le64 SmbCreateFlags;
+	__le64 Reserved;
+	__le32 DesiredAccess;
+	__le32 FileAttributes;
+	__le32 ShareAccess;
+	__le32 CreateDisposition;
+	__le32 CreateOptions;
+	__le16 NameOffset;
+	__le16 NameLength;
+	__le32 CreateContextsOffset;
+	__le32 CreateContextsLength;
+	__u8   Buffer[0];
+} __packed;
+
+struct smb2_create_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 89 */
+	__u8   OplockLevel;
+	__u8   Reserved;
+	__le32 CreateAction;
+	__le64 CreationTime;
+	__le64 LastAccessTime;
+	__le64 LastWriteTime;
+	__le64 ChangeTime;
+	__le64 AllocationSize;
+	__le64 EndofFile;
+	__le32 FileAttributes;
+	__le32 Reserved2;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+	__le32 CreateContextsOffset;
+	__le32 CreateContextsLength;
+	__u8   Buffer[1];
+} __packed;
+
+struct create_context {
+	__le32 Next;
+	__le16 NameOffset;
+	__le16 NameLength;
+	__le16 Reserved;
+	__le16 DataOffset;
+	__le32 DataLength;
+	__u8 Buffer[0];
+} __packed;
+
 struct create_durable_req_v2 {
 	struct create_context ccontext;
 	__u8   Name[8];
@@ -123,6 +691,13 @@ struct create_alloc_size_req {
 	__le64 AllocationSize;
 } __packed;
 
+struct create_posix {
+	struct create_context ccontext;
+	__u8    Name[16];
+	__le32  Mode;
+	__u32   Reserved;
+} __packed;
+
 struct create_durable_rsp {
 	struct create_context ccontext;
 	__u8   Name[8];
@@ -165,14 +740,213 @@ struct create_posix_rsp {
 	u8 SidBuffer[44];
 } __packed;
 
+#define SMB2_LEASE_NONE_LE			cpu_to_le32(0x00)
+#define SMB2_LEASE_READ_CACHING_LE		cpu_to_le32(0x01)
+#define SMB2_LEASE_HANDLE_CACHING_LE		cpu_to_le32(0x02)
+#define SMB2_LEASE_WRITE_CACHING_LE		cpu_to_le32(0x04)
+
+#define SMB2_LEASE_FLAG_BREAK_IN_PROGRESS_LE	cpu_to_le32(0x02)
+#define SMB2_LEASE_FLAG_PARENT_LEASE_KEY_SET_LE	cpu_to_le32(0x04)
+
+#define SMB2_LEASE_KEY_SIZE			16
+
+struct lease_context {
+	__u8 LeaseKey[SMB2_LEASE_KEY_SIZE];
+	__le32 LeaseState;
+	__le32 LeaseFlags;
+	__le64 LeaseDuration;
+} __packed;
+
+struct lease_context_v2 {
+	__u8 LeaseKey[SMB2_LEASE_KEY_SIZE];
+	__le32 LeaseState;
+	__le32 LeaseFlags;
+	__le64 LeaseDuration;
+	__u8 ParentLeaseKey[SMB2_LEASE_KEY_SIZE];
+	__le16 Epoch;
+	__le16 Reserved;
+} __packed;
+
+struct create_lease {
+	struct create_context ccontext;
+	__u8   Name[8];
+	struct lease_context lcontext;
+} __packed;
+
+struct create_lease_v2 {
+	struct create_context ccontext;
+	__u8   Name[8];
+	struct lease_context_v2 lcontext;
+	__u8   Pad[4];
+} __packed;
+
+/* Currently defined values for close flags */
+#define SMB2_CLOSE_FLAG_POSTQUERY_ATTRIB	cpu_to_le16(0x0001)
+struct smb2_close_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 24 */
+	__le16 Flags;
+	__le32 Reserved;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+} __packed;
+
+struct smb2_close_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* 60 */
+	__le16 Flags;
+	__le32 Reserved;
+	__le64 CreationTime;
+	__le64 LastAccessTime;
+	__le64 LastWriteTime;
+	__le64 ChangeTime;
+	__le64 AllocationSize;	/* Beginning of FILE_STANDARD_INFO equivalent */
+	__le64 EndOfFile;
+	__le32 Attributes;
+} __packed;
+
+struct smb2_flush_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 24 */
+	__le16 Reserved1;
+	__le32 Reserved2;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+} __packed;
+
+struct smb2_flush_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;
+	__le16 Reserved;
+} __packed;
+
 struct smb2_buffer_desc_v1 {
 	__le64 offset;
 	__le32 token;
 	__le32 length;
 } __packed;
 
+#define SMB2_CHANNEL_NONE		cpu_to_le32(0x00000000)
+#define SMB2_CHANNEL_RDMA_V1		cpu_to_le32(0x00000001)
+#define SMB2_CHANNEL_RDMA_V1_INVALIDATE cpu_to_le32(0x00000002)
+
+struct smb2_read_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 49 */
+	__u8   Padding; /* offset from start of SMB2 header to place read */
+	__u8   Reserved;
+	__le32 Length;
+	__le64 Offset;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+	__le32 MinimumCount;
+	__le32 Channel; /* Reserved MBZ */
+	__le32 RemainingBytes;
+	__le16 ReadChannelInfoOffset; /* Reserved MBZ */
+	__le16 ReadChannelInfoLength; /* Reserved MBZ */
+	__u8   Buffer[1];
+} __packed;
+
+struct smb2_read_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 17 */
+	__u8   DataOffset;
+	__u8   Reserved;
+	__le32 DataLength;
+	__le32 DataRemaining;
+	__u32  Reserved2;
+	__u8   Buffer[1];
+} __packed;
+
+/* For write request Flags field below the following flag is defined: */
+#define SMB2_WRITEFLAG_WRITE_THROUGH 0x00000001
+
+struct smb2_write_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 49 */
+	__le16 DataOffset; /* offset from start of SMB2 header to write data */
+	__le32 Length;
+	__le64 Offset;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+	__le32 Channel; /* Reserved MBZ */
+	__le32 RemainingBytes;
+	__le16 WriteChannelInfoOffset; /* Reserved MBZ */
+	__le16 WriteChannelInfoLength; /* Reserved MBZ */
+	__le32 Flags;
+	__u8   Buffer[1];
+} __packed;
+
+struct smb2_write_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 17 */
+	__u8   DataOffset;
+	__u8   Reserved;
+	__le32 DataLength;
+	__le32 DataRemaining;
+	__u32  Reserved2;
+	__u8   Buffer[1];
+} __packed;
+
 #define SMB2_0_IOCTL_IS_FSCTL 0x00000001
 
+struct duplicate_extents_to_file {
+	__u64 PersistentFileHandle; /* source file handle, opaque endianness */
+	__u64 VolatileFileHandle;
+	__le64 SourceFileOffset;
+	__le64 TargetFileOffset;
+	__le64 ByteCount;  /* Bytes to be copied */
+} __packed;
+
+struct smb2_ioctl_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 57 */
+	__le16 Reserved; /* offset from start of SMB2 header to write data */
+	__le32 CntCode;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+	__le32 InputOffset; /* Reserved MBZ */
+	__le32 InputCount;
+	__le32 MaxInputResponse;
+	__le32 OutputOffset;
+	__le32 OutputCount;
+	__le32 MaxOutputResponse;
+	__le32 Flags;
+	__le32 Reserved2;
+	__u8   Buffer[];
+} __packed;
+
+struct smb2_ioctl_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 49 */
+	__le16 Reserved; /* offset from start of SMB2 header to write data */
+	__le32 CntCode;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+	__le32 InputOffset; /* Reserved MBZ */
+	__le32 InputCount;
+	__le32 OutputOffset;
+	__le32 OutputCount;
+	__le32 Flags;
+	__le32 Reserved2;
+	__u8   Buffer[];
+} __packed;
+
+struct validate_negotiate_info_req {
+	__le32 Capabilities;
+	__u8   Guid[SMB2_CLIENT_GUID_SIZE];
+	__le16 SecurityMode;
+	__le16 DialectCount;
+	__le16 Dialects[1]; /* dialect (someday maybe list) client asked for */
+} __packed;
+
+struct validate_negotiate_info_rsp {
+	__le32 Capabilities;
+	__u8   Guid[SMB2_CLIENT_GUID_SIZE];
+	__le16 SecurityMode;
+	__le16 Dialect; /* Dialect in use for the connection */
+} __packed;
+
 struct smb_sockaddr_in {
 	__be16 Port;
 	__be32 IPv4address;
@@ -246,6 +1020,204 @@ struct file_sparse {
 	__u8	SetSparse;
 } __packed;
 
+struct file_zero_data_information {
+	__le64	FileOffset;
+	__le64	BeyondFinalZero;
+} __packed;
+
+struct file_allocated_range_buffer {
+	__le64	file_offset;
+	__le64	length;
+} __packed;
+
+struct reparse_data_buffer {
+	__le32	ReparseTag;
+	__le16	ReparseDataLength;
+	__u16	Reserved;
+	__u8	DataBuffer[]; /* Variable Length */
+} __packed;
+
+/* Completion Filter flags for Notify */
+#define FILE_NOTIFY_CHANGE_FILE_NAME	0x00000001
+#define FILE_NOTIFY_CHANGE_DIR_NAME	0x00000002
+#define FILE_NOTIFY_CHANGE_NAME		0x00000003
+#define FILE_NOTIFY_CHANGE_ATTRIBUTES	0x00000004
+#define FILE_NOTIFY_CHANGE_SIZE		0x00000008
+#define FILE_NOTIFY_CHANGE_LAST_WRITE	0x00000010
+#define FILE_NOTIFY_CHANGE_LAST_ACCESS	0x00000020
+#define FILE_NOTIFY_CHANGE_CREATION	0x00000040
+#define FILE_NOTIFY_CHANGE_EA		0x00000080
+#define FILE_NOTIFY_CHANGE_SECURITY	0x00000100
+#define FILE_NOTIFY_CHANGE_STREAM_NAME	0x00000200
+#define FILE_NOTIFY_CHANGE_STREAM_SIZE	0x00000400
+#define FILE_NOTIFY_CHANGE_STREAM_WRITE	0x00000800
+
+/* Flags */
+#define SMB2_WATCH_TREE	0x0001
+
+struct smb2_notify_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 32 */
+	__le16 Flags;
+	__le32 OutputBufferLength;
+	__u64 PersistentFileId;
+	__u64 VolatileFileId;
+	__u32 CompletionFileter;
+	__u32 Reserved;
+} __packed;
+
+struct smb2_notify_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 9 */
+	__le16 OutputBufferOffset;
+	__le32 OutputBufferLength;
+	__u8 Buffer[1];
+} __packed;
+
+/* SMB2 Notify Action Flags */
+#define FILE_ACTION_ADDED		0x00000001
+#define FILE_ACTION_REMOVED		0x00000002
+#define FILE_ACTION_MODIFIED		0x00000003
+#define FILE_ACTION_RENAMED_OLD_NAME	0x00000004
+#define FILE_ACTION_RENAMED_NEW_NAME	0x00000005
+#define FILE_ACTION_ADDED_STREAM	0x00000006
+#define FILE_ACTION_REMOVED_STREAM	0x00000007
+#define FILE_ACTION_MODIFIED_STREAM	0x00000008
+#define FILE_ACTION_REMOVED_BY_DELETE	0x00000009
+
+#define SMB2_LOCKFLAG_SHARED		0x0001
+#define SMB2_LOCKFLAG_EXCLUSIVE		0x0002
+#define SMB2_LOCKFLAG_UNLOCK		0x0004
+#define SMB2_LOCKFLAG_FAIL_IMMEDIATELY	0x0010
+#define SMB2_LOCKFLAG_MASK		0x0007
+
+struct smb2_lock_element {
+	__le64 Offset;
+	__le64 Length;
+	__le32 Flags;
+	__le32 Reserved;
+} __packed;
+
+struct smb2_lock_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 48 */
+	__le16 LockCount;
+	__le32 Reserved;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+	/* Followed by at least one */
+	struct smb2_lock_element locks[1];
+} __packed;
+
+struct smb2_lock_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 4 */
+	__le16 Reserved;
+} __packed;
+
+struct smb2_echo_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 4 */
+	__u16  Reserved;
+} __packed;
+
+struct smb2_echo_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize;	/* Must be 4 */
+	__u16  Reserved;
+} __packed;
+
+/* search (query_directory) Flags field */
+#define SMB2_RESTART_SCANS		0x01
+#define SMB2_RETURN_SINGLE_ENTRY	0x02
+#define SMB2_INDEX_SPECIFIED		0x04
+#define SMB2_REOPEN			0x10
+
+struct smb2_query_directory_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 33 */
+	__u8   FileInformationClass;
+	__u8   Flags;
+	__le32 FileIndex;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+	__le16 FileNameOffset;
+	__le16 FileNameLength;
+	__le32 OutputBufferLength;
+	__u8   Buffer[1];
+} __packed;
+
+struct smb2_query_directory_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 9 */
+	__le16 OutputBufferOffset;
+	__le32 OutputBufferLength;
+	__u8   Buffer[1];
+} __packed;
+
+/* Possible InfoType values */
+#define SMB2_O_INFO_FILE	0x01
+#define SMB2_O_INFO_FILESYSTEM	0x02
+#define SMB2_O_INFO_SECURITY	0x03
+#define SMB2_O_INFO_QUOTA	0x04
+
+/* Security info type additionalinfo flags. See MS-SMB2 (2.2.37) or MS-DTYP */
+#define OWNER_SECINFO   0x00000001
+#define GROUP_SECINFO   0x00000002
+#define DACL_SECINFO   0x00000004
+#define SACL_SECINFO   0x00000008
+#define LABEL_SECINFO   0x00000010
+#define ATTRIBUTE_SECINFO   0x00000020
+#define SCOPE_SECINFO   0x00000040
+#define BACKUP_SECINFO   0x00010000
+#define UNPROTECTED_SACL_SECINFO   0x10000000
+#define UNPROTECTED_DACL_SECINFO   0x20000000
+#define PROTECTED_SACL_SECINFO   0x40000000
+#define PROTECTED_DACL_SECINFO   0x80000000
+
+struct smb2_query_info_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 41 */
+	__u8   InfoType;
+	__u8   FileInfoClass;
+	__le32 OutputBufferLength;
+	__le16 InputBufferOffset;
+	__u16  Reserved;
+	__le32 InputBufferLength;
+	__le32 AdditionalInformation;
+	__le32 Flags;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+	__u8   Buffer[1];
+} __packed;
+
+struct smb2_query_info_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 9 */
+	__le16 OutputBufferOffset;
+	__le32 OutputBufferLength;
+	__u8   Buffer[1];
+} __packed;
+
+struct smb2_set_info_req {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 33 */
+	__u8   InfoType;
+	__u8   FileInfoClass;
+	__le32 BufferLength;
+	__le16 BufferOffset;
+	__u16  Reserved;
+	__le32 AdditionalInformation;
+	__u64  PersistentFileId;
+	__u64  VolatileFileId;
+	__u8   Buffer[1];
+} __packed;
+
+struct smb2_set_info_rsp {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 2 */
+} __packed;
+
 /* FILE Info response size */
 #define FILE_DIRECTORY_INFORMATION_SIZE       1
 #define FILE_FULL_DIRECTORY_INFORMATION_SIZE  2
@@ -301,11 +1273,145 @@ struct fs_type_info {
 	long		magic_number;
 } __packed;
 
+struct smb2_oplock_break {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 24 */
+	__u8   OplockLevel;
+	__u8   Reserved;
+	__le32 Reserved2;
+	__le64  PersistentFid;
+	__le64  VolatileFid;
+} __packed;
+
+#define SMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED cpu_to_le32(0x01)
+
+struct smb2_lease_break {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 44 */
+	__le16 Epoch;
+	__le32 Flags;
+	__u8   LeaseKey[16];
+	__le32 CurrentLeaseState;
+	__le32 NewLeaseState;
+	__le32 BreakReason;
+	__le32 AccessMaskHint;
+	__le32 ShareMaskHint;
+} __packed;
+
+struct smb2_lease_ack {
+	struct smb2_hdr hdr;
+	__le16 StructureSize; /* Must be 36 */
+	__le16 Reserved;
+	__le32 Flags;
+	__u8   LeaseKey[16];
+	__le32 LeaseState;
+	__le64 LeaseDuration;
+} __packed;
+
 /*
- *	PDU query infolevel structure definitions
+ *	PDU infolevel structure definitions
  *	BB consider moving to a different header
  */
 
+/* File System Information Classes */
+#define FS_VOLUME_INFORMATION		1 /* Query */
+#define FS_LABEL_INFORMATION		2 /* Set */
+#define FS_SIZE_INFORMATION		3 /* Query */
+#define FS_DEVICE_INFORMATION		4 /* Query */
+#define FS_ATTRIBUTE_INFORMATION	5 /* Query */
+#define FS_CONTROL_INFORMATION		6 /* Query, Set */
+#define FS_FULL_SIZE_INFORMATION	7 /* Query */
+#define FS_OBJECT_ID_INFORMATION	8 /* Query, Set */
+#define FS_DRIVER_PATH_INFORMATION	9 /* Query */
+#define FS_SECTOR_SIZE_INFORMATION	11 /* SMB3 or later. Query */
+#define FS_POSIX_INFORMATION		100 /* SMB3.1.1 POSIX. Query */
+
+struct smb2_fs_full_size_info {
+	__le64 TotalAllocationUnits;
+	__le64 CallerAvailableAllocationUnits;
+	__le64 ActualAvailableAllocationUnits;
+	__le32 SectorsPerAllocationUnit;
+	__le32 BytesPerSector;
+} __packed;
+
+#define SSINFO_FLAGS_ALIGNED_DEVICE		0x00000001
+#define SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE 0x00000002
+#define SSINFO_FLAGS_NO_SEEK_PENALTY		0x00000004
+#define SSINFO_FLAGS_TRIM_ENABLED		0x00000008
+
+/* sector size info struct */
+struct smb3_fs_ss_info {
+	__le32 LogicalBytesPerSector;
+	__le32 PhysicalBytesPerSectorForAtomicity;
+	__le32 PhysicalBytesPerSectorForPerf;
+	__le32 FSEffPhysicalBytesPerSectorForAtomicity;
+	__le32 Flags;
+	__le32 ByteOffsetForSectorAlignment;
+	__le32 ByteOffsetForPartitionAlignment;
+} __packed;
+
+/* File System Control Information */
+struct smb2_fs_control_info {
+	__le64 FreeSpaceStartFiltering;
+	__le64 FreeSpaceThreshold;
+	__le64 FreeSpaceStopFiltering;
+	__le64 DefaultQuotaThreshold;
+	__le64 DefaultQuotaLimit;
+	__le32 FileSystemControlFlags;
+	__le32 Padding;
+} __packed;
+
+/* partial list of QUERY INFO levels */
+#define FILE_DIRECTORY_INFORMATION	1
+#define FILE_FULL_DIRECTORY_INFORMATION 2
+#define FILE_BOTH_DIRECTORY_INFORMATION 3
+#define FILE_BASIC_INFORMATION		4
+#define FILE_STANDARD_INFORMATION	5
+#define FILE_INTERNAL_INFORMATION	6
+#define FILE_EA_INFORMATION	        7
+#define FILE_ACCESS_INFORMATION		8
+#define FILE_NAME_INFORMATION		9
+#define FILE_RENAME_INFORMATION		10
+#define FILE_LINK_INFORMATION		11
+#define FILE_NAMES_INFORMATION		12
+#define FILE_DISPOSITION_INFORMATION	13
+#define FILE_POSITION_INFORMATION	14
+#define FILE_FULL_EA_INFORMATION	15
+#define FILE_MODE_INFORMATION		16
+#define FILE_ALIGNMENT_INFORMATION	17
+#define FILE_ALL_INFORMATION		18
+#define FILE_ALLOCATION_INFORMATION	19
+#define FILE_END_OF_FILE_INFORMATION	20
+#define FILE_ALTERNATE_NAME_INFORMATION 21
+#define FILE_STREAM_INFORMATION		22
+#define FILE_PIPE_INFORMATION		23
+#define FILE_PIPE_LOCAL_INFORMATION	24
+#define FILE_PIPE_REMOTE_INFORMATION	25
+#define FILE_MAILSLOT_QUERY_INFORMATION 26
+#define FILE_MAILSLOT_SET_INFORMATION	27
+#define FILE_COMPRESSION_INFORMATION	28
+#define FILE_OBJECT_ID_INFORMATION	29
+/* Number 30 not defined in documents */
+#define FILE_MOVE_CLUSTER_INFORMATION	31
+#define FILE_QUOTA_INFORMATION		32
+#define FILE_REPARSE_POINT_INFORMATION	33
+#define FILE_NETWORK_OPEN_INFORMATION	34
+#define FILE_ATTRIBUTE_TAG_INFORMATION	35
+#define FILE_TRACKING_INFORMATION	36
+#define FILEID_BOTH_DIRECTORY_INFORMATION 37
+#define FILEID_FULL_DIRECTORY_INFORMATION 38
+#define FILE_VALID_DATA_LENGTH_INFORMATION 39
+#define FILE_SHORT_NAME_INFORMATION	40
+#define FILE_SFIO_RESERVE_INFORMATION	44
+#define FILE_SFIO_VOLUME_INFORMATION	45
+#define FILE_HARD_LINK_INFORMATION	46
+#define FILE_NORMALIZED_NAME_INFORMATION 48
+#define FILEID_GLOBAL_TX_DIRECTORY_INFORMATION 50
+#define FILE_STANDARD_LINK_INFORMATION	54
+
+#define OP_BREAK_STRUCT_SIZE_20		24
+#define OP_BREAK_STRUCT_SIZE_21		36
+
 struct smb2_file_access_info {
 	__le32 AccessFlags;
 } __packed;
@@ -314,6 +1420,56 @@ struct smb2_file_alignment_info {
 	__le32 AlignmentRequirement;
 } __packed;
 
+struct smb2_file_internal_info {
+	__le64 IndexNumber;
+} __packed; /* level 6 Query */
+
+struct smb2_file_rename_info { /* encoding of request for level 10 */
+	__u8   ReplaceIfExists; /* 1 = replace existing target with new */
+				/* 0 = fail if target already exists */
+	__u8   Reserved[7];
+	__u64  RootDirectory;  /* MBZ for network operations (why says spec?) */
+	__le32 FileNameLength;
+	char   FileName[0];     /* New name to be assigned */
+} __packed; /* level 10 Set */
+
+struct smb2_file_link_info { /* encoding of request for level 11 */
+	__u8   ReplaceIfExists; /* 1 = replace existing link with new */
+				/* 0 = fail if link already exists */
+	__u8   Reserved[7];
+	__u64  RootDirectory;  /* MBZ for network operations (why says spec?) */
+	__le32 FileNameLength;
+	char   FileName[0];     /* Name to be assigned to new link */
+} __packed; /* level 11 Set */
+
+/*
+ * This level 18, although with struct with same name is different from cifs
+ * level 0x107. Level 0x107 has an extra u64 between AccessFlags and
+ * CurrentByteOffset.
+ */
+struct smb2_file_all_info { /* data block encoding of response to level 18 */
+	__le64 CreationTime;	/* Beginning of FILE_BASIC_INFO equivalent */
+	__le64 LastAccessTime;
+	__le64 LastWriteTime;
+	__le64 ChangeTime;
+	__le32 Attributes;
+	__u32  Pad1;		/* End of FILE_BASIC_INFO_INFO equivalent */
+	__le64 AllocationSize;	/* Beginning of FILE_STANDARD_INFO equivalent */
+	__le64 EndOfFile;	/* size ie offset to first free byte in file */
+	__le32 NumberOfLinks;	/* hard links */
+	__u8   DeletePending;
+	__u8   Directory;
+	__u16  Pad2;		/* End of FILE_STANDARD_INFO equivalent */
+	__le64 IndexNumber;
+	__le32 EASize;
+	__le32 AccessFlags;
+	__le64 CurrentByteOffset;
+	__le32 Mode;
+	__le32 AlignmentRequirement;
+	__le32 FileNameLength;
+	char   FileName[1];
+} __packed; /* level 18 Query */
+
 struct smb2_file_basic_info { /* data block encoding of response to level 18 */
 	__le64 CreationTime;	/* Beginning of FILE_BASIC_INFO equivalent */
 	__le64 LastAccessTime;
@@ -325,7 +1481,7 @@ struct smb2_file_basic_info { /* data block encoding of response to level 18 */
 
 struct smb2_file_alt_name_info {
 	__le32 FileNameLength;
-	char FileName[];
+	char FileName[0];
 } __packed;
 
 struct smb2_file_stream_info {
@@ -333,9 +1489,13 @@ struct smb2_file_stream_info {
 	__le32  StreamNameLength;
 	__le64 StreamSize;
 	__le64 StreamAllocationSize;
-	char   StreamName[];
+	char   StreamName[0];
 } __packed;
 
+struct smb2_file_eof_info { /* encoding of request for level 10 */
+	__le64 EndOfFile; /* new end of file value */
+} __packed; /* level 20 Set */
+
 struct smb2_file_ntwrk_info {
 	__le64 CreationTime;
 	__le64 LastAccessTime;
@@ -372,7 +1532,7 @@ struct smb2_file_pos_info {
 	__le64 CurrentByteOffset;
 } __packed;
 
-#define FILE_MODE_INFO_MASK cpu_to_le32(0x0000100e)
+#define FILE_MODE_INFO_MASK cpu_to_le32(0x0000103e)
 
 struct smb2_file_mode_info {
 	__le32 Mode;
@@ -410,7 +1570,7 @@ struct smb2_ea_info {
 	__u8   Flags;
 	__u8   EaNameLength;
 	__le16 EaValueLength;
-	char name[1];
+	char name[];
 	/* optionally followed by value */
 } __packed; /* level 15 Query */
 
@@ -426,6 +1586,34 @@ struct create_sd_buf_req {
 	struct smb_ntsd ntsd;
 } __packed;
 
+/* Find File infolevels */
+#define SMB_FIND_FILE_POSIX_INFO	0x064
+
+/* Level 100 query info */
+struct smb311_posix_qinfo {
+	__le64 CreationTime;
+	__le64 LastAccessTime;
+	__le64 LastWriteTime;
+	__le64 ChangeTime;
+	__le64 EndOfFile;
+	__le64 AllocationSize;
+	__le32 DosAttributes;
+	__le64 Inode;
+	__le32 DeviceId;
+	__le32 Zero;
+	/* beginning of POSIX Create Context Response */
+	__le32 HardLinks;
+	__le32 ReparseTag;
+	__le32 Mode;
+	u8     Sids[];
+	/*
+	 * var sized owner SID
+	 * var sized group SID
+	 * le32 filenamelength
+	 * u8  filename[]
+	 */
+} __packed;
+
 struct smb2_posix_info {
 	__le32 NextEntryOffset;
 	__u32 Ignored;
@@ -456,6 +1644,7 @@ struct smb2_posix_info {
 } __packed;
 
 /* functions */
+int init_smb2_0_server(struct ksmbd_conn *conn);
 void init_smb2_1_server(struct ksmbd_conn *conn);
 void init_smb3_0_server(struct ksmbd_conn *conn);
 void init_smb3_02_server(struct ksmbd_conn *conn);
@@ -488,6 +1677,7 @@ int find_matching_smb2_dialect(int start_index, __le16 *cli_dialects,
 struct file_lock *smb_flock_init(struct file *f);
 int setup_async_work(struct ksmbd_work *work, void (*fn)(void **),
 		     void **arg);
+void release_async_work(struct ksmbd_work *work);
 void smb2_send_interim_resp(struct ksmbd_work *work, __le32 status);
 struct channel *lookup_chann_list(struct ksmbd_session *sess,
 				  struct ksmbd_conn *conn);
diff --git a/fs/ksmbd/smb_common.c b/fs/ksmbd/smb_common.c
index 212dfff8e764..2163e412f5ac 100644
--- a/fs/ksmbd/smb_common.c
+++ b/fs/ksmbd/smb_common.c
@@ -7,6 +7,7 @@
 #include <linux/user_namespace.h>
 
 #include "smb_common.h"
+#include "smb1pdu.h"
 #include "server.h"
 #include "misc.h"
 #include "smbstatus.h"
@@ -24,6 +25,12 @@ static const char basechars[43] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_-!@#$%";
 #define PERIOD '.'
 #define mangle(V) ((char)(basechars[(V) % MANGLE_BASE]))
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+#define KSMBD_MIN_SUPPORTED_HEADER_SIZE	(sizeof(struct smb_hdr))
+#else
+#define KSMBD_MIN_SUPPORTED_HEADER_SIZE	(sizeof(struct smb2_hdr))
+#endif
+
 struct smb_protocol {
 	int		index;
 	char		*name;
@@ -32,12 +39,20 @@ struct smb_protocol {
 };
 
 static struct smb_protocol smb1_protos[] = {
+#ifdef CONFIG_SMB_INSECURE_SERVER
 	{
-		SMB21_PROT,
-		"\2SMB 2.1",
-		"SMB2_10",
-		SMB21_PROT_ID
+		SMB1_PROT,
+		"\2NT LM 0.12",
+		"NT1",
+		SMB10_PROT_ID
 	},
+	{
+		SMB2_PROT,
+		"\2SMB 2.002",
+		"SMB2_02",
+		SMB20_PROT_ID
+	},
+#endif
 	{
 		SMB2X_PROT,
 		"\2SMB 2.???",
@@ -47,6 +62,12 @@ static struct smb_protocol smb1_protos[] = {
 };
 
 static struct smb_protocol smb2_protos[] = {
+	{
+		SMB2_PROT,
+		"\2SMB 2.002",
+		"SMB2_02",
+		SMB20_PROT_ID
+	},
 	{
 		SMB21_PROT,
 		"\2SMB 2.1",
@@ -90,7 +111,11 @@ unsigned int ksmbd_server_side_copy_max_total_size(void)
 
 inline int ksmbd_min_protocol(void)
 {
-	return SMB21_PROT;
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	return SMB1_PROT;
+#else
+	return SMB2_PROT;
+#endif
 }
 
 inline int ksmbd_max_protocol(void)
@@ -130,11 +155,21 @@ int ksmbd_lookup_protocol_idx(char *str)
  *
  * check for valid smb signature and packet direction(request/response)
  *
- * Return:      0 on success, otherwise -EINVAL
+ * Return:      0 on success, otherwise error
  */
 int ksmbd_verify_smb_message(struct ksmbd_work *work)
 {
 	struct smb2_hdr *smb2_hdr = ksmbd_req_buf_next(work);
+
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	if (smb2_hdr->ProtocolId == SMB2_PROTO_NUMBER) {
+		ksmbd_debug(SMB, "got SMB2 command\n");
+		return ksmbd_smb2_check_message(work);
+	}
+
+	work->conn->outstanding_credits++;
+	return ksmbd_smb1_check_message(work);
+#else
 	struct smb_hdr *hdr;
 
 	if (smb2_hdr->ProtocolId == SMB2_PROTO_NUMBER)
@@ -148,6 +183,7 @@ int ksmbd_verify_smb_message(struct ksmbd_work *work)
 	}
 
 	return -EINVAL;
+#endif
 }
 
 /**
@@ -158,7 +194,19 @@ int ksmbd_verify_smb_message(struct ksmbd_work *work)
  */
 bool ksmbd_smb_request(struct ksmbd_conn *conn)
 {
-	return conn->request_buf[0] == 0;
+	__le32 *proto = (__le32 *)smb2_get_msg(conn->request_buf);
+
+	if (*proto == SMB2_COMPRESSION_TRANSFORM_ID) {
+		pr_err_ratelimited("smb2 compression not support yet");
+		return false;
+	}
+
+	if (*proto != SMB1_PROTO_NUMBER &&
+	    *proto != SMB2_PROTO_NUMBER &&
+	    *proto != SMB2_TRANSFORM_PROTO_NUM)
+		return false;
+
+	return true;
 }
 
 static bool supported_protocol(int idx)
@@ -254,7 +302,7 @@ static int ksmbd_negotiate_smb_dialect(void *buf)
 		if (smb2_neg_size > smb_buf_length)
 			goto err_out;
 
-		if (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >
+		if (struct_size(req, Dialects, le16_to_cpu(req->DialectCount)) >
 		    smb_buf_length)
 			goto err_out;
 
@@ -283,6 +331,7 @@ static int ksmbd_negotiate_smb_dialect(void *buf)
 	return BAD_PROT_ID;
 }
 
+#ifndef CONFIG_SMB_INSECURE_SERVER
 #define SMB_COM_NEGOTIATE_EX	0x0
 
 /**
@@ -307,12 +356,6 @@ static int init_smb1_rsp_hdr(struct ksmbd_work *work)
 	struct smb_hdr *rsp_hdr = (struct smb_hdr *)work->response_buf;
 	struct smb_hdr *rcv_hdr = (struct smb_hdr *)work->request_buf;
 
-	/*
-	 * Remove 4 byte direct TCP header.
-	 */
-	*(__be32 *)work->response_buf =
-		cpu_to_be32(sizeof(struct smb_hdr) - 4);
-
 	rsp_hdr->Command = SMB_COM_NEGOTIATE;
 	*(__le32 *)rsp_hdr->Protocol = SMB1_PROTO_NUMBER;
 	rsp_hdr->Flags = SMBFLG_RESPONSE;
@@ -347,8 +390,8 @@ static int smb1_check_user_session(struct ksmbd_work *work)
  */
 static int smb1_allocate_rsp_buf(struct ksmbd_work *work)
 {
-	work->response_buf = kmalloc(MAX_CIFS_SMALL_BUFFER_SIZE,
-			GFP_KERNEL | __GFP_ZERO);
+	work->response_buf = kzalloc(MAX_CIFS_SMALL_BUFFER_SIZE,
+			GFP_KERNEL);
 	work->response_sz = MAX_CIFS_SMALL_BUFFER_SIZE;
 
 	if (!work->response_buf) {
@@ -360,11 +403,22 @@ static int smb1_allocate_rsp_buf(struct ksmbd_work *work)
 	return 0;
 }
 
+/**
+ * set_smb1_rsp_status() - set error type in smb response header
+ * @work:	smb work containing smb response header
+ * @err:	error code to set in response
+ */
+static void set_smb1_rsp_status(struct ksmbd_work *work, __le32 err)
+{
+	work->send_no_response = 1;
+}
+
 static struct smb_version_ops smb1_server_ops = {
 	.get_cmd_val = get_smb1_cmd_val,
 	.init_rsp_hdr = init_smb1_rsp_hdr,
 	.allocate_rsp_buf = smb1_allocate_rsp_buf,
 	.check_user_session = smb1_check_user_session,
+	.set_rsp_status = set_smb1_rsp_status,
 };
 
 static int smb1_negotiate(struct ksmbd_work *work)
@@ -376,26 +430,30 @@ static struct smb_version_cmds smb1_server_cmds[1] = {
 	[SMB_COM_NEGOTIATE_EX]	= { .proc = smb1_negotiate, },
 };
 
-static void init_smb1_server(struct ksmbd_conn *conn)
+static int init_smb1_server(struct ksmbd_conn *conn)
 {
 	conn->ops = &smb1_server_ops;
 	conn->cmds = smb1_server_cmds;
 	conn->max_cmds = ARRAY_SIZE(smb1_server_cmds);
+	return 0;
 }
+#endif
 
-void ksmbd_init_smb_server(struct ksmbd_work *work)
+int ksmbd_init_smb_server(struct ksmbd_work *work)
 {
 	struct ksmbd_conn *conn = work->conn;
 	__le32 proto;
 
-	if (conn->need_neg == false)
-		return;
-
 	proto = *(__le32 *)((struct smb_hdr *)work->request_buf)->Protocol;
+	if (conn->need_neg == false) {
+		if (proto == SMB1_PROTO_NUMBER)
+			return -EINVAL;
+		return 0;
+	}
+
 	if (proto == SMB1_PROTO_NUMBER)
-		init_smb1_server(conn);
-	else
-		init_smb3_11_server(conn);
+		return init_smb1_server(conn);
+	return init_smb3_11_server(conn);
 }
 
 int ksmbd_populate_dot_dotdot_entries(struct ksmbd_work *work, int info_level,
@@ -408,7 +466,11 @@ int ksmbd_populate_dot_dotdot_entries(struct ksmbd_work *work, int info_level,
 {
 	int i, rc = 0;
 	struct ksmbd_conn *conn = work->conn;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(dir->filp);
+#else
 	struct user_namespace *user_ns = file_mnt_user_ns(dir->filp);
+#endif
 
 	for (i = 0; i < 2; i++) {
 		struct kstat kstat;
@@ -434,7 +496,11 @@ int ksmbd_populate_dot_dotdot_entries(struct ksmbd_work *work, int info_level,
 
 			ksmbd_kstat.kstat = &kstat;
 			ksmbd_vfs_fill_dentry_attrs(work,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+						    idmap,
+#else
 						    user_ns,
+#endif
 						    dentry,
 						    &ksmbd_kstat);
 			rc = fn(conn, info_level, d_info, &ksmbd_kstat);
@@ -524,7 +590,7 @@ int ksmbd_extract_shortname(struct ksmbd_conn *conn, const char *longname,
 	out[baselen + 3] = PERIOD;
 
 	if (dot_present)
-		memcpy(&out[baselen + 4], extension, 4);
+		memcpy(out + baselen + 4, extension, 4);
 	else
 		out[baselen + 4] = '\0';
 	smbConvertToUTF16((__le16 *)shortname, out, PATH_MAX,
@@ -539,21 +605,24 @@ static int __smb2_negotiate(struct ksmbd_conn *conn)
 		conn->dialect <= SMB311_PROT_ID);
 }
 
+#ifndef CONFIG_SMB_INSECURE_SERVER
 static int smb_handle_negotiate(struct ksmbd_work *work)
 {
 	struct smb_negotiate_rsp *neg_rsp = work->response_buf;
 
 	ksmbd_debug(SMB, "Unsupported SMB1 protocol\n");
 
-	/* Add 2 byte bcc and 2 byte DialectIndex. */
-	inc_rfc1001_len(work->response_buf, 4);
-	neg_rsp->hdr.Status.CifsError = STATUS_SUCCESS;
+	if (ksmbd_iov_pin_rsp(work, (void *)neg_rsp,
+			      sizeof(struct smb_negotiate_unsupported_rsp) - 4))
+		return -ENOMEM;
 
+	neg_rsp->hdr.Status.CifsError = STATUS_SUCCESS;
 	neg_rsp->hdr.WordCount = 1;
 	neg_rsp->DialectIndex = cpu_to_le16(work->conn->dialect);
 	neg_rsp->ByteCount = 0;
 	return 0;
 }
+#endif
 
 int ksmbd_smb_negotiate_common(struct ksmbd_work *work, unsigned int command)
 {
diff --git a/fs/ksmbd/smb_common.h b/fs/ksmbd/smb_common.h
index 9130d2e3cd78..db800429b88c 100644
--- a/fs/ksmbd/smb_common.h
+++ b/fs/ksmbd/smb_common.h
@@ -10,7 +10,6 @@
 
 #include "glob.h"
 #include "nterr.h"
-#include "../smbfs_common/smb2pdu.h"
 #include "smb2pdu.h"
 
 /* ksmbd's Specific ERRNO */
@@ -33,6 +32,17 @@
 #define SMB302_VERSION_STRING	"3.02"
 #define SMB311_VERSION_STRING	"3.1.1"
 
+/* Dialects */
+#define SMB10_PROT_ID		0x00
+#define SMB20_PROT_ID		0x0202
+#define SMB21_PROT_ID		0x0210
+/* multi-protocol negotiate request */
+#define SMB2X_PROT_ID		0x02FF
+#define SMB30_PROT_ID		0x0300
+#define SMB302_PROT_ID		0x0302
+#define SMB311_PROT_ID		0x0311
+#define BAD_PROT_ID		0xFFFF
+
 #define SMB_ECHO_INTERVAL	(60 * HZ)
 
 #define CIFS_DEFAULT_IOSIZE	(64 * 1024)
@@ -40,6 +50,9 @@
 
 #define MAX_STREAM_PROT_LEN	0x00FFFFFF
 
+#define IS_SMB2(x)		((x)->vals->protocol_id != SMB10_PROT_ID)
+#define MAX_HEADER_SIZE(conn)		((conn)->vals->max_header_size)
+
 /* Responses when opening a file. */
 #define F_SUPERSEDED	0
 #define F_OPENED	1
@@ -49,6 +62,21 @@
 /*
  * File Attribute flags
  */
+#define ATTR_READONLY			0x0001
+#define ATTR_HIDDEN			0x0002
+#define ATTR_SYSTEM			0x0004
+#define ATTR_VOLUME			0x0008
+#define ATTR_DIRECTORY			0x0010
+#define ATTR_ARCHIVE			0x0020
+#define ATTR_DEVICE			0x0040
+#define ATTR_NORMAL			0x0080
+#define ATTR_TEMPORARY			0x0100
+#define ATTR_SPARSE			0x0200
+#define ATTR_REPARSE			0x0400
+#define ATTR_COMPRESSED			0x0800
+#define ATTR_OFFLINE			0x1000
+#define ATTR_NOT_CONTENT_INDEXED	0x2000
+#define ATTR_ENCRYPTED			0x4000
 #define ATTR_POSIX_SEMANTICS		0x01000000
 #define ATTR_BACKUP_SEMANTICS		0x02000000
 #define ATTR_DELETE_ON_CLOSE		0x04000000
@@ -57,6 +85,23 @@
 #define ATTR_NO_BUFFERING		0x20000000
 #define ATTR_WRITE_THROUGH		0x80000000
 
+#define ATTR_READONLY_LE		cpu_to_le32(ATTR_READONLY)
+#define ATTR_HIDDEN_LE			cpu_to_le32(ATTR_HIDDEN)
+#define ATTR_SYSTEM_LE			cpu_to_le32(ATTR_SYSTEM)
+#define ATTR_DIRECTORY_LE		cpu_to_le32(ATTR_DIRECTORY)
+#define ATTR_ARCHIVE_LE			cpu_to_le32(ATTR_ARCHIVE)
+#define ATTR_NORMAL_LE			cpu_to_le32(ATTR_NORMAL)
+#define ATTR_TEMPORARY_LE		cpu_to_le32(ATTR_TEMPORARY)
+#define ATTR_SPARSE_FILE_LE		cpu_to_le32(ATTR_SPARSE)
+#define ATTR_REPARSE_POINT_LE		cpu_to_le32(ATTR_REPARSE)
+#define ATTR_COMPRESSED_LE		cpu_to_le32(ATTR_COMPRESSED)
+#define ATTR_OFFLINE_LE			cpu_to_le32(ATTR_OFFLINE)
+#define ATTR_NOT_CONTENT_INDEXED_LE	cpu_to_le32(ATTR_NOT_CONTENT_INDEXED)
+#define ATTR_ENCRYPTED_LE		cpu_to_le32(ATTR_ENCRYPTED)
+#define ATTR_INTEGRITY_STREAML_LE	cpu_to_le32(0x00008000)
+#define ATTR_NO_SCRUB_DATA_LE		cpu_to_le32(0x00020000)
+#define ATTR_MASK_LE			cpu_to_le32(0x00007FB7)
+
 /* List of FileSystemAttributes - see 2.5.1 of MS-FSCC */
 #define FILE_SUPPORTS_SPARSE_VDL	0x10000000 /* faster nonsparse extend */
 #define FILE_SUPPORTS_BLOCK_REFCOUNTING	0x08000000 /* allow ioctl dup extents */
@@ -118,6 +163,11 @@
 /* file_execute, file_read_attributes*/
 /* write_dac, and delete.           */
 
+#define FILE_READ_RIGHTS (FILE_READ_DATA | FILE_READ_EA | FILE_READ_ATTRIBUTES)
+#define FILE_WRITE_RIGHTS (FILE_WRITE_DATA | FILE_APPEND_DATA \
+		| FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES)
+#define FILE_EXEC_RIGHTS (FILE_EXECUTE)
+
 #define SET_FILE_READ_RIGHTS (FILE_READ_DATA | FILE_READ_EA \
 		| FILE_READ_ATTRIBUTES \
 		| DELETE | READ_CONTROL | WRITE_DAC \
@@ -158,15 +208,8 @@
 
 #define SMB1_PROTO_NUMBER		cpu_to_le32(0x424d53ff)
 #define SMB_COM_NEGOTIATE		0x72
-#define SMB1_CLIENT_GUID_SIZE		(16)
-
-#define SMBFLG_RESPONSE 0x80	/* this PDU is a response from server */
-
-#define SMBFLG2_IS_LONG_NAME	cpu_to_le16(0x40)
-#define SMBFLG2_EXT_SEC		cpu_to_le16(0x800)
-#define SMBFLG2_ERR_STATUS	cpu_to_le16(0x4000)
-#define SMBFLG2_UNICODE		cpu_to_le16(0x8000)
 
+#define SMB1_CLIENT_GUID_SIZE		(16)
 struct smb_hdr {
 	__be32 smb_buf_length;
 	__u8 Protocol[4];
@@ -200,10 +243,10 @@ struct smb_hdr {
 struct smb_negotiate_req {
 	struct smb_hdr hdr;     /* wct = 0 */
 	__le16 ByteCount;
-	unsigned char DialectsArray[1];
+	unsigned char DialectsArray[];
 } __packed;
 
-struct smb_negotiate_rsp {
+struct smb_negotiate_unsupported_rsp {
 	struct smb_hdr hdr;     /* wct = 17 */
 	__le16 DialectIndex; /* 0xFFFF = no dialect acceptable */
 	__le16 ByteCount;
@@ -236,6 +279,14 @@ struct filesystem_info {
 	__le32 BytesPerSector;
 } __packed;     /* size info, level 0x103 */
 
+struct filesystem_full_info {
+	__le64 TotalAllocationUnits;
+	__le64 FreeAllocationUnits;
+	__le64 ActualAvailableUnits;
+	__le32 SectorsPerAllocationUnit;
+	__le32 BytesPerSector;
+} __packed;     /* size info, level 0x3ef */
+
 #define EXTENDED_INFO_MAGIC 0x43667364	/* Cfsd */
 #define STRING_LENGTH 28
 
@@ -427,7 +478,9 @@ bool ksmbd_smb_request(struct ksmbd_conn *conn);
 
 int ksmbd_lookup_dialect_by_id(__le16 *cli_dialects, __le16 dialects_count);
 
-void ksmbd_init_smb_server(struct ksmbd_work *work);
+int ksmbd_init_smb_server(struct ksmbd_work *work);
+
+bool ksmbd_pdu_size_has_room(unsigned int pdu);
 
 struct ksmbd_kstat;
 int ksmbd_populate_dot_dotdot_entries(struct ksmbd_work *work,
diff --git a/fs/ksmbd/smbacl.c b/fs/ksmbd/smbacl.c
index ab5c68cc0e13..416420ef483a 100644
--- a/fs/ksmbd/smbacl.c
+++ b/fs/ksmbd/smbacl.c
@@ -6,10 +6,13 @@
  *   Author(s): Namjae Jeon <linkinjeon@kernel.org>
  */
 
+#include <linux/version.h>
 #include <linux/fs.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
 #include <linux/mnt_idmapping.h>
+#endif
 
 #include "smbacl.h"
 #include "smb_common.h"
@@ -97,7 +100,7 @@ int compare_sids(const struct smb_sid *ctsid, const struct smb_sid *cwsid)
 	/* compare all of the subauth values if any */
 	num_sat = ctsid->num_subauth;
 	num_saw = cwsid->num_subauth;
-	num_subauth = num_sat < num_saw ? num_sat : num_saw;
+	num_subauth = min(num_sat, num_saw);
 	if (num_subauth) {
 		for (i = 0; i < num_subauth; ++i) {
 			if (ctsid->sub_auth[i] != cwsid->sub_auth[i]) {
@@ -254,7 +257,11 @@ void id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid)
 	ssid->num_subauth++;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static int sid_to_id(struct mnt_idmap *idmap,
+#else
 static int sid_to_id(struct user_namespace *user_ns,
+#endif
 		     struct smb_sid *psid, uint sidtype,
 		     struct smb_fattr *fattr)
 {
@@ -270,13 +277,38 @@ static int sid_to_id(struct user_namespace *user_ns,
 		return -EIO;
 	}
 
+	if (!compare_sids(psid, &sid_everyone))
+		return -EIO;
+
 	if (sidtype == SIDOWNER) {
 		kuid_t uid;
 		uid_t id;
 
 		id = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0) || \
+    (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 52) && LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 		uid = KUIDT_INIT(id);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		uid = from_vfsuid(idmap, &init_user_ns, VFSUIDT_INIT(uid));
+#else
 		uid = from_vfsuid(user_ns, &init_user_ns, VFSUIDT_INIT(uid));
+#endif
+#else
+		uid = mapped_kuid_user(user_ns, &init_user_ns, KUIDT_INIT(id));
+#endif
+#else
+		/*
+		 * Translate raw sid into kuid in the server's user
+		 * namespace.
+		 */
+		uid = make_kuid(&init_user_ns, id);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		/* If this is an idmapped mount, apply the idmapping. */
+		uid = kuid_from_mnt(user_ns, uid);
+#endif
+#endif
 		if (uid_valid(uid)) {
 			fattr->cf_uid = uid;
 			rc = 0;
@@ -286,8 +318,30 @@ static int sid_to_id(struct user_namespace *user_ns,
 		gid_t id;
 
 		id = le32_to_cpu(psid->sub_auth[psid->num_subauth - 1]);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0) || \
+    (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 52) && LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 		gid = KGIDT_INIT(id);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		gid = from_vfsgid(idmap, &init_user_ns, VFSGIDT_INIT(gid));
+#else
 		gid = from_vfsgid(user_ns, &init_user_ns, VFSGIDT_INIT(gid));
+#endif
+#else
+		gid = mapped_kgid_user(user_ns, &init_user_ns, KGIDT_INIT(id));
+#endif
+#else
+		/*
+		 * Translate raw sid into kgid in the server's user
+		 * namespace.
+		 */
+		gid = make_kgid(&init_user_ns, id);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		/* If this is an idmapped mount, apply the idmapping. */
+		gid = kgid_from_mnt(user_ns, gid);
+#endif
+#endif
 		if (gid_valid(gid)) {
 			fattr->cf_gid = gid;
 			rc = 0;
@@ -362,7 +416,11 @@ void free_acl_state(struct posix_acl_state *state)
 	kfree(state->groups);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static void parse_dacl(struct mnt_idmap *idmap,
+#else
 static void parse_dacl(struct user_namespace *user_ns,
+#endif
 		       struct smb_acl *pdacl, char *end_of_acl,
 		       struct smb_sid *pownersid, struct smb_sid *pgrpsid,
 		       struct smb_fattr *fattr)
@@ -489,7 +547,11 @@ static void parse_dacl(struct user_namespace *user_ns,
 			acl_mode = access_flags_to_mode(fattr, ppace[i]->access_req,
 							ppace[i]->type);
 			temp_fattr.cf_uid = INVALID_UID;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			ret = sid_to_id(idmap, &ppace[i]->sid, SIDOWNER, &temp_fattr);
+#else
 			ret = sid_to_id(user_ns, &ppace[i]->sid, SIDOWNER, &temp_fattr);
+#endif
 			if (ret || uid_eq(temp_fattr.cf_uid, INVALID_UID)) {
 				pr_err("%s: Error %d mapping Owner SID to uid\n",
 				       __func__, ret);
@@ -575,7 +637,11 @@ static void parse_dacl(struct user_namespace *user_ns,
 	free_acl_state(&default_acl_state);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static void set_posix_acl_entries_dacl(struct mnt_idmap *idmap,
+#else
 static void set_posix_acl_entries_dacl(struct user_namespace *user_ns,
+#endif
 				       struct smb_ace *pndace,
 				       struct smb_fattr *fattr, u32 *num_aces,
 				       u16 *size, u32 nt_aces_num)
@@ -600,14 +666,22 @@ static void set_posix_acl_entries_dacl(struct user_namespace *user_ns,
 			uid_t uid;
 			unsigned int sid_type = SIDOWNER;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			uid = posix_acl_uid_translate(idmap, pace);
+#else
 			uid = posix_acl_uid_translate(user_ns, pace);
+#endif
 			if (!uid)
 				sid_type = SIDUNIX_USER;
 			id_to_sid(uid, sid_type, sid);
 		} else if (pace->e_tag == ACL_GROUP) {
 			gid_t gid;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			gid = posix_acl_gid_translate(idmap, pace);
+#else
 			gid = posix_acl_gid_translate(user_ns, pace);
+#endif
 			id_to_sid(gid, SIDUNIX_GROUP, sid);
 		} else if (pace->e_tag == ACL_OTHER && !nt_aces_num) {
 			smb_copy_sid(sid, &sid_everyone);
@@ -666,12 +740,20 @@ static void set_posix_acl_entries_dacl(struct user_namespace *user_ns,
 		if (pace->e_tag == ACL_USER) {
 			uid_t uid;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			uid = posix_acl_uid_translate(idmap, pace);
+#else
 			uid = posix_acl_uid_translate(user_ns, pace);
+#endif
 			id_to_sid(uid, SIDCREATOR_OWNER, sid);
 		} else if (pace->e_tag == ACL_GROUP) {
 			gid_t gid;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			gid = posix_acl_gid_translate(idmap, pace);
+#else
 			gid = posix_acl_gid_translate(user_ns, pace);
+#endif
 			id_to_sid(gid, SIDCREATOR_GROUP, sid);
 		} else {
 			kfree(sid);
@@ -689,7 +771,11 @@ static void set_posix_acl_entries_dacl(struct user_namespace *user_ns,
 	}
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static void set_ntacl_dacl(struct mnt_idmap *idmap,
+#else
 static void set_ntacl_dacl(struct user_namespace *user_ns,
+#endif
 			   struct smb_acl *pndacl,
 			   struct smb_acl *nt_dacl,
 			   unsigned int aces_size,
@@ -723,13 +809,21 @@ static void set_ntacl_dacl(struct user_namespace *user_ns,
 		}
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	set_posix_acl_entries_dacl(idmap, pndace, fattr,
+#else
 	set_posix_acl_entries_dacl(user_ns, pndace, fattr,
+#endif
 				   &num_aces, &size, nt_num_aces);
 	pndacl->num_aces = cpu_to_le32(num_aces);
 	pndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static void set_mode_dacl(struct mnt_idmap *idmap,
+#else
 static void set_mode_dacl(struct user_namespace *user_ns,
+#endif
 			  struct smb_acl *pndacl, struct smb_fattr *fattr)
 {
 	struct smb_ace *pace, *pndace;
@@ -741,7 +835,11 @@ static void set_mode_dacl(struct user_namespace *user_ns,
 	pace = pndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));
 
 	if (fattr->cf_acls) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		set_posix_acl_entries_dacl(idmap, pndace, fattr,
+#else
 		set_posix_acl_entries_dacl(user_ns, pndace, fattr,
+#endif
 					   &num_aces, &size, num_aces);
 		goto out;
 	}
@@ -808,7 +906,11 @@ static int parse_sid(struct smb_sid *psid, char *end_of_acl)
 }
 
 /* Convert CIFS ACL to POSIX form */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int parse_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,
+#else
 int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
+#endif
 		   int acl_len, struct smb_fattr *fattr)
 {
 	int rc = 0;
@@ -851,7 +953,11 @@ int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
 			return rc;
 		}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = sid_to_id(idmap, owner_sid_ptr, SIDOWNER, fattr);
+#else
 		rc = sid_to_id(user_ns, owner_sid_ptr, SIDOWNER, fattr);
+#endif
 		if (rc) {
 			pr_err("%s: Error %d mapping Owner SID to uid\n",
 			       __func__, rc);
@@ -866,7 +972,11 @@ int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
 			       __func__, rc);
 			return rc;
 		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = sid_to_id(idmap, group_sid_ptr, SIDUNIX_GROUP, fattr);
+#else
 		rc = sid_to_id(user_ns, group_sid_ptr, SIDUNIX_GROUP, fattr);
+#endif
 		if (rc) {
 			pr_err("%s: Error %d mapping Group SID to gid\n",
 			       __func__, rc);
@@ -881,7 +991,11 @@ int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
 		pntsd->type |= cpu_to_le16(DACL_PROTECTED);
 
 	if (dacloffset) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		parse_dacl(idmap, dacl_ptr, end_of_acl,
+#else
 		parse_dacl(user_ns, dacl_ptr, end_of_acl,
+#endif
 			   owner_sid_ptr, group_sid_ptr, fattr);
 	}
 
@@ -889,7 +1003,11 @@ int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
 }
 
 /* Convert permission bits from mode to equivalent CIFS ACL */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int build_sec_desc(struct mnt_idmap *idmap,
+#else
 int build_sec_desc(struct user_namespace *user_ns,
+#endif
 		   struct smb_ntsd *pntsd, struct smb_ntsd *ppntsd,
 		   int ppntsd_size, int addition_info, __u32 *secdesclen,
 		   struct smb_fattr *fattr)
@@ -950,7 +1068,11 @@ int build_sec_desc(struct user_namespace *user_ns,
 		dacl_ptr->num_aces = 0;
 
 		if (!ppntsd) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			set_mode_dacl(idmap, dacl_ptr, fattr);
+#else
 			set_mode_dacl(user_ns, dacl_ptr, fattr);
+#endif
 		} else {
 			struct smb_acl *ppdacl_ptr;
 			unsigned int dacl_offset = le32_to_cpu(ppntsd->dacloffset);
@@ -966,7 +1088,11 @@ int build_sec_desc(struct user_namespace *user_ns,
 			    ppdacl_size < sizeof(struct smb_acl))
 				goto out;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			set_ntacl_dacl(idmap, dacl_ptr, ppdacl_ptr,
+#else
 			set_ntacl_dacl(user_ns, dacl_ptr, ppdacl_ptr,
+#endif
 				       ntacl_size - sizeof(struct smb_acl),
 				       nowner_sid_ptr, ngroup_sid_ptr,
 				       fattr);
@@ -1002,13 +1128,21 @@ int smb_inherit_dacl(struct ksmbd_conn *conn,
 	struct smb_ntsd *parent_pntsd = NULL;
 	struct smb_sid owner_sid, group_sid;
 	struct dentry *parent = path->dentry->d_parent;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	int inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;
 	int rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;
 	char *aces_base;
 	bool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	pntsd_size = ksmbd_vfs_get_sd_xattr(conn, idmap,
+#else
 	pntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,
+#endif
 					    parent, &parent_pntsd);
 	if (pntsd_size <= 0)
 		return -ENOENT;
@@ -1107,6 +1241,7 @@ int smb_inherit_dacl(struct ksmbd_conn *conn,
 		struct smb_acl *pdacl;
 		struct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;
 		int powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;
+		int pntsd_alloc_size;
 
 		if (parent_pntsd->osidoffset) {
 			powner_sid = (struct smb_sid *)((char *)parent_pntsd +
@@ -1119,9 +1254,10 @@ int smb_inherit_dacl(struct ksmbd_conn *conn,
 			pgroup_sid_size = 1 + 1 + 6 + (pgroup_sid->num_subauth * 4);
 		}
 
-		pntsd = kzalloc(sizeof(struct smb_ntsd) + powner_sid_size +
-				pgroup_sid_size + sizeof(struct smb_acl) +
-				nt_size, GFP_KERNEL);
+		pntsd_alloc_size = sizeof(struct smb_ntsd) + powner_sid_size +
+			pgroup_sid_size + sizeof(struct smb_acl) + nt_size;
+
+		pntsd = kzalloc(pntsd_alloc_size, GFP_KERNEL);
 		if (!pntsd) {
 			rc = -ENOMEM;
 			goto free_aces_base;
@@ -1136,6 +1272,27 @@ int smb_inherit_dacl(struct ksmbd_conn *conn,
 		pntsd->gsidoffset = parent_pntsd->gsidoffset;
 		pntsd->dacloffset = parent_pntsd->dacloffset;
 
+		if ((u64)le32_to_cpu(pntsd->osidoffset) + powner_sid_size >
+		    pntsd_alloc_size) {
+			rc = -EINVAL;
+			kfree(pntsd);
+			goto free_aces_base;
+		}
+
+		if ((u64)le32_to_cpu(pntsd->gsidoffset) + pgroup_sid_size >
+		    pntsd_alloc_size) {
+			rc = -EINVAL;
+			kfree(pntsd);
+			goto free_aces_base;
+		}
+
+		if ((u64)le32_to_cpu(pntsd->dacloffset) + sizeof(struct smb_acl) + nt_size >
+		    pntsd_alloc_size) {
+			rc = -EINVAL;
+			kfree(pntsd);
+			goto free_aces_base;
+		}
+
 		if (pntsd->osidoffset) {
 			struct smb_sid *owner_sid = (struct smb_sid *)((char *)pntsd +
 					le32_to_cpu(pntsd->osidoffset));
@@ -1162,8 +1319,12 @@ int smb_inherit_dacl(struct ksmbd_conn *conn,
 			pntsd_size += sizeof(struct smb_acl) + nt_size;
 		}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		ksmbd_vfs_set_sd_xattr(conn, idmap,
+#else
 		ksmbd_vfs_set_sd_xattr(conn, user_ns,
-				       path->dentry, pntsd, pntsd_size);
+#endif
+				       path, pntsd, pntsd_size, false);
 		kfree(pntsd);
 	}
 
@@ -1190,7 +1351,11 @@ bool smb_inherit_flags(int flags, bool is_dir)
 int smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,
 			__le32 *pdaccess, int uid)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	struct smb_ntsd *pntsd = NULL;
 	struct smb_acl *pdacl;
 	struct posix_acl *posix_acls;
@@ -1206,7 +1371,11 @@ int smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,
 	unsigned short ace_size;
 
 	ksmbd_debug(SMB, "check permission using windows acl\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	pntsd_size = ksmbd_vfs_get_sd_xattr(conn, idmap,
+#else
 	pntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,
+#endif
 					    path->dentry, &pntsd);
 	if (pntsd_size <= 0 || !pntsd)
 		goto err_out;
@@ -1289,16 +1458,28 @@ int smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,
 	}
 
 	if (IS_ENABLED(CONFIG_FS_POSIX_ACL)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
 		posix_acls = get_inode_acl(d_inode(path->dentry), ACL_TYPE_ACCESS);
-		if (posix_acls && !found) {
+#else
+		posix_acls = get_acl(d_inode(path->dentry), ACL_TYPE_ACCESS);
+#endif
+		if (!IS_ERR_OR_NULL(posix_acls) && !found) {
 			unsigned int id = -1;
 
 			pa_entry = posix_acls->a_entries;
 			for (i = 0; i < posix_acls->a_count; i++, pa_entry++) {
 				if (pa_entry->e_tag == ACL_USER)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					id = posix_acl_uid_translate(idmap, pa_entry);
+#else
 					id = posix_acl_uid_translate(user_ns, pa_entry);
+#endif
 				else if (pa_entry->e_tag == ACL_GROUP)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+					id = posix_acl_gid_translate(idmap, pa_entry);
+#else
 					id = posix_acl_gid_translate(user_ns, pa_entry);
+#endif
 				else
 					continue;
 
@@ -1314,7 +1495,7 @@ int smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,
 				}
 			}
 		}
-		if (posix_acls)
+		if (!IS_ERR_OR_NULL(posix_acls))
 			posix_acl_release(posix_acls);
 	}
 
@@ -1355,19 +1536,27 @@ int smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,
 
 int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 		 const struct path *path, struct smb_ntsd *pntsd, int ntsd_len,
-		 bool type_check)
+		 bool type_check, bool get_write)
 {
 	int rc;
 	struct smb_fattr fattr = {{0}};
 	struct inode *inode = d_inode(path->dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = mnt_idmap(path->mnt);
+#else
 	struct user_namespace *user_ns = mnt_user_ns(path->mnt);
+#endif
 	struct iattr newattrs;
 
 	fattr.cf_uid = INVALID_UID;
 	fattr.cf_gid = INVALID_GID;
 	fattr.cf_mode = inode->i_mode;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = parse_sec_desc(idmap, pntsd, ntsd_len, &fattr);
+#else
 	rc = parse_sec_desc(user_ns, pntsd, ntsd_len, &fattr);
+#endif
 	if (rc)
 		goto out;
 
@@ -1377,24 +1566,55 @@ int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 		newattrs.ia_uid = fattr.cf_uid;
 	}
 	if (!gid_eq(fattr.cf_gid, INVALID_GID)) {
+		inode->i_gid = fattr.cf_gid;
 		newattrs.ia_valid |= ATTR_GID;
 		newattrs.ia_gid = fattr.cf_gid;
 	}
 	newattrs.ia_valid |= ATTR_MODE;
 	newattrs.ia_mode = (inode->i_mode & ~0777) | (fattr.cf_mode & 0777);
 
-	ksmbd_vfs_remove_acl_xattrs(user_ns, path->dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ksmbd_vfs_remove_acl_xattrs(idmap, path);
+#else
+	ksmbd_vfs_remove_acl_xattrs(user_ns, path);
+#endif
 	/* Update posix acls */
 	if (IS_ENABLED(CONFIG_FS_POSIX_ACL) && fattr.cf_dacls) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = set_posix_acl(idmap, path->dentry,
+#else
 		rc = set_posix_acl(user_ns, path->dentry,
-				   ACL_TYPE_ACCESS, fattr.cf_acls);
+#endif
+#else
+		rc = set_posix_acl(user_ns, inode,
+#endif
+				   ACL_TYPE_ACCESS,
+				   fattr.cf_acls);
+#else
+		rc = set_posix_acl(inode, ACL_TYPE_ACCESS, fattr.cf_acls);
+#endif
 		if (rc < 0)
 			ksmbd_debug(SMB,
 				    "Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\n",
 				    rc);
 		if (S_ISDIR(inode->i_mode) && fattr.cf_dacls) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			rc = set_posix_acl(idmap, path->dentry,
+#else
 			rc = set_posix_acl(user_ns, path->dentry,
+#endif
+#else
+			rc = set_posix_acl(user_ns, inode,
+#endif
 					   ACL_TYPE_DEFAULT, fattr.cf_dacls);
+#else
+			rc = set_posix_acl(inode, ACL_TYPE_DEFAULT,
+					   fattr.cf_dacls);
+#endif
 			if (rc)
 				ksmbd_debug(SMB,
 					    "Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\n",
@@ -1403,7 +1623,15 @@ int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 	}
 
 	inode_lock(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = notify_change(idmap, path->dentry, &newattrs, NULL);
+#else
 	rc = notify_change(user_ns, path->dentry, &newattrs, NULL);
+#endif
+#else
+	rc = notify_change(path->dentry, &newattrs, NULL);
+#endif
 	inode_unlock(inode);
 	if (rc)
 		goto out;
@@ -1414,15 +1642,19 @@ int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 
 	if (test_share_config_flag(tcon->share_conf, KSMBD_SHARE_FLAG_ACL_XATTR)) {
 		/* Update WinACL in xattr */
-		ksmbd_vfs_remove_sd_xattrs(user_ns, path->dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		ksmbd_vfs_remove_sd_xattrs(idmap, path);
+		ksmbd_vfs_set_sd_xattr(conn, idmap,
+#else
+		ksmbd_vfs_remove_sd_xattrs(user_ns, path);
 		ksmbd_vfs_set_sd_xattr(conn, user_ns,
-				       path->dentry, pntsd, ntsd_len);
+#endif
+				       path, pntsd, ntsd_len, get_write);
 	}
 
 out:
 	posix_acl_release(fattr.cf_acls);
 	posix_acl_release(fattr.cf_dacls);
-	mark_inode_dirty(inode);
 	return rc;
 }
 
diff --git a/fs/ksmbd/smbacl.h b/fs/ksmbd/smbacl.h
index 618f2e0236b3..e486fa3dd783 100644
--- a/fs/ksmbd/smbacl.h
+++ b/fs/ksmbd/smbacl.h
@@ -8,10 +8,13 @@
 #ifndef _SMBACL_H
 #define _SMBACL_H
 
+#include <linux/version.h>
 #include <linux/fs.h>
 #include <linux/namei.h>
 #include <linux/posix_acl.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
 #include <linux/mnt_idmapping.h>
+#endif
 
 #include "mgmt/tree_connect.h"
 
@@ -190,9 +193,17 @@ struct posix_acl_state {
 	struct posix_ace_state_array *groups;
 };
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int parse_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,
+#else
 int parse_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
+#endif
 		   int acl_len, struct smb_fattr *fattr);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int build_sec_desc(struct mnt_idmap *idmap, struct smb_ntsd *pntsd,
+#else
 int build_sec_desc(struct user_namespace *user_ns, struct smb_ntsd *pntsd,
+#endif
 		   struct smb_ntsd *ppntsd, int ppntsd_size, int addition_info,
 		   __u32 *secdesclen, struct smb_fattr *fattr);
 int init_acl_state(struct posix_acl_state *state, int cnt);
@@ -207,32 +218,90 @@ int smb_check_perm_dacl(struct ksmbd_conn *conn, const struct path *path,
 			__le32 *pdaccess, int uid);
 int set_info_sec(struct ksmbd_conn *conn, struct ksmbd_tree_connect *tcon,
 		 const struct path *path, struct smb_ntsd *pntsd, int ntsd_len,
-		 bool type_check);
+		 bool type_check, bool get_write);
 void id_to_sid(unsigned int cid, uint sidtype, struct smb_sid *ssid);
 void ksmbd_init_domain(u32 *sub_auth);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static inline uid_t posix_acl_uid_translate(struct mnt_idmap *idmap,
+#else
 static inline uid_t posix_acl_uid_translate(struct user_namespace *mnt_userns,
+#endif
 					    struct posix_acl_entry *pace)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	vfsuid_t vfsuid;
+#else
+	kuid_t kuid;
+#endif
 
 	/* If this is an idmapped mount, apply the idmapping. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0) || \
+    (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 52) && LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsuid = make_vfsuid(idmap, &init_user_ns, pace->e_uid);
+#else
 	vfsuid = make_vfsuid(mnt_userns, &init_user_ns, pace->e_uid);
+#endif
+#else
+	kuid = mapped_kuid_fs(mnt_userns, &init_user_ns, pace->e_uid);
+#endif
+#else
+	kuid = kuid_into_mnt(mnt_userns, pace->e_uid);
+#endif
 
 	/* Translate the kuid into a userspace id ksmbd would see. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	return from_kuid(&init_user_ns, vfsuid_into_kuid(vfsuid));
+#else
+	return from_kuid(&init_user_ns, kuid);
+#endif
+#else
+	return from_kuid(&init_user_ns, pace->e_uid);
+#endif
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static inline gid_t posix_acl_gid_translate(struct mnt_idmap *idmap,
+#else
 static inline gid_t posix_acl_gid_translate(struct user_namespace *mnt_userns,
+#endif
 					    struct posix_acl_entry *pace)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	vfsgid_t vfsgid;
+#else
+	kgid_t kgid;
+#endif
 
 	/* If this is an idmapped mount, apply the idmapping. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0) || \
+    (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 52) && LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	vfsgid = make_vfsgid(idmap, &init_user_ns, pace->e_gid);
+#else
 	vfsgid = make_vfsgid(mnt_userns, &init_user_ns, pace->e_gid);
+#endif
+#else
+	kgid = mapped_kgid_fs(mnt_userns, &init_user_ns, pace->e_gid);
+#endif
+#else
+	kgid = kgid_into_mnt(mnt_userns, pace->e_gid);
+#endif
 
 	/* Translate the kgid into a userspace id ksmbd would see. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
 	return from_kgid(&init_user_ns, vfsgid_into_kgid(vfsgid));
+#else
+	return from_kgid(&init_user_ns, kgid);
+#endif
+#else
+	return from_kgid(&init_user_ns, pace->e_gid);
+#endif
 }
 
 #endif /* _SMBACL_H */
diff --git a/fs/ksmbd/smberr.h b/fs/ksmbd/smberr.h
new file mode 100644
index 000000000000..ce842303ae1f
--- /dev/null
+++ b/fs/ksmbd/smberr.h
@@ -0,0 +1,235 @@
+/* SPDX-License-Identifier: LGPL-2.1+ */
+/*
+ *   Copyright (c) International Business Machines  Corp., 2002,2004
+ *   Author(s): Steve French (sfrench@us.ibm.com)
+ *
+ *   See Error Codes section of the SNIA CIFS Specification
+ *   for more information
+ */
+#ifndef __KSMBD_SMBERR_H
+#define __KSMBD_SMBERR_H
+
+#define SUCCESS	0x00	/* The request was successful. */
+#define ERRDOS	0x01	/* Error is from the core DOS operating system set */
+#define ERRSRV	0x02	/* Error is generated by the file server daemon */
+#define ERRHRD	0x03	/* Error is a hardware error. */
+#define ERRCMD	0xFF	/* Command was not in the "SMB" format. */
+
+/* The following error codes may be generated with the SUCCESS error class.*/
+
+/*#define SUCCESS	0	The request was successful. */
+
+/* The following error codes may be generated with the ERRDOS error class.*/
+
+#define ERRbadfunc		1	/*
+					 * Invalid function. The server did not
+					 * recognize or could not perform a
+					 * system call generated by the server,
+					 * e.g., set the DIRECTORY attribute on
+					 * a data file, invalid seek mode.
+					 */
+#define ERRbadfile		2	/*
+					 * File not found. The last component
+					 * of a file's pathname could not be
+					 * found.
+					 */
+#define ERRbadpath		3	/*
+					 * Directory invalid. A directory
+					 * component in a pathname could not be
+					 * found.
+					 */
+#define ERRnofids		4	/*
+					 * Too many open files. The server has
+					 * no file handles available.
+					 */
+#define ERRnoaccess		5	/*
+					 * Access denied, the client's context
+					 * does not permit the requested
+					 * function. This includes the
+					 * following conditions: invalid rename
+					 * command, write to Fid open for read
+					 * only, read on Fid open for write
+					 * only, attempt to delete a non-empty
+					 * directory
+					 */
+#define ERRbadfid		6	/*
+					 * Invalid file handle. The file handle
+					 * specified was not recognized by the
+					 * server.
+					 */
+#define ERRbadmcb		7	/* Memory control blocks destroyed. */
+#define ERRnomem		8	/*
+					 * Insufficient server memory to
+					 * perform the requested function.
+					 */
+#define ERRbadmem		9	/* Invalid memory block address. */
+#define ERRbadenv		10	/* Invalid environment. */
+#define ERRbadformat		11	/* Invalid format. */
+#define ERRbadaccess		12	/* Invalid open mode. */
+#define ERRbaddata		13	/*
+					 * Invalid data (generated only by
+					 * IOCTL calls within the server).
+					 */
+#define ERRbaddrive		15	/* Invalid drive specified. */
+#define ERRremcd		16	/*
+					 * A Delete Directory request attempted
+					 * to remove the server's current
+					 * directory.
+					 */
+#define ERRdiffdevice		17	/*
+					 * Not same device (e.g., a cross
+					 * volume rename was attempted
+					 */
+#define ERRnofiles		18	/*
+					 * A File Search command can find no
+					 * more files matching the specified
+					 * criteria.
+					 */
+#define ERRwriteprot		19	/* media is write protected */
+#define ERRgeneral		31
+#define ERRbadshare		32	/*
+					 * The sharing mode specified for an
+					 * Open conflicts with existing FIDs on
+					 * the file.
+					 */
+#define ERRlock			33	/*
+					 * A Lock request conflicted with an
+					 * existing lock or specified an
+					 * invalid mode, or an Unlock requested
+					 * attempted to remove a lock held by
+					 * another process.
+					 */
+#define ERRunsup		50
+#define ERRnosuchshare		67
+#define ERRfilexists		80	/*
+					 * The file named in the request
+					 * already exists.
+					 */
+#define ERRinvparm		87
+#define ERRdiskfull		112
+#define ERRinvname		123
+#define ERRinvlevel		124
+#define ERRdirnotempty		145
+#define ERRnotlocked		158
+#define ERRcancelviolation	173
+#define ERRnoatomiclocks	174
+#define ERRalreadyexists	183
+#define ERRbadpipe		230
+#define ERRpipebusy		231
+#define ERRpipeclosing		232
+#define ERRnotconnected		233
+#define ERRmoredata		234
+#define ERReasnotsupported	282
+#define ErrQuota		0x200	/*
+					 * The operation would cause a quota
+					 * limit to be exceeded.
+					 */
+#define ErrNotALink		0x201	/*
+					 * A link operation was performed on a
+					 * pathname that was not a link.
+					 */
+
+/*
+ * Below errors are used internally (do not come over the wire) for passthrough
+ * from STATUS codes to POSIX only
+ */
+#define ERRsymlink              0xFFFD
+#define ErrTooManyLinks         0xFFFE
+
+/* Following error codes may be generated with the ERRSRV error class.*/
+
+#define ERRerror		1	/*
+					 * Non-specific error code. It is
+					 * returned under the following
+					 * conditions: resource other than disk
+					 * space exhausted (e.g. TIDs), first
+					 * SMB command was not negotiate,
+					 * multiple negotiates attempted, and
+					 * internal server error.
+					 */
+#define ERRbadpw		2	/*
+					 * Bad password - name/password pair in
+					 * a TreeConnect or Session Setup are
+					 * invalid.
+					 */
+#define ERRbadtype		3	/*
+					 * used for indicating DFS referral
+					 * needed
+					 */
+#define ERRaccess		4	/*
+					 * The client does not have the
+					 * necessary access rights within the
+					 * specified context for requested
+					 * function.
+					 */
+#define ERRinvtid		5	/*
+					 * The Tid specified in a command was
+					 * invalid.
+					 */
+#define ERRinvnetname		6	/*
+					 * Invalid network name in tree
+					 * connect.
+					 */
+#define ERRinvdevice		7	/*
+					 * Invalid device - printer request
+					 * made to non-printer connection or
+					 * non-printer request made to printer
+					 * connection.
+					 */
+#define ERRqfull		49	/*
+					 * Print queue full (files) -- returned
+					 * by open print file.
+					 */
+#define ERRqtoobig		50	/* Print queue full -- no space. */
+#define ERRqeof			51	/* EOF on print queue dump */
+#define ERRinvpfid		52	/* Invalid print file FID. */
+#define ERRsmbcmd		64	/*
+					 * The server did not recognize the
+					 * command received.
+					 */
+#define ERRsrverror		65	/*
+					 * The server encountered an internal
+					 * error, e.g., system file
+					 * unavailable.
+					 */
+#define ERRbadBID		66	/* (obsolete) */
+#define ERRfilespecs		67	/*
+					 * The Fid and pathname parameters
+					 * contained an invalid combination of
+					 * values.
+					 */
+#define ERRbadLink		68	/* (obsolete) */
+#define ERRbadpermits		69	/*
+					 * The access permissions specified for
+					 * a file or directory are not a valid
+					 * combination.
+					 */
+#define ERRbadPID		70
+#define ERRsetattrmode		71	/* attribute (mode) is invalid */
+#define ERRpaused		81	/* Server is paused */
+#define ERRmsgoff		82	/* reserved - messaging off */
+#define ERRnoroom		83	/* reserved - no room for message */
+#define ERRrmuns		87	/* reserved - too many remote names */
+#define ERRtimeout		88	/* operation timed out */
+#define ERRnoresource		89	/* No resources available for request */
+#define ERRtoomanyuids		90	/*
+					 * Too many UIDs active on this session
+					 */
+#define ERRbaduid		91	/*
+					 * The UID is not known as a valid user
+					 */
+#define ERRusempx		250	/* temporarily unable to use raw */
+#define ERRusestd		251	/*
+					 * temporarily unable to use either raw
+					 * or mpx
+					 */
+#define ERR_NOTIFY_ENUM_DIR	1024
+#define ERRnoSuchUser		2238	/* user account does not exist */
+#define ERRaccountexpired	2239
+#define ERRbadclient		2240	/* can not logon from this client */
+#define ERRbadLogonTime		2241	/* logon hours do not allow this */
+#define ERRpasswordExpired	2242
+#define ERRnetlogonNotStarted	2455
+#define ERRnosupport		0xFFFF
+
+#endif /* __KSMBD_SMBERR_H */
diff --git a/fs/ksmbd/transport_ipc.c b/fs/ksmbd/transport_ipc.c
index 40c721f9227e..fb8e191e8567 100644
--- a/fs/ksmbd/transport_ipc.c
+++ b/fs/ksmbd/transport_ipc.c
@@ -197,7 +197,9 @@ static struct genl_family ksmbd_genl_family = {
 	.module		= THIS_MODULE,
 	.ops		= ksmbd_genl_ops,
 	.n_ops		= ARRAY_SIZE(ksmbd_genl_ops),
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 	.resv_start_op	= KSMBD_EVENT_SPNEGO_AUTHEN_RESPONSE + 1,
+#endif
 };
 
 static void ksmbd_nl_init_fixup(void)
@@ -229,7 +231,7 @@ static struct ksmbd_ipc_msg *ipc_msg_alloc(size_t sz)
 	struct ksmbd_ipc_msg *msg;
 	size_t msg_sz = sz + sizeof(struct ksmbd_ipc_msg);
 
-	msg = kvmalloc(msg_sz, GFP_KERNEL | __GFP_ZERO);
+	msg = kvzalloc(msg_sz, GFP_KERNEL);
 	if (msg)
 		msg->sz = sz;
 	return msg;
@@ -268,7 +270,7 @@ static int handle_response(int type, void *payload, size_t sz)
 			       entry->type + 1, type);
 		}
 
-		entry->response = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);
+		entry->response = kvzalloc(sz, GFP_KERNEL);
 		if (!entry->response) {
 			ret = -ENOMEM;
 			break;
@@ -516,7 +518,6 @@ struct ksmbd_login_response *ksmbd_ipc_login_request(const char *account)
 	req = (struct ksmbd_login_request *)msg->payload;
 	req->handle = ksmbd_acquire_id(&ipc_ida);
 	strscpy(req->account, account, KSMBD_REQ_MAX_ACCOUNT_NAME_SZ);
-
 	resp = ipc_msg_send_request(msg, req->handle);
 	ipc_msg_handle_free(req->handle);
 	ipc_msg_free(msg);
diff --git a/fs/ksmbd/transport_rdma.c b/fs/ksmbd/transport_rdma.c
index c06efc020bd9..cf559498a2d3 100644
--- a/fs/ksmbd/transport_rdma.c
+++ b/fs/ksmbd/transport_rdma.c
@@ -201,7 +201,7 @@ struct smb_direct_rdma_rw_msg {
 	struct list_head	list;
 	struct rdma_rw_ctx	rw_ctx;
 	struct sg_table		sgt;
-	struct scatterlist	sg_list[];
+	struct scatterlist	sg_list[0];
 };
 
 void init_smbd_max_io_size(unsigned int sz)
@@ -217,8 +217,8 @@ unsigned int get_smbd_max_read_write_size(void)
 
 static inline int get_buf_page_count(void *buf, int size)
 {
-	return DIV_ROUND_UP((uintptr_t)buf + size, PAGE_SIZE) -
-		(uintptr_t)buf / PAGE_SIZE;
+	return (int)(DIV_ROUND_UP((uintptr_t)buf + size, PAGE_SIZE) -
+		     (uintptr_t)buf / PAGE_SIZE);
 }
 
 static void smb_direct_destroy_pools(struct smb_direct_transport *transport);
@@ -1241,14 +1241,12 @@ static int smb_direct_writev(struct ksmbd_transport *t,
 
 	//FIXME: skip RFC1002 header..
 	buflen -= 4;
-	iov[0].iov_base += 4;
-	iov[0].iov_len -= 4;
 
 	remaining_data_length = buflen;
 	ksmbd_debug(RDMA, "Sending smb (RDMA): smb_len=%u\n", buflen);
 
 	smb_direct_send_ctx_init(st, &send_ctx, need_invalidate, remote_key);
-	start = i = 0;
+	start = i = 1;
 	buflen = 0;
 	while (true) {
 		buflen += iov[i].iov_len;
@@ -1366,24 +1364,35 @@ static int smb_direct_rdma_xmit(struct smb_direct_transport *t,
 	LIST_HEAD(msg_list);
 	char *desc_buf;
 	int credits_needed;
-	unsigned int desc_buf_len;
-	size_t total_length = 0;
+	unsigned int desc_buf_len, desc_num = 0;
 
 	if (t->status != SMB_DIRECT_CS_CONNECTED)
 		return -ENOTCONN;
 
+	if (buf_len > t->max_rdma_rw_size)
+		return -EINVAL;
+
 	/* calculate needed credits */
 	credits_needed = 0;
 	desc_buf = buf;
 	for (i = 0; i < desc_len / sizeof(*desc); i++) {
+		if (!buf_len)
+			break;
+
 		desc_buf_len = le32_to_cpu(desc[i].length);
+		if (!desc_buf_len)
+			return -EINVAL;
+
+		if (desc_buf_len > buf_len) {
+			desc_buf_len = buf_len;
+			desc[i].length = cpu_to_le32(desc_buf_len);
+			buf_len = 0;
+		}
 
 		credits_needed += calc_rw_credits(t, desc_buf, desc_buf_len);
 		desc_buf += desc_buf_len;
-		total_length += desc_buf_len;
-		if (desc_buf_len == 0 || total_length > buf_len ||
-		    total_length > t->max_rdma_rw_size)
-			return -EINVAL;
+		buf_len -= desc_buf_len;
+		desc_num++;
 	}
 
 	ksmbd_debug(RDMA, "RDMA %s, len %#x, needed credits %#x\n",
@@ -1395,7 +1404,7 @@ static int smb_direct_rdma_xmit(struct smb_direct_transport *t,
 
 	/* build rdma_rw_ctx for each descriptor */
 	desc_buf = buf;
-	for (i = 0; i < desc_len / sizeof(*desc); i++) {
+	for (i = 0; i < desc_num; i++) {
 		msg = kzalloc(offsetof(struct smb_direct_rdma_rw_msg, sg_list) +
 			      sizeof(struct scatterlist) * SG_CHUNK_SIZE, GFP_KERNEL);
 		if (!msg) {
@@ -1703,11 +1712,11 @@ static int smb_direct_init_params(struct smb_direct_transport *t,
 	int max_send_sges, max_rw_wrs, max_send_wrs;
 	unsigned int max_sge_per_wr, wrs_per_credit;
 
-	/* need 3 more sge. because a SMB_DIRECT header, SMB2 header,
-	 * SMB2 response could be mapped.
+	/* need 2 more sge. because a SMB_DIRECT header will be mapped,
+	 * and maybe a send buffer could be not page aligned.
 	 */
 	t->max_send_size = smb_direct_max_send_size;
-	max_send_sges = DIV_ROUND_UP(t->max_send_size, PAGE_SIZE) + 3;
+	max_send_sges = DIV_ROUND_UP(t->max_send_size, PAGE_SIZE) + 2;
 	if (max_send_sges > SMB_DIRECT_MAX_SEND_SGES) {
 		pr_err("max_send_size %d is too large\n", t->max_send_size);
 		return -EINVAL;
@@ -1728,8 +1737,6 @@ static int smb_direct_init_params(struct smb_direct_transport *t,
 
 	max_sge_per_wr = min_t(unsigned int, device->attrs.max_send_sge,
 			       device->attrs.max_sge_rd);
-	max_sge_per_wr = max_t(unsigned int, max_sge_per_wr,
-			       max_send_sges);
 	wrs_per_credit = max_t(unsigned int, 4,
 			       DIV_ROUND_UP(t->pages_per_rw_credit,
 					    max_sge_per_wr) + 1);
@@ -1754,6 +1761,11 @@ static int smb_direct_init_params(struct smb_direct_transport *t,
 		return -EINVAL;
 	}
 
+	if (device->attrs.max_send_sge < SMB_DIRECT_MAX_SEND_SGES) {
+		pr_err("warning: device max_send_sge = %d too small\n",
+		       device->attrs.max_send_sge);
+		return -EINVAL;
+	}
 	if (device->attrs.max_recv_sge < SMB_DIRECT_MAX_RECV_SGES) {
 		pr_err("warning: device max_recv_sge = %d too small\n",
 		       device->attrs.max_recv_sge);
@@ -1862,7 +1874,9 @@ static int smb_direct_create_qpair(struct smb_direct_transport *t,
 {
 	int ret;
 	struct ib_qp_init_attr qp_attr;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0)
 	int pages_per_rw;
+#endif
 
 	t->pd = ib_alloc_pd(t->cm_id->device, 0);
 	if (IS_ERR(t->pd)) {
@@ -1910,8 +1924,10 @@ static int smb_direct_create_qpair(struct smb_direct_transport *t,
 	t->qp = t->cm_id->qp;
 	t->cm_id->event_handler = smb_direct_cm_handler;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0)
 	pages_per_rw = DIV_ROUND_UP(t->max_rdma_rw_size, PAGE_SIZE) + 1;
 	if (pages_per_rw > t->cm_id->device->attrs.max_sgl_rd) {
+#endif
 		ret = ib_mr_pool_init(t->qp, &t->qp->rdma_mrs,
 				      t->max_rw_credits, IB_MR_TYPE_MEM_REG,
 				      t->pages_per_rw_credit, 0);
@@ -1920,8 +1936,9 @@ static int smb_direct_create_qpair(struct smb_direct_transport *t,
 			       t->max_rw_credits, t->pages_per_rw_credit);
 			goto err;
 		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 5, 0)
 	}
-
+#endif
 	return 0;
 err:
 	if (t->qp) {
@@ -2123,7 +2140,11 @@ static int smb_direct_listen(int port)
 	return ret;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
 static int smb_direct_ib_client_add(struct ib_device *ib_dev)
+#else
+static void smb_direct_ib_client_add(struct ib_device *ib_dev)
+#endif
 {
 	struct smb_direct_device *smb_dev;
 
@@ -2131,13 +2152,20 @@ static int smb_direct_ib_client_add(struct ib_device *ib_dev)
 	if (ib_dev->node_type != RDMA_NODE_IB_CA)
 		smb_direct_port = SMB_DIRECT_PORT_IWARP;
 
-	if (!ib_dev->ops.get_netdev ||
-	    !rdma_frwr_is_supported(&ib_dev->attrs))
+	if (!rdma_frwr_is_supported(&ib_dev->attrs))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
 		return 0;
+#else
+		return;
+#endif
 
 	smb_dev = kzalloc(sizeof(*smb_dev), GFP_KERNEL);
 	if (!smb_dev)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
 		return -ENOMEM;
+#else
+		return;
+#endif
 	smb_dev->ib_dev = ib_dev;
 
 	write_lock(&smb_direct_device_lock);
@@ -2145,7 +2173,11 @@ static int smb_direct_ib_client_add(struct ib_device *ib_dev)
 	write_unlock(&smb_direct_device_lock);
 
 	ksmbd_debug(RDMA, "ib device added: name %s\n", ib_dev->name);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
 	return 0;
+#else
+	return;
+#endif
 }
 
 static void smb_direct_ib_client_remove(struct ib_device *ib_dev,
@@ -2232,17 +2264,38 @@ bool ksmbd_rdma_capable_netdev(struct net_device *netdev)
 		for (i = 0; i < smb_dev->ib_dev->phys_port_cnt; i++) {
 			struct net_device *ndev;
 
-			ndev = smb_dev->ib_dev->ops.get_netdev(smb_dev->ib_dev,
-							       i + 1);
-			if (!ndev)
-				continue;
+			if (smb_dev->ib_dev->ops.get_netdev) {
+				ndev = smb_dev->ib_dev->ops.get_netdev(
+					smb_dev->ib_dev, i + 1);
+				if (!ndev)
+					continue;
 
-			if (ndev == netdev) {
+				if (ndev == netdev) {
+					dev_put(ndev);
+					rdma_capable = true;
+					goto out;
+				}
 				dev_put(ndev);
-				rdma_capable = true;
-				goto out;
+			/* if ib_dev does not implement ops.get_netdev
+			 * check for matching infiniband GUID in hw_addr
+			 */
+			} else if (netdev->type == ARPHRD_INFINIBAND) {
+				struct netdev_hw_addr *ha;
+				union ib_gid gid;
+				u32 port_num;
+				int ret;
+
+				netdev_hw_addr_list_for_each(
+					ha, &netdev->dev_addrs) {
+					memcpy(&gid, ha->addr + 4, sizeof(gid));
+					ret = ib_find_gid(smb_dev->ib_dev, &gid,
+							  &port_num, NULL);
+					if (!ret) {
+						rdma_capable = true;
+						goto out;
+					}
+				}
 			}
-			dev_put(ndev);
 		}
 	}
 out:
diff --git a/fs/ksmbd/transport_tcp.c b/fs/ksmbd/transport_tcp.c
index eff7a1d793f0..b5db6b4652a2 100644
--- a/fs/ksmbd/transport_tcp.c
+++ b/fs/ksmbd/transport_tcp.c
@@ -48,27 +48,55 @@ static struct interface *alloc_iface(char *ifname);
 
 static inline void ksmbd_tcp_nodelay(struct socket *sock)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 8, 0)
+	int val = 1;
+
+	kernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&val,
+			  sizeof(val));
+#else
 	tcp_sock_set_nodelay(sock->sk);
+#endif
 }
 
 static inline void ksmbd_tcp_reuseaddr(struct socket *sock)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 8, 0)
+	int val = 1;
+
+	kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&val,
+			  sizeof(val));
+#else
 	sock_set_reuseaddr(sock->sk);
+#endif
 }
 
 static inline void ksmbd_tcp_rcv_timeout(struct socket *sock, s64 secs)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 8, 0)
+	struct __kernel_old_timeval tv = { .tv_sec = secs, .tv_usec = 0 };
+
+	kernel_setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO_OLD, (char *)&tv,
+			  sizeof(tv));
+#else
 	lock_sock(sock->sk);
 	if (secs && secs < MAX_SCHEDULE_TIMEOUT / HZ - 1)
 		sock->sk->sk_rcvtimeo = secs * HZ;
 	else
 		sock->sk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;
 	release_sock(sock->sk);
+#endif
 }
 
 static inline void ksmbd_tcp_snd_timeout(struct socket *sock, s64 secs)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 8, 0)
+	struct __kernel_old_timeval tv = { .tv_sec = secs, .tv_usec = 0 };
+
+	kernel_setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO_OLD, (char *)&tv,
+			  sizeof(tv));
+#else
 	sock_set_sndtimeo(sock->sk, secs);
+#endif
 }
 
 static struct tcp_transport *alloc_transport(struct socket *client_sk)
@@ -193,12 +221,12 @@ static int ksmbd_tcp_new_connection(struct socket *client_sk)
 	}
 
 	csin = KSMBD_TCP_PEER_SOCKADDR(KSMBD_TRANS(t)->conn);
+
 	if (kernel_getpeername(client_sk, csin) < 0) {
 		pr_err("client ip resolution failed\n");
 		rc = -EINVAL;
 		goto out_error;
 	}
-
 	KSMBD_TRANS(t)->handler = kthread_run(ksmbd_conn_handler_loop,
 					      KSMBD_TRANS(t)->conn,
 					      "ksmbd:%u",
@@ -450,11 +478,23 @@ static int create_socket(struct interface *iface)
 	ksmbd_tcp_nodelay(ksmbd_socket);
 	ksmbd_tcp_reuseaddr(ksmbd_socket);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 8, 0)
+	ret = kernel_setsockopt(ksmbd_socket,
+				SOL_SOCKET,
+				SO_BINDTODEVICE,
+				iface->name,
+				strlen(iface->name));
+#else
 	ret = sock_setsockopt(ksmbd_socket,
 			      SOL_SOCKET,
 			      SO_BINDTODEVICE,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
+			      (char __user *)iface->name,
+#else
 			      KERNEL_SOCKPTR(iface->name),
+#endif
 			      strlen(iface->name));
+#endif
 	if (ret != -ENODEV && ret < 0) {
 		pr_err("Failed to set SO_BINDTODEVICE: %d\n", ret);
 		goto out_error;
@@ -506,7 +546,7 @@ static int ksmbd_netdev_event(struct notifier_block *nb, unsigned long event,
 
 	switch (event) {
 	case NETDEV_UP:
-		if (netif_is_bridge_port(netdev))
+		if (netdev->priv_flags & IFF_BRIDGE_PORT)
 			return NOTIFY_OK;
 
 		list_for_each_entry(iface, &iface_list, entry) {
@@ -615,7 +655,7 @@ int ksmbd_tcp_set_interfaces(char *ifc_list, int ifc_list_sz)
 
 		rtnl_lock();
 		for_each_netdev(&init_net, netdev) {
-			if (netif_is_bridge_port(netdev))
+			if (netdev->priv_flags & IFF_BRIDGE_PORT)
 				continue;
 			if (!alloc_iface(kstrdup(netdev->name, GFP_KERNEL)))
 				return -ENOMEM;
diff --git a/fs/ksmbd/unicode.c b/fs/ksmbd/unicode.c
index a0db699ddafd..b4fd44d6e2aa 100644
--- a/fs/ksmbd/unicode.c
+++ b/fs/ksmbd/unicode.c
@@ -14,46 +14,28 @@
 #include "uniupr.h"
 #include "smb_common.h"
 
-/*
- * smb_utf16_bytes() - how long will a string be after conversion?
- * @from:	pointer to input string
- * @maxbytes:	don't go past this many bytes of input string
- * @codepage:	destination codepage
- *
- * Walk a utf16le string and return the number of bytes that the string will
- * be after being converted to the given charset, not including any null
- * termination required. Don't walk past maxbytes in the source buffer.
- *
- * Return:	string length after conversion
- */
-static int smb_utf16_bytes(const __le16 *from, int maxbytes,
-			   const struct nls_table *codepage)
+#ifdef CONFIG_SMB_INSECURE_SERVER
+int smb1_utf16_name_length(const __le16 *from, int maxbytes)
 {
-	int i;
-	int charlen, outlen = 0;
+	int i, len = 0;
 	int maxwords = maxbytes / 2;
-	char tmp[NLS_MAX_CHARSET_SIZE];
 	__u16 ftmp;
 
 	for (i = 0; i < maxwords; i++) {
 		ftmp = get_unaligned_le16(&from[i]);
+		len += 2;
 		if (ftmp == 0)
 			break;
-
-		charlen = codepage->uni2char(ftmp, tmp, NLS_MAX_CHARSET_SIZE);
-		if (charlen > 0)
-			outlen += charlen;
-		else
-			outlen++;
 	}
 
-	return outlen;
+	return len;
 }
+#endif
 
 /*
  * cifs_mapchar() - convert a host-endian char to proper char in codepage
  * @target:	where converted character should be copied
- * @src_char:	2 byte host-endian source character
+ * @from:	host-endian source string
  * @cp:		codepage to which character should be converted
  * @mapchar:	should character be mapped according to mapchars mount option?
  *
@@ -64,10 +46,13 @@ static int smb_utf16_bytes(const __le16 *from, int maxbytes,
  * Return:	string length after conversion
  */
 static int
-cifs_mapchar(char *target, const __u16 src_char, const struct nls_table *cp,
+cifs_mapchar(char *target, const __u16 *from, const struct nls_table *cp,
 	     bool mapchar)
 {
 	int len = 1;
+	__u16 src_char;
+
+	src_char = *from;
 
 	if (!mapchar)
 		goto cp_convert;
@@ -105,12 +90,66 @@ cifs_mapchar(char *target, const __u16 src_char, const struct nls_table *cp,
 
 cp_convert:
 	len = cp->uni2char(src_char, target, NLS_MAX_CHARSET_SIZE);
-	if (len <= 0) {
-		*target = '?';
-		len = 1;
-	}
+	if (len <= 0)
+		goto surrogate_pair;
 
 	goto out;
+
+surrogate_pair:
+	/* convert SURROGATE_PAIR and IVS */
+	if (strcmp(cp->charset, "utf8"))
+		goto unknown;
+	len = utf16s_to_utf8s(from, 3, UTF16_LITTLE_ENDIAN, target, 6);
+	if (len <= 0)
+		goto unknown;
+	return len;
+
+unknown:
+	*target = '?';
+	len = 1;
+	goto out;
+}
+
+/*
+ * smb_utf16_bytes() - compute converted string length
+ * @from:	pointer to input string
+ * @maxbytes:	input string length
+ * @codepage:	destination codepage
+ *
+ * Walk a utf16le string and return the number of bytes that the string will
+ * be after being converted to the given charset, not including any null
+ * termination required. Don't walk past maxbytes in the source buffer.
+ *
+ * Return:	string length after conversion
+ */
+static int smb_utf16_bytes(const __le16 *from, int maxbytes,
+			   const struct nls_table *codepage)
+{
+	int i, j;
+	int charlen, outlen = 0;
+	int maxwords = maxbytes / 2;
+	char tmp[NLS_MAX_CHARSET_SIZE];
+	__u16 ftmp[3];
+
+	for (i = 0; i < maxwords; i++) {
+		ftmp[0] = get_unaligned_le16(&from[i]);
+		if (ftmp[0] == 0)
+			break;
+		for (j = 1; j <= 2; j++) {
+			if (i + j < maxwords)
+				ftmp[j] = get_unaligned_le16(&from[i + j]);
+			else
+				ftmp[j] = 0;
+		}
+
+		charlen = cifs_mapchar(tmp, ftmp, codepage, 0);
+		if (charlen > 0)
+			outlen += charlen;
+		else
+			outlen++;
+	}
+
+	return outlen;
 }
 
 /*
@@ -158,12 +197,12 @@ static inline int is_char_allowed(char *ch)
 static int smb_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,
 			  const struct nls_table *codepage, bool mapchar)
 {
-	int i, charlen, safelen;
+	int i, j, charlen, safelen;
 	int outlen = 0;
 	int nullsize = nls_nullsize(codepage);
 	int fromwords = fromlen / 2;
 	char tmp[NLS_MAX_CHARSET_SIZE];
-	__u16 ftmp;
+	__u16 ftmp[3];	/* ftmp[3] = 3array x 2bytes = 6bytes UTF-16 */
 
 	/*
 	 * because the chars can be of varying widths, we need to take care
@@ -174,9 +213,15 @@ static int smb_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,
 	safelen = tolen - (NLS_MAX_CHARSET_SIZE + nullsize);
 
 	for (i = 0; i < fromwords; i++) {
-		ftmp = get_unaligned_le16(&from[i]);
-		if (ftmp == 0)
+		ftmp[0] = get_unaligned_le16(&from[i]);
+		if (ftmp[0] == 0)
 			break;
+		for (j = 1; j <= 2; j++) {
+			if (i + j < fromwords)
+				ftmp[j] = get_unaligned_le16(&from[i + j]);
+			else
+				ftmp[j] = 0;
+		}
 
 		/*
 		 * check to see if converting this character might make the
@@ -191,6 +236,19 @@ static int smb_from_utf16(char *to, const __le16 *from, int tolen, int fromlen,
 		/* put converted char into 'to' buffer */
 		charlen = cifs_mapchar(&to[outlen], ftmp, codepage, mapchar);
 		outlen += charlen;
+
+		/*
+		 * charlen (=bytes of UTF-8 for 1 character)
+		 * 4bytes UTF-8(surrogate pair) is charlen=4
+		 * (4bytes UTF-16 code)
+		 * 7-8bytes UTF-8(IVS) is charlen=3+4 or 4+4
+		 * (2 UTF-8 pairs divided to 2 UTF-16 pairs)
+		 */
+		if (charlen == 4)
+			i++;
+		else if (charlen >= 5)
+			/* 5-6bytes UTF-8 */
+			i += 2;
 	}
 
 	/* properly null-terminate string */
@@ -325,6 +383,9 @@ int smbConvertToUTF16(__le16 *target, const char *source, int srclen,
 	char src_char;
 	__le16 dst_char;
 	wchar_t tmp;
+	wchar_t wchar_to[6];	/* UTF-16 */
+	int ret;
+	unicode_t u;
 
 	if (!mapchars)
 		return smb_strtoUTF16(target, source, srclen, cp);
@@ -367,11 +428,57 @@ int smbConvertToUTF16(__le16 *target, const char *source, int srclen,
 			 * if no match, use question mark, which at least in
 			 * some cases serves as wild card
 			 */
-			if (charlen < 1) {
-				dst_char = cpu_to_le16(0x003f);
-				charlen = 1;
+			if (charlen > 0)
+				goto ctoUTF16;
+
+			/* convert SURROGATE_PAIR */
+			if (strcmp(cp->charset, "utf8"))
+				goto unknown;
+			if (*(source + i) & 0x80) {
+				charlen = utf8_to_utf32(source + i, 6, &u);
+				if (charlen < 0)
+					goto unknown;
+			} else
+				goto unknown;
+			ret  = utf8s_to_utf16s(source + i, charlen,
+					UTF16_LITTLE_ENDIAN,
+					wchar_to, 6);
+			if (ret < 0)
+				goto unknown;
+
+			i += charlen;
+			dst_char = cpu_to_le16(*wchar_to);
+			if (charlen <= 3)
+				/* 1-3bytes UTF-8 to 2bytes UTF-16 */
+				put_unaligned(dst_char, &target[j]);
+			else if (charlen == 4) {
+				/*
+				 * 4bytes UTF-8(surrogate pair) to 4bytes UTF-16
+				 * 7-8bytes UTF-8(IVS) divided to 2 UTF-16
+				 * (charlen=3+4 or 4+4)
+				 */
+				put_unaligned(dst_char, &target[j]);
+				dst_char = cpu_to_le16(*(wchar_to + 1));
+				j++;
+				put_unaligned(dst_char, &target[j]);
+			} else if (charlen >= 5) {
+				/* 5-6bytes UTF-8 to 6bytes UTF-16 */
+				put_unaligned(dst_char, &target[j]);
+				dst_char = cpu_to_le16(*(wchar_to + 1));
+				j++;
+				put_unaligned(dst_char, &target[j]);
+				dst_char = cpu_to_le16(*(wchar_to + 2));
+				j++;
+				put_unaligned(dst_char, &target[j]);
 			}
+			continue;
+
+unknown:
+			dst_char = cpu_to_le16(0x003f);
+			charlen = 1;
 		}
+
+ctoUTF16:
 		/*
 		 * character may take more than one byte in the source string,
 		 * but will take exactly two bytes in the target string
diff --git a/fs/ksmbd/unicode.h b/fs/ksmbd/unicode.h
index 076f6034a789..9252b68f35bb 100644
--- a/fs/ksmbd/unicode.h
+++ b/fs/ksmbd/unicode.h
@@ -63,6 +63,9 @@ extern const struct UniCaseRange CifsUniLowerRange[];
 #endif				/* UNIUPR_NOLOWER */
 
 #ifdef __KERNEL__
+#ifdef CONFIG_SMB_INSECURE_SERVER
+int smb1_utf16_name_length(const __le16 *from, int maxbytes);
+#endif
 int smb_strtoUTF16(__le16 *to, const char *from, int len,
 		   const struct nls_table *codepage);
 char *smb_strndup_from_utf16(const char *src, const int maxlen,
diff --git a/fs/ksmbd/vfs.c b/fs/ksmbd/vfs.c
index ff0e7a4fcd4d..826028bca5b5 100644
--- a/fs/ksmbd/vfs.c
+++ b/fs/ksmbd/vfs.c
@@ -6,19 +6,28 @@
 
 #include <linux/kernel.h>
 #include <linux/fs.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#include <linux/filelock.h>
+#endif
 #include <linux/uaccess.h>
 #include <linux/backing-dev.h>
 #include <linux/writeback.h>
 #include <linux/xattr.h>
 #include <linux/falloc.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 18, 0)
+#include <linux/genhd.h>
+#endif
 #include <linux/fsnotify.h>
 #include <linux/dcache.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
-#include <linux/sched/xacct.h>
 #include <linux/crc32c.h>
-
-#include "../internal.h"	/* for vfs_path_lookup */
+#include <linux/sched/xacct.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+#include <linux/namei.h>
+#endif
+#include <linux/mount.h>
 
 #include "glob.h"
 #include "oplock.h"
@@ -36,6 +45,12 @@
 #include "mgmt/user_session.h"
 #include "mgmt/user_config.h"
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
+			   const char *, unsigned int, struct path *);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
 static char *extract_last_component(char *path)
 {
 	char *p = strrchr(path, '/');
@@ -48,6 +63,7 @@ static char *extract_last_component(char *path)
 	}
 	return p;
 }
+#endif
 
 static void ksmbd_vfs_inherit_owner(struct ksmbd_work *work,
 				    struct inode *parent_inode,
@@ -60,6 +76,96 @@ static void ksmbd_vfs_inherit_owner(struct ksmbd_work *work,
 	i_uid_write(inode, i_uid_read(parent_inode));
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+/**
+ * ksmbd_vfs_lock_parent() - lock parent dentry if it is stable
+ */
+int ksmbd_vfs_lock_parent(struct dentry *parent, struct dentry *child)
+{
+	inode_lock_nested(d_inode(parent), I_MUTEX_PARENT);
+	if (child->d_parent != parent) {
+		inode_unlock(d_inode(parent));
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+static int ksmbd_vfs_path_lookup_locked(struct ksmbd_share_config *share_conf,
+					char *pathname, unsigned int flags,
+					struct path *parent_path,
+					struct path *path)
+{
+	struct qstr last;
+	struct filename *filename;
+	struct path *root_share_path = &share_conf->vfs_path;
+	int err, type;
+	struct dentry *d;
+
+	if (pathname[0] == '\0') {
+		pathname = share_conf->path;
+		root_share_path = NULL;
+	} else {
+		flags |= LOOKUP_BENEATH;
+	}
+
+	filename = getname_kernel(pathname);
+	if (IS_ERR(filename))
+		return PTR_ERR(filename);
+
+	err = vfs_path_parent_lookup(filename, flags,
+				     parent_path, &last, &type,
+				     root_share_path);
+	if (err) {
+		putname(filename);
+		return err;
+	}
+
+	if (unlikely(type != LAST_NORM)) {
+		path_put(parent_path);
+		putname(filename);
+		return -ENOENT;
+	}
+
+	err = mnt_want_write(parent_path->mnt);
+	if (err) {
+		path_put(parent_path);
+		putname(filename);
+		return -ENOENT;
+	}
+
+	inode_lock_nested(parent_path->dentry->d_inode, I_MUTEX_PARENT);
+	d = lookup_one_qstr_excl(&last, parent_path->dentry, 0);
+	if (IS_ERR(d))
+		goto err_out;
+
+	if (d_is_negative(d)) {
+		dput(d);
+		goto err_out;
+	}
+
+	path->dentry = d;
+	path->mnt = mntget(parent_path->mnt);
+
+	if (test_share_config_flag(share_conf, KSMBD_SHARE_FLAG_CROSSMNT)) {
+		err = follow_down(path, 0);
+		if (err < 0) {
+			path_put(path);
+			goto err_out;
+		}
+	}
+
+	putname(filename);
+	return 0;
+
+err_out:
+	inode_unlock(d_inode(parent_path->dentry));
+	mnt_drop_write(parent_path->mnt);
+	path_put(parent_path);
+	putname(filename);
+	return -ENOENT;
+}
+#else
 /**
  * ksmbd_vfs_lock_parent() - lock parent dentry if it is stable
  *
@@ -69,15 +175,28 @@ static void ksmbd_vfs_inherit_owner(struct ksmbd_work *work,
  *
  * the reference count of @parent isn't incremented.
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_lock_parent(struct mnt_idmap *idmap, struct dentry *parent,
+#else
 int ksmbd_vfs_lock_parent(struct user_namespace *user_ns, struct dentry *parent,
+#endif
 			  struct dentry *child)
 {
 	struct dentry *dentry;
 	int ret = 0;
 
 	inode_lock_nested(d_inode(parent), I_MUTEX_PARENT);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	dentry = lookup_one(idmap, child->d_name.name, parent,
+#else
 	dentry = lookup_one(user_ns, child->d_name.name, parent,
+#endif
 			    child->d_name.len);
+#else
+	dentry = lookup_one_len(child->d_name.name, parent,
+				child->d_name.len);
+#endif
 	if (IS_ERR(dentry)) {
 		ret = PTR_ERR(dentry);
 		goto out_err;
@@ -95,29 +214,74 @@ int ksmbd_vfs_lock_parent(struct user_namespace *user_ns, struct dentry *parent,
 	inode_unlock(d_inode(parent));
 	return ret;
 }
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_may_delete(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_may_delete(struct user_namespace *user_ns,
+#endif
 			 struct dentry *dentry)
 {
 	struct dentry *parent;
 	int ret;
 
 	parent = dget_parent(dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ret = ksmbd_vfs_lock_parent(idmap, parent, dentry);
+#else
 	ret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);
+#endif
 	if (ret) {
 		dput(parent);
 		return ret;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ret = inode_permission(idmap, d_inode(parent),
+#else
 	ret = inode_permission(user_ns, d_inode(parent),
+#endif
 			       MAY_EXEC | MAY_WRITE);
+#else
+	ret = inode_permission(d_inode(parent), MAY_EXEC | MAY_WRITE);
+#endif
 
 	inode_unlock(d_inode(parent));
 	dput(parent);
 	return ret;
 }
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+void ksmbd_vfs_query_maximal_access(struct mnt_idmap *idmap,
+				   struct dentry *dentry, __le32 *daccess)
+{
+	*daccess = cpu_to_le32(FILE_READ_ATTRIBUTES | READ_CONTROL);
+
+	if (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_WRITE))
+		*daccess |= cpu_to_le32(WRITE_DAC | WRITE_OWNER | SYNCHRONIZE |
+				FILE_WRITE_DATA | FILE_APPEND_DATA |
+				FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES |
+				FILE_DELETE_CHILD);
+
+	if (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_READ))
+		*daccess |= FILE_READ_DATA_LE | FILE_READ_EA_LE;
+
+	if (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_EXEC))
+		*daccess |= FILE_EXECUTE_LE;
 
+	if (!inode_permission(idmap, d_inode(dentry->d_parent), MAY_EXEC | MAY_WRITE))
+		*daccess |= FILE_DELETE_LE;
+}
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_query_maximal_access(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_query_maximal_access(struct user_namespace *user_ns,
+#endif
 				   struct dentry *dentry, __le32 *daccess)
 {
 	struct dentry *parent;
@@ -125,32 +289,69 @@ int ksmbd_vfs_query_maximal_access(struct user_namespace *user_ns,
 
 	*daccess = cpu_to_le32(FILE_READ_ATTRIBUTES | READ_CONTROL);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	if (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_WRITE))
+#else
 	if (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_WRITE))
+#endif
+#else
+	if (!inode_permission(d_inode(dentry), MAY_OPEN | MAY_WRITE))
+#endif
 		*daccess |= cpu_to_le32(WRITE_DAC | WRITE_OWNER | SYNCHRONIZE |
 				FILE_WRITE_DATA | FILE_APPEND_DATA |
 				FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES |
 				FILE_DELETE_CHILD);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	if (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_READ))
+#else
 	if (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_READ))
+#endif
+#else
+	if (!inode_permission(d_inode(dentry), MAY_OPEN | MAY_READ))
+#endif
 		*daccess |= FILE_READ_DATA_LE | FILE_READ_EA_LE;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	if (!inode_permission(idmap, d_inode(dentry), MAY_OPEN | MAY_EXEC))
+#else
 	if (!inode_permission(user_ns, d_inode(dentry), MAY_OPEN | MAY_EXEC))
+#endif
+#else
+	if (!inode_permission(d_inode(dentry), MAY_OPEN | MAY_EXEC))
+#endif
 		*daccess |= FILE_EXECUTE_LE;
 
 	parent = dget_parent(dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	ret = ksmbd_vfs_lock_parent(idmap, parent, dentry);
+#else
 	ret = ksmbd_vfs_lock_parent(user_ns, parent, dentry);
+#endif
 	if (ret) {
 		dput(parent);
 		return ret;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	if (!inode_permission(idmap, d_inode(parent), MAY_EXEC | MAY_WRITE))
+#else
 	if (!inode_permission(user_ns, d_inode(parent), MAY_EXEC | MAY_WRITE))
+#endif
+#else
+	if (!inode_permission(d_inode(parent), MAY_EXEC | MAY_WRITE))
+#endif
 		*daccess |= FILE_DELETE_LE;
 
 	inode_unlock(d_inode(parent));
 	dput(parent);
 	return ret;
 }
+#endif
 
 /**
  * ksmbd_vfs_create() - vfs helper for smb create file
@@ -177,14 +378,24 @@ int ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode)
 	}
 
 	mode |= S_IFREG;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_create(mnt_idmap(path.mnt), d_inode(path.dentry),
+			 dentry, mode, true);
+#else
 	err = vfs_create(mnt_user_ns(path.mnt), d_inode(path.dentry),
 			 dentry, mode, true);
+#endif
+#else
+	err = vfs_create(d_inode(path.dentry), dentry, mode, true);
+#endif
 	if (!err) {
 		ksmbd_vfs_inherit_owner(work, d_inode(path.dentry),
 					d_inode(dentry));
 	} else {
 		pr_err("File(%s): creation failed (err:%d)\n", name, err);
 	}
+
 	done_path_create(&path, dentry);
 	return err;
 }
@@ -199,7 +410,11 @@ int ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode)
  */
 int ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct path path;
 	struct dentry *dentry;
 	int err;
@@ -215,37 +430,61 @@ int ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode)
 		return err;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = mnt_idmap(path.mnt);
+#else
 	user_ns = mnt_user_ns(path.mnt);
+#endif
 	mode |= S_IFDIR;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_mkdir(idmap, d_inode(path.dentry), dentry, mode);
+#else
 	err = vfs_mkdir(user_ns, d_inode(path.dentry), dentry, mode);
-	if (err) {
-		goto out;
-	} else if (d_unhashed(dentry)) {
+#endif
+#else
+	err = vfs_mkdir(d_inode(path.dentry), dentry, mode);
+#endif
+	if (!err && d_unhashed(dentry)) {
 		struct dentry *d;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		d = lookup_one(idmap, dentry->d_name.name, dentry->d_parent,
+#else
 		d = lookup_one(user_ns, dentry->d_name.name, dentry->d_parent,
+#endif
 			       dentry->d_name.len);
+#else
+		d = lookup_one_len(dentry->d_name.name, dentry->d_parent,
+				   dentry->d_name.len);
+#endif
 		if (IS_ERR(d)) {
 			err = PTR_ERR(d);
-			goto out;
+			goto out_err;
 		}
 		if (unlikely(d_is_negative(d))) {
 			dput(d);
 			err = -ENOENT;
-			goto out;
+			goto out_err;
 		}
 
 		ksmbd_vfs_inherit_owner(work, d_inode(path.dentry), d_inode(d));
 		dput(d);
 	}
-out:
+
+out_err:
 	done_path_create(&path, dentry);
 	if (err)
 		pr_err("mkdir(%s): creation failed (err:%d)\n", name, err);
 	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static ssize_t ksmbd_vfs_getcasexattr(struct mnt_idmap *idmap,
+#else
 static ssize_t ksmbd_vfs_getcasexattr(struct user_namespace *user_ns,
+#endif
 				      struct dentry *dentry, char *attr_name,
 				      int attr_name_len, char **attr_value)
 {
@@ -262,7 +501,11 @@ static ssize_t ksmbd_vfs_getcasexattr(struct user_namespace *user_ns,
 		if (strncasecmp(attr_name, name, attr_name_len))
 			continue;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		value_len = ksmbd_vfs_getxattr(idmap,
+#else
 		value_len = ksmbd_vfs_getxattr(user_ns,
+#endif
 					       dentry,
 					       name,
 					       attr_value);
@@ -285,7 +528,11 @@ static int ksmbd_vfs_stream_read(struct ksmbd_file *fp, char *buf, loff_t *pos,
 	ksmbd_debug(VFS, "read stream data pos : %llu, count : %zd\n",
 		    *pos, count);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	v_len = ksmbd_vfs_getcasexattr(file_mnt_idmap(fp->filp),
+#else
 	v_len = ksmbd_vfs_getcasexattr(file_mnt_user_ns(fp->filp),
+#endif
 				       fp->filp->f_path.dentry,
 				       fp->stream.name,
 				       fp->stream.size,
@@ -321,7 +568,11 @@ static int check_lock_range(struct file *filp, loff_t start, loff_t end,
 			    unsigned char type)
 {
 	struct file_lock *flock;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
 	struct file_lock_context *ctx = locks_inode_context(file_inode(filp));
+#else
+	struct file_lock_context *ctx = file_inode(filp)->i_flctx;
+#endif
 	int error = 0;
 
 	if (!ctx || list_empty_careful(&ctx->flc_posix))
@@ -358,15 +609,15 @@ static int check_lock_range(struct file *filp, loff_t start, loff_t end,
  * @fid:	file id of open file
  * @count:	read byte count
  * @pos:	file pos
+ * @rbuf:	read data buffer
  *
  * Return:	number of read bytes on success, otherwise error
  */
 int ksmbd_vfs_read(struct ksmbd_work *work, struct ksmbd_file *fp, size_t count,
-		   loff_t *pos)
+		   loff_t *pos, char *rbuf)
 {
 	struct file *filp = fp->filp;
 	ssize_t nbytes = 0;
-	char *rbuf = work->aux_payload_buf;
 	struct inode *inode = file_inode(filp);
 
 	if (S_ISDIR(inode->i_mode))
@@ -409,8 +660,13 @@ static int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,
 				  size_t count)
 {
 	char *stream_buf = NULL, *wbuf;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap = file_mnt_idmap(fp->filp);
+#else
 	struct user_namespace *user_ns = file_mnt_user_ns(fp->filp);
-	size_t size, v_len;
+#endif
+	size_t size;
+	ssize_t v_len;
 	int err = 0;
 
 	ksmbd_debug(VFS, "write stream data pos : %llu, count : %zd\n",
@@ -422,19 +678,23 @@ static int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,
 		count = (*pos + count) - XATTR_SIZE_MAX;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	v_len = ksmbd_vfs_getcasexattr(idmap,
+#else
 	v_len = ksmbd_vfs_getcasexattr(user_ns,
+#endif
 				       fp->filp->f_path.dentry,
 				       fp->stream.name,
 				       fp->stream.size,
 				       &stream_buf);
-	if ((int)v_len < 0) {
+	if (v_len < 0) {
 		pr_err("not found stream in xattr : %zd\n", v_len);
-		err = (int)v_len;
+		err = v_len;
 		goto out;
 	}
 
 	if (v_len < size) {
-		wbuf = kvmalloc(size, GFP_KERNEL | __GFP_ZERO);
+		wbuf = kvzalloc(size, GFP_KERNEL);
 		if (!wbuf) {
 			err = -ENOMEM;
 			goto out;
@@ -448,12 +708,17 @@ static int ksmbd_vfs_stream_write(struct ksmbd_file *fp, char *buf, loff_t *pos,
 
 	memcpy(&stream_buf[*pos], buf, count);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_setxattr(idmap,
+#else
 	err = ksmbd_vfs_setxattr(user_ns,
-				 fp->filp->f_path.dentry,
+#endif
+				 &fp->filp->f_path,
 				 fp->stream.name,
 				 (void *)stream_buf,
 				 size,
-				 0);
+				 0,
+				 true);
 	if (err < 0)
 		goto out;
 
@@ -510,6 +775,9 @@ int ksmbd_vfs_write(struct ksmbd_work *work, struct ksmbd_file *fp,
 		}
 	}
 
+	/* Reserve lease break for parent dir at closing time */
+	fp->reserve_lease_break = true;
+
 	/* Do we need to break any of a levelII oplock? */
 	smb_break_all_levII_oplock(work, fp, 1);
 
@@ -551,6 +819,316 @@ int ksmbd_vfs_getattr(const struct path *path, struct kstat *stat)
 	return err;
 }
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+/**
+ * smb_check_attrs() - sanitize inode attributes
+ * @inode:	inode
+ * @attrs:	inode attributes
+ */
+static void smb_check_attrs(struct inode *inode, struct iattr *attrs)
+{
+	/* sanitize the mode change */
+	if (attrs->ia_valid & ATTR_MODE) {
+		attrs->ia_mode &= S_IALLUGO;
+		attrs->ia_mode |= (inode->i_mode & ~S_IALLUGO);
+	}
+
+	/* Revoke setuid/setgid on chown */
+	if (!S_ISDIR(inode->i_mode) &&
+	    (((attrs->ia_valid & ATTR_UID) &&
+	      !uid_eq(attrs->ia_uid, inode->i_uid)) ||
+	     ((attrs->ia_valid & ATTR_GID) &&
+	      !gid_eq(attrs->ia_gid, inode->i_gid)))) {
+		attrs->ia_valid |= ATTR_KILL_PRIV;
+		if (attrs->ia_valid & ATTR_MODE) {
+			/* we're setting mode too, just clear the s*id bits */
+			attrs->ia_mode &= ~S_ISUID;
+			if (attrs->ia_mode & 0010)
+				attrs->ia_mode &= ~S_ISGID;
+		} else {
+			/* set ATTR_KILL_* bits and let VFS handle it */
+			attrs->ia_valid |= (ATTR_KILL_SUID | ATTR_KILL_SGID);
+		}
+	}
+}
+
+/**
+ * ksmbd_vfs_setattr() - vfs helper for smb setattr
+ * @work:	work
+ * @name:	file name
+ * @fid:	file id of open file
+ * @attrs:	inode attributes
+ *
+ * Return:	0 on success, otherwise error
+ */
+int ksmbd_vfs_setattr(struct ksmbd_work *work, const char *name, u64 fid,
+		      struct iattr *attrs)
+{
+	struct file *filp;
+	struct dentry *dentry;
+	struct inode *inode;
+	struct path path;
+	bool update_size = false;
+	int err = 0;
+	struct ksmbd_file *fp = NULL;
+	struct user_namespace *user_ns;
+	struct mnt_idmap *idmap;
+
+	if (ksmbd_override_fsids(work))
+		return -ENOMEM;
+
+	if (name) {
+		err = kern_path(name, 0, &path);
+		if (err) {
+			ksmbd_revert_fsids(work);
+			ksmbd_debug(VFS, "lookup failed for %s, err = %d\n",
+				    name, err);
+			return -ENOENT;
+		}
+		dentry = path.dentry;
+		inode = d_inode(dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		idmap = mnt_idmap(path.mnt);
+#else
+		user_ns = mnt_user_ns(path.mnt);
+#endif
+	} else {
+		fp = ksmbd_lookup_fd_fast(work, fid);
+		if (!fp) {
+			ksmbd_revert_fsids(work);
+			pr_err("failed to get filp for fid %llu\n", fid);
+			return -ENOENT;
+		}
+
+		filp = fp->filp;
+		dentry = filp->f_path.dentry;
+		inode = d_inode(dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		idmap = file_mnt_idmap(filp);
+#else
+		user_ns = file_mnt_user_ns(filp);
+#endif
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = inode_permission(idmap, d_inode(dentry), MAY_WRITE);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+	err = inode_permission(user_ns, d_inode(dentry), MAY_WRITE);
+#else
+	err = inode_permission(d_inode(dentry), MAY_WRITE);
+#endif
+#endif
+	if (err)
+		goto out;
+
+	/* no need to update mode of symlink */
+	if (S_ISLNK(inode->i_mode))
+		attrs->ia_valid &= ~ATTR_MODE;
+
+	/* skip setattr, if nothing to update */
+	if (!attrs->ia_valid) {
+		err = 0;
+		goto out;
+	}
+
+	smb_check_attrs(inode, attrs);
+	if (attrs->ia_valid & ATTR_SIZE) {
+		err = get_write_access(inode);
+		if (err)
+			goto out;
+		update_size = true;
+	}
+
+	attrs->ia_valid |= ATTR_CTIME;
+
+	inode_lock(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = notify_change(idmap, dentry, attrs, NULL);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+	err = notify_change(user_ns, dentry, attrs, NULL);
+#else
+	err = notify_change(dentry, attrs, NULL);
+#endif
+#endif
+	inode_unlock(inode);
+
+	if (update_size)
+		put_write_access(inode);
+
+	if (!err) {
+		sync_inode_metadata(inode, 1);
+		ksmbd_debug(VFS, "fid %llu, setattr done\n", fid);
+	}
+
+out:
+	if (name)
+		path_put(&path);
+	ksmbd_fd_put(work, fp);
+	ksmbd_revert_fsids(work);
+	return err;
+}
+
+/**
+ * ksmbd_vfs_symlink() - vfs helper for creating smb symlink
+ * @name:	source file name
+ * @symname:	symlink name
+ *
+ * Return:	0 on success, otherwise error
+ */
+int ksmbd_vfs_symlink(struct ksmbd_work *work, const char *name,
+		      const char *symname)
+{
+	struct path path;
+	struct dentry *dentry;
+	int err;
+
+	if (ksmbd_override_fsids(work))
+		return -ENOMEM;
+
+	dentry = kern_path_create(AT_FDCWD, symname, &path, 0);
+	if (IS_ERR(dentry)) {
+		ksmbd_revert_fsids(work);
+		err = PTR_ERR(dentry);
+		pr_err("path create failed for %s, err %d\n", name, err);
+		return err;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_symlink(mnt_idmap(path.mnt), d_inode(dentry->d_parent), dentry, name);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+	err = vfs_symlink(mnt_user_ns(path.mnt), d_inode(dentry->d_parent), dentry, name);
+#else
+	err = vfs_symlink(d_inode(dentry->d_parent), dentry, name);
+#endif
+#endif
+	if (err && (err != -EEXIST || err != -ENOSPC))
+		ksmbd_debug(VFS, "failed to create symlink, err %d\n", err);
+
+	done_path_create(&path, dentry);
+	ksmbd_revert_fsids(work);
+	return err;
+}
+
+/**
+ * ksmbd_vfs_readlink() - vfs helper for reading value of symlink
+ * @path:	path of symlink
+ * @buf:	destination buffer for symlink value
+ * @lenp:	destination buffer length
+ *
+ * Return:	symlink value length on success, otherwise error
+ */
+int ksmbd_vfs_readlink(struct path *path, char *buf, int lenp)
+{
+	struct inode *inode;
+	int err, len;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	const char *link;
+	DEFINE_DELAYED_CALL(done);
+#else
+	mm_segment_t old_fs;
+#endif
+
+	if (!path)
+		return -ENOENT;
+
+	inode = d_inode(path->dentry);
+	if (!S_ISLNK(inode->i_mode))
+		return -EINVAL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	link = vfs_get_link(path->dentry, &done);
+	if (IS_ERR(link)) {
+		err = PTR_ERR(link);
+		pr_err("readlink failed, err = %d\n", err);
+		return err;
+	}
+
+	len = strlen(link);
+	if (len > lenp)
+		len = lenp;
+
+	memcpy(buf, link, len);
+	do_delayed_call(&done);
+
+	return len;
+#else
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	err = vfs_readlink(path->dentry, (char __user *)buf, lenp);
+	set_fs(old_fs);
+	if (err < 0) {
+		pr_err("readlink failed, err = %d\n", err);
+		return err;
+	}
+	len = lenp;
+
+	return len;
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_readdir_name(struct ksmbd_work *work,
+			   struct mnt_idmap *idmap,
+			   struct ksmbd_kstat *ksmbd_kstat,
+			   const char *de_name, int de_name_len,
+			   const char *dir_path)
+#else
+int ksmbd_vfs_readdir_name(struct ksmbd_work *work,
+			   struct user_namespace *user_ns,
+			   struct ksmbd_kstat *ksmbd_kstat,
+			   const char *de_name, int de_name_len,
+			   const char *dir_path)
+#endif
+{
+	struct path path, parent_path;
+	int rc, file_pathlen, dir_pathlen;
+	char *name;
+
+	dir_pathlen = strlen(dir_path);
+	/* 1 for '/'*/
+	file_pathlen = dir_pathlen +  de_name_len + 1;
+	name = kmalloc(file_pathlen + 1, GFP_KERNEL);
+	if (!name)
+		return -ENOMEM;
+
+	memcpy(name, dir_path, dir_pathlen);
+	memset(name + dir_pathlen, '/', 1);
+	memcpy(name + dir_pathlen + 1, de_name, de_name_len);
+	name[file_pathlen] = '\0';
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	rc = ksmbd_vfs_kern_path_locked(work, name, LOOKUP_NO_SYMLINKS,
+					&parent_path, &path, true);
+#else
+	rc = ksmbd_vfs_kern_path(work, name, LOOKUP_NO_SYMLINKS, &path, 1);
+#endif
+	if (rc) {
+		pr_err("lookup failed: %s [%d]\n", name, rc);
+		kfree(name);
+		return -ENOMEM;
+	}
+
+	ksmbd_vfs_fill_dentry_attrs(work,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+				    idmap,
+#else
+				    user_ns,
+#endif
+				    path.dentry,
+				    ksmbd_kstat);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+	ksmbd_vfs_kern_path_unlock(&parent_path, &path);
+#else
+	path_put(&path);
+#endif
+	kfree(name);
+	return 0;
+}
+#endif
+
 /**
  * ksmbd_vfs_fsync() - vfs helper for smb fsync
  * @work:	work
@@ -575,6 +1153,43 @@ int ksmbd_vfs_fsync(struct ksmbd_work *work, u64 fid, u64 p_id)
 	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+/**
+ * ksmbd_vfs_remove_file() - vfs helper for smb rmdir or unlink
+ * @name:	directory or file name that is relative to share
+ *
+ * Return:	0 on success, otherwise error
+ */
+int ksmbd_vfs_remove_file(struct ksmbd_work *work, const struct path *path)
+{
+	struct mnt_idmap *idmap;
+	struct dentry *parent = path->dentry->d_parent;
+	int err;
+
+	if (ksmbd_override_fsids(work))
+		return -ENOMEM;
+
+	if (!d_inode(path->dentry)->i_nlink) {
+		err = -ENOENT;
+		goto out_err;
+	}
+
+	idmap = mnt_idmap(path->mnt);
+	if (S_ISDIR(d_inode(path->dentry)->i_mode)) {
+		err = vfs_rmdir(idmap, d_inode(parent), path->dentry);
+		if (err && err != -ENOTEMPTY)
+			ksmbd_debug(VFS, "rmdir failed, err %d\n", err);
+	} else {
+		err = vfs_unlink(idmap, d_inode(parent), path->dentry, NULL);
+		if (err)
+			ksmbd_debug(VFS, "unlink failed, err %d\n", err);
+	}
+
+out_err:
+	ksmbd_revert_fsids(work);
+	return err;
+}
+#else
 /**
  * ksmbd_vfs_remove_file() - vfs helper for smb rmdir or unlink
  * @name:	directory or file name that is relative to share
@@ -583,7 +1198,11 @@ int ksmbd_vfs_fsync(struct ksmbd_work *work, u64 fid, u64 p_id)
  */
 int ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct path path;
 	struct dentry *parent;
 	int err;
@@ -598,9 +1217,17 @@ int ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)
 		return err;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = mnt_idmap(path.mnt);
+#else
 	user_ns = mnt_user_ns(path.mnt);
+#endif
 	parent = dget_parent(path.dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_lock_parent(idmap, parent, path.dentry);
+#else
 	err = ksmbd_vfs_lock_parent(user_ns, parent, path.dentry);
+#endif
 	if (err) {
 		dput(parent);
 		path_put(&path);
@@ -614,12 +1241,28 @@ int ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)
 	}
 
 	if (S_ISDIR(d_inode(path.dentry)->i_mode)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		err = vfs_rmdir(idmap, d_inode(parent), path.dentry);
+#else
 		err = vfs_rmdir(user_ns, d_inode(parent), path.dentry);
+#endif
+#else
+		err = vfs_rmdir(d_inode(parent), path.dentry);
+#endif
 		if (err && err != -ENOTEMPTY)
 			ksmbd_debug(VFS, "%s: rmdir failed, err %d\n", name,
 				    err);
 	} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		err = vfs_unlink(idmap, d_inode(parent), path.dentry, NULL);
+#else
 		err = vfs_unlink(user_ns, d_inode(parent), path.dentry, NULL);
+#endif
+#else
+		err = vfs_unlink(d_inode(parent), path.dentry, NULL);
+#endif
 		if (err)
 			ksmbd_debug(VFS, "%s: unlink failed, err %d\n", name,
 				    err);
@@ -632,6 +1275,7 @@ int ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name)
 	ksmbd_revert_fsids(work);
 	return err;
 }
+#endif
 
 /**
  * ksmbd_vfs_link() - vfs helper for creating smb hardlink
@@ -672,9 +1316,19 @@ int ksmbd_vfs_link(struct ksmbd_work *work, const char *oldname,
 		goto out3;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_link(oldpath.dentry, mnt_idmap(newpath.mnt),
+		       d_inode(newpath.dentry),
+		       dentry, NULL);
+#else
 	err = vfs_link(oldpath.dentry, mnt_user_ns(newpath.mnt),
 		       d_inode(newpath.dentry),
 		       dentry, NULL);
+#endif
+#else
+	err = vfs_link(oldpath.dentry, d_inode(newpath.dentry), dentry, NULL);
+#endif
 	if (err)
 		ksmbd_debug(VFS, "vfs_link failed err %d\n", err);
 
@@ -687,6 +1341,125 @@ int ksmbd_vfs_link(struct ksmbd_work *work, const char *oldname,
 	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+int ksmbd_vfs_rename(struct ksmbd_work *work, const struct path *old_path,
+		     char *newname, int flags)
+{
+	struct dentry *old_parent, *new_dentry, *trap;
+	struct dentry *old_child = old_path->dentry;
+	struct path new_path;
+	struct qstr new_last;
+	struct renamedata rd;
+	struct filename *to;
+	struct ksmbd_share_config *share_conf = work->tcon->share_conf;
+	struct ksmbd_file *parent_fp;
+	int new_type;
+	int err, lookup_flags = LOOKUP_NO_SYMLINKS;
+
+	if (ksmbd_override_fsids(work))
+		return -ENOMEM;
+
+	to = getname_kernel(newname);
+	if (IS_ERR(to)) {
+		err = PTR_ERR(to);
+		goto revert_fsids;
+	}
+
+retry:
+	err = vfs_path_parent_lookup(to, lookup_flags | LOOKUP_BENEATH,
+				     &new_path, &new_last, &new_type,
+				     &share_conf->vfs_path);
+	if (err)
+		goto out1;
+
+	if (old_path->mnt != new_path.mnt) {
+		err = -EXDEV;
+		goto out2;
+	}
+
+	err = mnt_want_write(old_path->mnt);
+	if (err)
+		goto out2;
+
+	trap = lock_rename_child(old_child, new_path.dentry);
+
+	old_parent = dget(old_child->d_parent);
+	if (d_unhashed(old_child)) {
+		err = -EINVAL;
+		goto out3;
+	}
+
+	parent_fp = ksmbd_lookup_fd_inode(old_child->d_parent);
+	if (parent_fp) {
+		if (parent_fp->daccess & FILE_DELETE_LE) {
+			pr_err("parent dir is opened with delete access\n");
+			err = -ESHARE;
+			ksmbd_fd_put(work, parent_fp);
+			goto out3;
+		}
+		ksmbd_fd_put(work, parent_fp);
+	}
+
+	new_dentry = lookup_one_qstr_excl(&new_last, new_path.dentry,
+					  lookup_flags | LOOKUP_RENAME_TARGET);
+	if (IS_ERR(new_dentry)) {
+		err = PTR_ERR(new_dentry);
+		goto out3;
+	}
+
+	if (d_is_symlink(new_dentry)) {
+		err = -EACCES;
+		goto out4;
+	}
+
+	if ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry)) {
+		err = -EEXIST;
+		goto out4;
+	}
+
+	if (old_child == trap) {
+		err = -EINVAL;
+		goto out4;
+	}
+
+	if (new_dentry == trap) {
+		err = -ENOTEMPTY;
+		goto out4;
+	}
+
+	rd.old_mnt_idmap	= mnt_idmap(old_path->mnt),
+	rd.old_dir		= d_inode(old_parent),
+	rd.old_dentry		= old_child,
+	rd.new_mnt_idmap	= mnt_idmap(new_path.mnt),
+	rd.new_dir		= new_path.dentry->d_inode,
+	rd.new_dentry		= new_dentry,
+	rd.flags		= flags,
+	rd.delegated_inode	= NULL,
+	err = vfs_rename(&rd);
+	if (err)
+		ksmbd_debug(VFS, "vfs_rename failed err %d\n", err);
+
+out4:
+	dput(new_dentry);
+out3:
+	dput(old_parent);
+	unlock_rename(old_parent, new_path.dentry);
+	mnt_drop_write(old_path->mnt);
+out2:
+	path_put(&new_path);
+
+	if (retry_estale(err, lookup_flags)) {
+		lookup_flags |= LOOKUP_REVAL;
+		goto retry;
+	}
+out1:
+	putname(to);
+revert_fsids:
+	ksmbd_revert_fsids(work);
+	return err;
+}
+
+#else
 static int ksmbd_validate_entry_in_use(struct dentry *src_dent)
 {
 	struct dentry *dst_dent;
@@ -698,7 +1471,7 @@ static int ksmbd_validate_entry_in_use(struct dentry *src_dent)
 		if (d_really_is_negative(dst_dent))
 			continue;
 
-		child_fp = ksmbd_lookup_fd_inode(d_inode(dst_dent));
+		child_fp = ksmbd_lookup_fd_inode(dst_dent);
 		if (child_fp) {
 			spin_unlock(&src_dent->d_lock);
 			ksmbd_debug(VFS, "Forbid rename, sub file/dir is in use\n");
@@ -710,14 +1483,25 @@ static int ksmbd_validate_entry_in_use(struct dentry *src_dent)
 	return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
 static int __ksmbd_vfs_rename(struct ksmbd_work *work,
-			      struct user_namespace *src_user_ns,
+			      struct mnt_idmap *src_idmap,
+			      struct dentry *src_dent_parent,
+			      struct dentry *src_dent,
+			      struct mnt_idmap *dst_idmap,
+			      struct dentry *dst_dent_parent,
+			      struct dentry *trap_dent,
+			      char *dst_name)
+#else
+static int __ksmbd_vfs_rename(struct ksmbd_work *work,
+			      struct user_namespace *src_user_ns,
 			      struct dentry *src_dent_parent,
 			      struct dentry *src_dent,
 			      struct user_namespace *dst_user_ns,
 			      struct dentry *dst_dent_parent,
 			      struct dentry *trap_dent,
 			      char *dst_name)
+#endif
 {
 	struct dentry *dst_dent;
 	int err;
@@ -740,8 +1524,18 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 	if (ksmbd_override_fsids(work))
 		return -ENOMEM;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	dst_dent = lookup_one(dst_idmap, dst_name,
+			      dst_dent_parent, strlen(dst_name));
+#else
 	dst_dent = lookup_one(dst_user_ns, dst_name, dst_dent_parent,
 			      strlen(dst_name));
+#endif
+#else
+	dst_dent = lookup_one_len(dst_name, dst_dent_parent,
+				  strlen(dst_name));
+#endif
 	err = PTR_ERR(dst_dent);
 	if (IS_ERR(dst_dent)) {
 		pr_err("lookup failed %s [%d]\n", dst_name, err);
@@ -750,6 +1544,17 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 
 	err = -ENOTEMPTY;
 	if (dst_dent != trap_dent && !d_really_is_positive(dst_dent)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		struct renamedata rd = {
+			.old_mnt_idmap	= src_idmap,
+			.old_dir	= d_inode(src_dent_parent),
+			.old_dentry	= src_dent,
+			.new_mnt_idmap	= dst_idmap,
+			.new_dir	= d_inode(dst_dent_parent),
+			.new_dentry	= dst_dent,
+		};
+#else
 		struct renamedata rd = {
 			.old_mnt_userns	= src_user_ns,
 			.old_dir	= d_inode(src_dent_parent),
@@ -758,7 +1563,16 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 			.new_dir	= d_inode(dst_dent_parent),
 			.new_dentry	= dst_dent,
 		};
+#endif
 		err = vfs_rename(&rd);
+#else
+		err = vfs_rename(d_inode(src_dent_parent),
+				 src_dent,
+				 d_inode(dst_dent_parent),
+				 dst_dent,
+				 NULL,
+				 0);
+#endif
 	}
 	if (err)
 		pr_err("vfs_rename failed err %d\n", err);
@@ -772,7 +1586,11 @@ static int __ksmbd_vfs_rename(struct ksmbd_work *work,
 int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 			char *newname)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	struct mnt_idmap *idmap;
+#else
 	struct user_namespace *user_ns;
+#endif
 	struct path dst_path;
 	struct dentry *src_dent_parent, *dst_dent_parent;
 	struct dentry *src_dent, *trap_dent, *src_child;
@@ -800,9 +1618,22 @@ int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 	trap_dent = lock_rename(src_dent_parent, dst_dent_parent);
 	dget(src_dent);
 	dget(dst_dent_parent);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	idmap = file_mnt_idmap(fp->filp);
+#else
 	user_ns = file_mnt_user_ns(fp->filp);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	src_child = lookup_one(idmap, src_dent->d_name.name, src_dent_parent,
+#else
 	src_child = lookup_one(user_ns, src_dent->d_name.name, src_dent_parent,
+#endif
 			       src_dent->d_name.len);
+#else
+	src_child = lookup_one_len(src_dent->d_name.name, src_dent_parent,
+				   src_dent->d_name.len);
+#endif
 	if (IS_ERR(src_child)) {
 		err = PTR_ERR(src_child);
 		goto out_lock;
@@ -815,6 +1646,16 @@ int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 	}
 	dput(src_child);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = __ksmbd_vfs_rename(work,
+				 idmap,
+				 src_dent_parent,
+				 src_dent,
+				 mnt_idmap(dst_path.mnt),
+				 dst_dent_parent,
+				 trap_dent,
+				 dst_name);
+#else
 	err = __ksmbd_vfs_rename(work,
 				 user_ns,
 				 src_dent_parent,
@@ -823,6 +1664,7 @@ int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 				 dst_dent_parent,
 				 trap_dent,
 				 dst_name);
+#endif
 out_lock:
 	dput(src_dent);
 	dput(dst_dent_parent);
@@ -832,10 +1674,12 @@ int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 	dput(src_dent_parent);
 	return err;
 }
+#endif
 
 /**
  * ksmbd_vfs_truncate() - vfs helper for smb file truncate
  * @work:	work
+ * @name:	old filename
  * @fid:	file id of old file
  * @size:	truncate to given size
  *
@@ -847,6 +1691,9 @@ int ksmbd_vfs_truncate(struct ksmbd_work *work,
 	int err = 0;
 	struct file *filp;
 
+	if (size < 0)
+		return -EINVAL;
+
 	filp = fp->filp;
 
 	/* Do we need to break any of a levelII oplock? */
@@ -892,7 +1739,7 @@ ssize_t ksmbd_vfs_listxattr(struct dentry *dentry, char **list)
 	if (size <= 0)
 		return size;
 
-	vlist = kvmalloc(size, GFP_KERNEL | __GFP_ZERO);
+	vlist = kvzalloc(size, GFP_KERNEL);
 	if (!vlist)
 		return -ENOMEM;
 
@@ -907,22 +1754,42 @@ ssize_t ksmbd_vfs_listxattr(struct dentry *dentry, char **list)
 	return size;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static ssize_t ksmbd_vfs_xattr_len(struct mnt_idmap *idmap,
+#else
 static ssize_t ksmbd_vfs_xattr_len(struct user_namespace *user_ns,
+#endif
 				   struct dentry *dentry, char *xattr_name)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	return vfs_getxattr(idmap, dentry, xattr_name, NULL, 0);
+#else
 	return vfs_getxattr(user_ns, dentry, xattr_name, NULL, 0);
+#endif
+#else
+	return vfs_getxattr(dentry, xattr_name, NULL, 0);
+#endif
 }
 
 /**
  * ksmbd_vfs_getxattr() - vfs helper for smb get extended attributes value
- * @user_ns:	user namespace
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
++  @idmap:	idmap
+#else
++  @user_ns:	user namespace
+#endif
  * @dentry:	dentry of file for getting xattrs
  * @xattr_name:	name of xattr name to query
  * @xattr_buf:	destination buffer xattr value
  *
  * Return:	read xattr value length on success, otherwise error
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ssize_t ksmbd_vfs_getxattr(struct mnt_idmap *idmap,
+#else
 ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry,
 			   char *xattr_name, char **xattr_buf)
 {
@@ -930,7 +1797,11 @@ ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
 	char *buf;
 
 	*xattr_buf = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	xattr_len = ksmbd_vfs_xattr_len(idmap, dentry, xattr_name);
+#else
 	xattr_len = ksmbd_vfs_xattr_len(user_ns, dentry, xattr_name);
+#endif
 	if (xattr_len < 0)
 		return xattr_len;
 
@@ -938,8 +1809,16 @@ ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
 	if (!buf)
 		return -ENOMEM;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	xattr_len = vfs_getxattr(idmap, dentry, xattr_name,
+#else
 	xattr_len = vfs_getxattr(user_ns, dentry, xattr_name,
+#endif
 				 (void *)buf, xattr_len);
+#else
+	xattr_len = vfs_getxattr(dentry, xattr_name, (void *)buf, xattr_len);
+#endif
 	if (xattr_len > 0)
 		*xattr_buf = buf;
 	else
@@ -949,29 +1828,536 @@ ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
 
 /**
  * ksmbd_vfs_setxattr() - vfs helper for smb set extended attributes value
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ * @idmap:	idmap of the relevant mount
+#else
  * @user_ns:	user namespace
- * @dentry:	dentry to set XATTR at
- * @name:	xattr name for setxattr
- * @value:	xattr value to set
- * @size:	size of xattr value
+#endif
+ * @path:	path of dentry to set XATTR at
+ * @attr_name:	xattr name for setxattr
+ * @attr_value:	xattr value to set
+ * @attr_size:	size of xattr value
  * @flags:	destination buffer length
  *
  * Return:	0 on success, otherwise error
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_setxattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_setxattr(struct user_namespace *user_ns,
-		       struct dentry *dentry, const char *attr_name,
-		       void *attr_value, size_t attr_size, int flags)
+#endif
+		       const struct path *path, const char *attr_name,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+		       void *attr_value, size_t attr_size, int flags,
+		       bool get_write)
+#else
+		       const void *attr_value, size_t attr_size, int flags,
+		       bool get_write)
+#endif
+{
+	int err;
+
+	if (get_write == true) {
+		err = mnt_want_write(path->mnt);
+		if (err)
+			return err;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_setxattr(idmap,
+#else
+	err = vfs_setxattr(user_ns,
+#endif
+			   path->dentry,
+#else
+	err = vfs_setxattr(path->dentry,
+#endif
+			   attr_name,
+			   attr_value,
+			   attr_size,
+			   flags);
+	if (err)
+		ksmbd_debug(VFS, "setxattr failed, err %d\n", err);
+	if (get_write == true)
+		mnt_drop_write(path->mnt);
+	return err;
+}
+
+#ifdef CONFIG_SMB_INSECURE_SERVER
+int ksmbd_vfs_fsetxattr(struct ksmbd_work *work, const char *filename,
+			const char *attr_name, const void *attr_value,
+			size_t attr_size, int flags)
+{
+	struct path path;
+	int err;
+
+	if (ksmbd_override_fsids(work))
+		return -ENOMEM;
+
+	err = kern_path(filename, 0, &path);
+	if (err) {
+		ksmbd_revert_fsids(work);
+		ksmbd_debug(VFS, "cannot get linux path %s, err %d\n",
+			    filename, err);
+		return err;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_setxattr(mnt_idmap(path.mnt), path.dentry,
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+	err = vfs_setxattr(mnt_user_ns(path.mnt), path.dentry,
+#else
+	err = vfs_setxattr(path.dentry,
+#endif
+#endif
+			   attr_name,
+			   attr_value,
+			   attr_size,
+			   flags);
+	if (err)
+		ksmbd_debug(VFS, "setxattr failed, err %d\n", err);
+	path_put(&path);
+	ksmbd_revert_fsids(work);
+	return err;
+}
+#endif
+
+struct dentry *ksmbd_vfs_kern_path_create(struct ksmbd_work *work,
+					  const char *name,
+					  unsigned int flags,
+					  struct path *path)
+{
+	char *abs_name;
+	struct dentry *dent;
+
+	abs_name = convert_to_unix_name(work->tcon->share_conf, name);
+	if (!abs_name)
+		return ERR_PTR(-ENOMEM);
+
+	dent = kern_path_create(AT_FDCWD, abs_name, path, flags);
+	kfree(abs_name);
+	return dent;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_acl_xattrs(struct mnt_idmap *idmap,
+				const struct path *path)
+#else
+int ksmbd_vfs_remove_acl_xattrs(struct user_namespace *user_ns,
+				const struct path *path)
+#endif
+{
+	char *name, *xattr_list = NULL;
+	ssize_t xattr_list_len;
+	int err = 0;
+
+	xattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);
+	if (xattr_list_len < 0) {
+		goto out;
+	} else if (!xattr_list_len) {
+		ksmbd_debug(SMB, "empty xattr in the file\n");
+		goto out;
+	}
+
+	err = mnt_want_write(path->mnt);
+	if (err)
+		goto out;
+
+	for (name = xattr_list; name - xattr_list < xattr_list_len;
+	     name += strlen(name) + 1) {
+		ksmbd_debug(SMB, "%s, len %zd\n", name, strlen(name));
+
+		if (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS,
+			     sizeof(XATTR_NAME_POSIX_ACL_ACCESS) - 1) ||
+		    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT,
+			     sizeof(XATTR_NAME_POSIX_ACL_DEFAULT) - 1)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			err = vfs_remove_acl(idmap, path->dentry, name);
+#else
+			err = vfs_remove_acl(user_ns, path->dentry, name);
+#endif
+#else
+			err = ksmbd_vfs_remove_xattr(user_ns, path, name);
+#endif
+			if (err)
+				ksmbd_debug(SMB,
+					    "remove acl xattr failed : %s\n", name);
+		}
+	}
+	mnt_drop_write(path->mnt);
+out:
+	kvfree(xattr_list);
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_sd_xattrs(struct mnt_idmap *idmap,
+#else
+int ksmbd_vfs_remove_sd_xattrs(struct user_namespace *user_ns,
+#endif
+			       const struct path *path)
+{
+	char *name, *xattr_list = NULL;
+	ssize_t xattr_list_len;
+	int err = 0;
+
+	xattr_list_len = ksmbd_vfs_listxattr(path->dentry, &xattr_list);
+	if (xattr_list_len < 0) {
+		goto out;
+	} else if (!xattr_list_len) {
+		ksmbd_debug(SMB, "empty xattr in the file\n");
+		goto out;
+	}
+
+	for (name = xattr_list; name - xattr_list < xattr_list_len;
+			name += strlen(name) + 1) {
+		ksmbd_debug(SMB, "%s, len %zd\n", name, strlen(name));
+
+		if (!strncmp(name, XATTR_NAME_SD, XATTR_NAME_SD_LEN)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			err = ksmbd_vfs_remove_xattr(idmap, path, name);
+#else
+			err = ksmbd_vfs_remove_xattr(user_ns, path, name);
+#endif
+			if (err)
+				ksmbd_debug(SMB, "remove xattr failed : %s\n", name);
+		}
+	}
+out:
+	kvfree(xattr_list);
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct mnt_idmap *idmap,
+#else
+static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct user_namespace *user_ns,
+#endif
+							    struct inode *inode,
+							    int acl_type)
+{
+	struct xattr_smb_acl *smb_acl = NULL;
+	struct posix_acl *posix_acls;
+	struct posix_acl_entry *pa_entry;
+	struct xattr_acl_entry *xa_entry;
+	int i;
+
+	if (!IS_ENABLED(CONFIG_FS_POSIX_ACL))
+		return NULL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+	posix_acls = get_inode_acl(inode, acl_type);
+#else
+	posix_acls = get_acl(inode, acl_type);
+#endif
+	if (IS_ERR_OR_NULL(posix_acls))
+		return NULL;
+
+	smb_acl = kzalloc(sizeof(struct xattr_smb_acl) +
+			  sizeof(struct xattr_acl_entry) * posix_acls->a_count,
+			  GFP_KERNEL);
+	if (!smb_acl)
+		goto out;
+
+	smb_acl->count = posix_acls->a_count;
+	pa_entry = posix_acls->a_entries;
+	xa_entry = smb_acl->entries;
+	for (i = 0; i < posix_acls->a_count; i++, pa_entry++, xa_entry++) {
+		switch (pa_entry->e_tag) {
+		case ACL_USER:
+			xa_entry->type = SMB_ACL_USER;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			xa_entry->uid = posix_acl_uid_translate(idmap, pa_entry);
+#else
+			xa_entry->uid = posix_acl_uid_translate(user_ns, pa_entry);
+#endif
+			break;
+		case ACL_USER_OBJ:
+			xa_entry->type = SMB_ACL_USER_OBJ;
+			break;
+		case ACL_GROUP:
+			xa_entry->type = SMB_ACL_GROUP;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			xa_entry->gid = posix_acl_gid_translate(idmap, pa_entry);
+#else
+			xa_entry->gid = posix_acl_gid_translate(user_ns, pa_entry);
+#endif
+			break;
+		case ACL_GROUP_OBJ:
+			xa_entry->type = SMB_ACL_GROUP_OBJ;
+			break;
+		case ACL_OTHER:
+			xa_entry->type = SMB_ACL_OTHER;
+			break;
+		case ACL_MASK:
+			xa_entry->type = SMB_ACL_MASK;
+			break;
+		default:
+			pr_err("unknown type : 0x%x\n", pa_entry->e_tag);
+			goto out;
+		}
+
+		if (pa_entry->e_perm & ACL_READ)
+			xa_entry->perm |= SMB_ACL_READ;
+		if (pa_entry->e_perm & ACL_WRITE)
+			xa_entry->perm |= SMB_ACL_WRITE;
+		if (pa_entry->e_perm & ACL_EXECUTE)
+			xa_entry->perm |= SMB_ACL_EXECUTE;
+	}
+out:
+	posix_acl_release(posix_acls);
+	return smb_acl;
+}
+
+int ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			   struct mnt_idmap *idmap,
+#else
+			   struct user_namespace *user_ns,
+#endif
+			   const struct path *path,
+			   struct smb_ntsd *pntsd, int len,
+			   bool get_write)
+{
+	int rc;
+	struct ndr sd_ndr = {0}, acl_ndr = {0};
+	struct xattr_ntacl acl = {0};
+	struct xattr_smb_acl *smb_acl, *def_smb_acl = NULL;
+	struct dentry *dentry = path->dentry;
+	struct inode *inode = d_inode(dentry);
+
+	acl.version = 4;
+	acl.hash_type = XATTR_SD_HASH_TYPE_SHA256;
+	acl.current_time = ksmbd_UnixTimeToNT(current_time(inode));
+
+	memcpy(acl.desc, "posix_acl", 9);
+	acl.desc_len = 10;
+
+	pntsd->osidoffset =
+		cpu_to_le32(le32_to_cpu(pntsd->osidoffset) + NDR_NTSD_OFFSETOF);
+	pntsd->gsidoffset =
+		cpu_to_le32(le32_to_cpu(pntsd->gsidoffset) + NDR_NTSD_OFFSETOF);
+	pntsd->dacloffset =
+		cpu_to_le32(le32_to_cpu(pntsd->dacloffset) + NDR_NTSD_OFFSETOF);
+
+	acl.sd_buf = (char *)pntsd;
+	acl.sd_size = len;
+
+	rc = ksmbd_gen_sd_hash(conn, acl.sd_buf, acl.sd_size, acl.hash);
+	if (rc) {
+		pr_err("failed to generate hash for ndr acl\n");
+		return rc;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,
+#else
+	smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
+#endif
+						 ACL_TYPE_ACCESS);
+	if (S_ISDIR(inode->i_mode))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,
+#else
+		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
+#endif
+							     ACL_TYPE_DEFAULT);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ndr_encode_posix_acl(&acl_ndr, idmap, inode,
+#else
+	rc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode,
+#endif
+				  smb_acl, def_smb_acl);
+	if (rc) {
+		pr_err("failed to encode ndr to posix acl\n");
+		goto out;
+	}
+
+	rc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset,
+			       acl.posix_acl_hash);
+	if (rc) {
+		pr_err("failed to generate hash for ndr acl\n");
+		goto out;
+	}
+
+	rc = ndr_encode_v4_ntacl(&sd_ndr, &acl);
+	if (rc) {
+		pr_err("failed to encode ndr to posix acl\n");
+		goto out;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_setxattr(idmap, path,
+#else
+	rc = ksmbd_vfs_setxattr(user_ns, path,
+#endif
+				XATTR_NAME_SD, sd_ndr.data,
+				sd_ndr.offset, 0, get_write);
+	if (rc < 0)
+		pr_err("Failed to store XATTR ntacl :%d\n", rc);
+
+	kfree(sd_ndr.data);
+out:
+	kfree(acl_ndr.data);
+	kfree(smb_acl);
+	kfree(def_smb_acl);
+	return rc;
+}
+
+int ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			   struct mnt_idmap *idmap,
+#else
+			   struct user_namespace *user_ns,
+#endif
+			   struct dentry *dentry,
+			   struct smb_ntsd **pntsd)
+{
+	int rc;
+	struct ndr n;
+	struct inode *inode = d_inode(dentry);
+	struct ndr acl_ndr = {0};
+	struct xattr_ntacl acl;
+	struct xattr_smb_acl *smb_acl = NULL, *def_smb_acl = NULL;
+	__u8 cmp_hash[XATTR_SD_HASH_SIZE] = {0};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ksmbd_vfs_getxattr(idmap, dentry, XATTR_NAME_SD, &n.data);
+#else
+	rc = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_SD, &n.data);
+#endif
+	if (rc <= 0)
+		return rc;
+
+	n.length = rc;
+	rc = ndr_decode_v4_ntacl(&n, &acl);
+	if (rc)
+		goto free_n_data;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,
+#else
+	smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
+#endif
+						 ACL_TYPE_ACCESS);
+	if (S_ISDIR(inode->i_mode))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(idmap, inode,
+#else
+		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
+#endif
+							     ACL_TYPE_DEFAULT);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = ndr_encode_posix_acl(&acl_ndr, idmap, inode, smb_acl,
+#else
+	rc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode, smb_acl,
+#endif
+				  def_smb_acl);
+	if (rc) {
+		pr_err("failed to encode ndr to posix acl\n");
+		goto out_free;
+	}
+
+	rc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset, cmp_hash);
+	if (rc) {
+		pr_err("failed to generate hash for ndr acl\n");
+		goto out_free;
+	}
+
+	if (memcmp(cmp_hash, acl.posix_acl_hash, XATTR_SD_HASH_SIZE)) {
+		pr_err("hash value diff\n");
+		rc = -EINVAL;
+		goto out_free;
+	}
+
+	*pntsd = acl.sd_buf;
+	if (acl.sd_size < sizeof(struct smb_ntsd)) {
+		pr_err("sd size is invalid\n");
+		goto out_free;
+	}
+
+	(*pntsd)->osidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->osidoffset) -
+					   NDR_NTSD_OFFSETOF);
+	(*pntsd)->gsidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->gsidoffset) -
+					   NDR_NTSD_OFFSETOF);
+	(*pntsd)->dacloffset = cpu_to_le32(le32_to_cpu((*pntsd)->dacloffset) -
+					   NDR_NTSD_OFFSETOF);
+
+	rc = acl.sd_size;
+out_free:
+	kfree(acl_ndr.data);
+	kfree(smb_acl);
+	kfree(def_smb_acl);
+	if (rc < 0) {
+		kfree(acl.sd_buf);
+		*pntsd = NULL;
+	}
+
+free_n_data:
+	kfree(n.data);
+	return rc;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_set_dos_attrib_xattr(struct mnt_idmap *idmap,
+#else
+int ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,
+#endif
+				   const struct path *path,
+				   struct xattr_dos_attrib *da,
+				   bool get_write)
+{
+	struct ndr n;
+	int err;
+
+	err = ndr_encode_dos_attr(&n, da);
+	if (err)
+		return err;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_setxattr(idmap, path, XATTR_NAME_DOS_ATTRIBUTE,
+#else
+	err = ksmbd_vfs_setxattr(user_ns, path, XATTR_NAME_DOS_ATTRIBUTE,
+#endif
+				 (void *)n.data, n.offset, 0, get_write);
+	if (err)
+		ksmbd_debug(SMB, "failed to store dos attribute in xattr\n");
+	kfree(n.data);
+
+	return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_get_dos_attrib_xattr(struct mnt_idmap *idmap,
+#else
+int ksmbd_vfs_get_dos_attrib_xattr(struct user_namespace *user_ns,
+#endif
+				   struct dentry *dentry,
+				   struct xattr_dos_attrib *da)
 {
+	struct ndr n;
 	int err;
 
-	err = vfs_setxattr(user_ns,
-			   dentry,
-			   attr_name,
-			   attr_value,
-			   attr_size,
-			   flags);
-	if (err)
-		ksmbd_debug(VFS, "setxattr failed, err %d\n", err);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_getxattr(idmap, dentry, XATTR_NAME_DOS_ATTRIBUTE,
+#else
+	err = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_DOS_ATTRIBUTE,
+#endif
+				 (char **)&n.data);
+	if (err > 0) {
+		n.length = err;
+		if (ndr_decode_dos_attr(&n, da))
+			err = -EINVAL;
+		kfree(n.data);
+	} else {
+		ksmbd_debug(SMB, "failed to load dos attribute in xattr\n");
+	}
+
 	return err;
 }
 
@@ -1007,7 +2393,7 @@ int ksmbd_vfs_zero_data(struct ksmbd_work *work, struct ksmbd_file *fp,
 			loff_t off, loff_t len)
 {
 	smb_break_all_levII_oplock(work, fp, 1);
-	if (fp->f_ci->m_fattr & FILE_ATTRIBUTE_SPARSE_FILE_LE)
+	if (fp->f_ci->m_fattr & ATTR_SPARSE_FILE_LE)
 		return vfs_fallocate(fp->filp,
 				     FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,
 				     off, len);
@@ -1074,26 +2460,100 @@ int ksmbd_vfs_fqar_lseek(struct ksmbd_file *fp, loff_t start, loff_t length,
 	return ret;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_xattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_remove_xattr(struct user_namespace *user_ns,
-			   struct dentry *dentry, char *attr_name)
+#endif
+			   const struct path *path, char *attr_name)
 {
-	return vfs_removexattr(user_ns, dentry, attr_name);
+	int err;
+
+	err = mnt_want_write(path->mnt);
+	if (err)
+		return err;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = vfs_removexattr(idmap, path->dentry, attr_name);
+#else
+	err = vfs_removexattr(user_ns, path->dentry, attr_name);
+#endif
+#else
+	err = vfs_removexattr(path->dentry, attr_name);
+#endif
+	mnt_drop_write(path->mnt);
+
+	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+int ksmbd_vfs_unlink(struct file *filp)
+{
+	int err = 0;
+	struct dentry *dir, *dentry = filp->f_path.dentry;
+	struct mnt_idmap *idmap = file_mnt_idmap(filp);
+
+	err = mnt_want_write(filp->f_path.mnt);
+	if (err)
+		return err;
+
+	dir = dget_parent(dentry);
+	err = ksmbd_vfs_lock_parent(dir, dentry);
+	if (err)
+		goto out;
+	dget(dentry);
+
+	if (S_ISDIR(d_inode(dentry)->i_mode))
+		err = vfs_rmdir(idmap, d_inode(dir), dentry);
+	else
+		err = vfs_unlink(idmap, d_inode(dir), dentry, NULL);
+
+	dput(dentry);
+	inode_unlock(d_inode(dir));
+	if (err)
+		ksmbd_debug(VFS, "failed to delete, err %d\n", err);
+out:
+	dput(dir);
+	mnt_drop_write(filp->f_path.mnt);
+
+	return err;
+}
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_unlink(struct mnt_idmap *idmap,
+		     struct dentry *dir, struct dentry *dentry)
+#else
 int ksmbd_vfs_unlink(struct user_namespace *user_ns,
 		     struct dentry *dir, struct dentry *dentry)
+#endif
 {
 	int err = 0;
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	err = ksmbd_vfs_lock_parent(idmap, dir, dentry);
+#else
 	err = ksmbd_vfs_lock_parent(user_ns, dir, dentry);
+#endif
 	if (err)
 		return err;
-	dget(dentry);
 
+	dget(dentry);
 	if (S_ISDIR(d_inode(dentry)->i_mode))
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		err = vfs_rmdir(idmap, d_inode(dir), dentry);
+	else
+		err = vfs_unlink(idmap, d_inode(dir), dentry, NULL);
+#else
 		err = vfs_rmdir(user_ns, d_inode(dir), dentry);
 	else
 		err = vfs_unlink(user_ns, d_inode(dir), dentry, NULL);
+#endif
+#else
+		err = vfs_rmdir(d_inode(dir), dentry);
+	else
+		err = vfs_unlink(d_inode(dir), dentry, NULL);
+#endif
 
 	dput(dentry);
 	inode_unlock(d_inode(dir));
@@ -1102,8 +2562,70 @@ int ksmbd_vfs_unlink(struct user_namespace *user_ns,
 
 	return err;
 }
+#endif
+
+#ifdef CONFIG_SMB_INSECURE_SERVER
+/**
+ * ksmbd_vfs_dentry_open() - open a dentry and provide fid for it
+ * @work:	smb work ptr
+ * @path:	path of dentry to be opened
+ * @flags:	open flags
+ * @ret_id:	fid returned on this
+ * @option:	file access pattern options for fadvise
+ * @fexist:	file already present or not
+ *
+ * Return:	allocated struct ksmbd_file on success, otherwise error pointer
+ */
+struct ksmbd_file *ksmbd_vfs_dentry_open(struct ksmbd_work *work,
+					 const struct path *path, int flags,
+					 __le32 option, int fexist)
+{
+	struct file *filp;
+	int err = 0;
+	struct ksmbd_file *fp = NULL;
+
+	filp = dentry_open(path, flags | O_LARGEFILE, current_cred());
+	if (IS_ERR(filp)) {
+		err = PTR_ERR(filp);
+		pr_err("dentry open failed, err %d\n", err);
+		return ERR_PTR(err);
+	}
+
+	ksmbd_vfs_set_fadvise(filp, option);
+
+	fp = ksmbd_open_fd(work, filp);
+	if (IS_ERR(fp)) {
+		fput(filp);
+		err = PTR_ERR(fp);
+		pr_err("id insert failed\n");
+		goto err_out;
+	}
+
+	if (flags & O_TRUNC) {
+		if (fexist)
+			smb_break_all_oplock(work, fp);
+		err = vfs_truncate((struct path *)path, 0);
+		if (err)
+			goto err_out;
+	}
+	return fp;
+
+err_out:
+	if (!IS_ERR(fp))
+		ksmbd_close_fd(work, fp->volatile_id);
+	if (err) {
+		fp = ERR_PTR(err);
+		pr_err("err : %d\n", err);
+	}
+	return fp;
+}
+#endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 static bool __dir_empty(struct dir_context *ctx, const char *name, int namlen,
+#else
+static int __dir_empty(struct dir_context *ctx, const char *name, int namlen,
+#endif
 		       loff_t offset, u64 ino, unsigned int d_type)
 {
 	struct ksmbd_readdir_data *buf;
@@ -1111,7 +2633,13 @@ static bool __dir_empty(struct dir_context *ctx, const char *name, int namlen,
 	buf = container_of(ctx, struct ksmbd_readdir_data, ctx);
 	buf->dirent_count++;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 	return buf->dirent_count <= 2;
+#else
+	if (buf->dirent_count > 2)
+		return -ENOTEMPTY;
+	return 0;
+#endif
 }
 
 /**
@@ -1138,7 +2666,11 @@ int ksmbd_vfs_empty_dir(struct ksmbd_file *fp)
 	return err;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 static bool __caseless_lookup(struct dir_context *ctx, const char *name,
+#else
+static int __caseless_lookup(struct dir_context *ctx, const char *name,
+#endif
 			     int namlen, loff_t offset, u64 ino,
 			     unsigned int d_type)
 {
@@ -1148,7 +2680,11 @@ static bool __caseless_lookup(struct dir_context *ctx, const char *name,
 	buf = container_of(ctx, struct ksmbd_readdir_data, ctx);
 
 	if (buf->used != namlen)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 		return true;
+#else
+		return 0;
+#endif
 	if (IS_ENABLED(CONFIG_UNICODE) && buf->um) {
 		const struct qstr q_buf = {.name = buf->private,
 					   .len = buf->used};
@@ -1162,9 +2698,17 @@ static bool __caseless_lookup(struct dir_context *ctx, const char *name,
 	if (!cmp) {
 		memcpy((char *)buf->private, name, namlen);
 		buf->dirent_count = 1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 		return false;
+#else
+		return -EEXIST;
+#endif
 	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 	return true;
+#else
+	return 0;
+#endif
 }
 
 /**
@@ -1200,33 +2744,31 @@ static int ksmbd_vfs_lookup_in_dir(const struct path *dir, char *name,
 	return ret;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
 /**
- * ksmbd_vfs_kern_path() - lookup a file and get path info
- * @name:	file path that is relative to share
- * @flags:	lookup flags
- * @path:	if lookup succeed, return path info
+ * ksmbd_vfs_kern_path_locked() - lookup a file and get path info
+ * @name:		file path that is relative to share
+ * @flags:		lookup flags
+ * @parent_path:	if lookup succeed, return parent_path info
+ * @path:		if lookup succeed, return path info
  * @caseless:	caseless filename lookup
  *
  * Return:	0 on success, otherwise error
  */
-int ksmbd_vfs_kern_path(struct ksmbd_work *work, char *name,
-			unsigned int flags, struct path *path, bool caseless)
+int ksmbd_vfs_kern_path_locked(struct ksmbd_work *work, char *name,
+			       unsigned int flags, struct path *parent_path,
+			       struct path *path, bool caseless)
 {
 	struct ksmbd_share_config *share_conf = work->tcon->share_conf;
 	int err;
 
-	flags |= LOOKUP_BENEATH;
-	err = vfs_path_lookup(share_conf->vfs_path.dentry,
-			      share_conf->vfs_path.mnt,
-			      name,
-			      flags,
-			      path);
+	err = ksmbd_vfs_path_lookup_locked(share_conf, name, flags, parent_path,
+					   path);
 	if (!err)
 		return 0;
 
 	if (caseless) {
 		char *filepath;
-		struct path parent;
 		size_t path_len, remain_len;
 
 		filepath = kstrdup(name, GFP_KERNEL);
@@ -1236,10 +2778,10 @@ int ksmbd_vfs_kern_path(struct ksmbd_work *work, char *name,
 		path_len = strlen(filepath);
 		remain_len = path_len;
 
-		parent = share_conf->vfs_path;
-		path_get(&parent);
+		*parent_path = share_conf->vfs_path;
+		path_get(parent_path);
 
-		while (d_can_lookup(parent.dentry)) {
+		while (d_can_lookup(parent_path->dentry)) {
 			char *filename = filepath + path_len - remain_len;
 			char *next = strchrnul(filename, '/');
 			size_t filename_len = next - filename;
@@ -1248,12 +2790,11 @@ int ksmbd_vfs_kern_path(struct ksmbd_work *work, char *name,
 			if (filename_len == 0)
 				break;
 
-			err = ksmbd_vfs_lookup_in_dir(&parent, filename,
+			err = ksmbd_vfs_lookup_in_dir(parent_path, filename,
 						      filename_len,
 						      work->conn->um);
-			path_put(&parent);
 			if (err)
-				goto out;
+				goto out2;
 
 			next[0] = '\0';
 
@@ -1261,361 +2802,214 @@ int ksmbd_vfs_kern_path(struct ksmbd_work *work, char *name,
 					      share_conf->vfs_path.mnt,
 					      filepath,
 					      flags,
-					      &parent);
+					      path);
 			if (err)
-				goto out;
-			else if (is_last) {
-				*path = parent;
-				goto out;
-			}
+				goto out2;
+			else if (is_last)
+				goto out1;
+			path_put(parent_path);
+			*parent_path = *path;
 
 			next[0] = '/';
 			remain_len -= filename_len + 1;
 		}
 
-		path_put(&parent);
 		err = -EINVAL;
-out:
+out2:
+		path_put(parent_path);
+out1:
 		kfree(filepath);
 	}
-	return err;
-}
-
-struct dentry *ksmbd_vfs_kern_path_create(struct ksmbd_work *work,
-					  const char *name,
-					  unsigned int flags,
-					  struct path *path)
-{
-	char *abs_name;
-	struct dentry *dent;
-
-	abs_name = convert_to_unix_name(work->tcon->share_conf, name);
-	if (!abs_name)
-		return ERR_PTR(-ENOMEM);
-
-	dent = kern_path_create(AT_FDCWD, abs_name, path, flags);
-	kfree(abs_name);
-	return dent;
-}
-
-int ksmbd_vfs_remove_acl_xattrs(struct user_namespace *user_ns,
-				struct dentry *dentry)
-{
-	char *name, *xattr_list = NULL;
-	ssize_t xattr_list_len;
-	int err = 0;
-
-	xattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);
-	if (xattr_list_len < 0) {
-		goto out;
-	} else if (!xattr_list_len) {
-		ksmbd_debug(SMB, "empty xattr in the file\n");
-		goto out;
-	}
-
-	for (name = xattr_list; name - xattr_list < xattr_list_len;
-	     name += strlen(name) + 1) {
-		ksmbd_debug(SMB, "%s, len %zd\n", name, strlen(name));
 
-		if (!strncmp(name, XATTR_NAME_POSIX_ACL_ACCESS,
-			     sizeof(XATTR_NAME_POSIX_ACL_ACCESS) - 1) ||
-		    !strncmp(name, XATTR_NAME_POSIX_ACL_DEFAULT,
-			     sizeof(XATTR_NAME_POSIX_ACL_DEFAULT) - 1)) {
-			err = vfs_remove_acl(user_ns, dentry, name);
-			if (err)
-				ksmbd_debug(SMB,
-					    "remove acl xattr failed : %s\n", name);
+	if (!err) {
+		err = mnt_want_write(parent_path->mnt);
+		if (err) {
+			path_put(path);
+			path_put(parent_path);
+			return err;
 		}
-	}
-out:
-	kvfree(xattr_list);
-	return err;
-}
-
-int ksmbd_vfs_remove_sd_xattrs(struct user_namespace *user_ns,
-			       struct dentry *dentry)
-{
-	char *name, *xattr_list = NULL;
-	ssize_t xattr_list_len;
-	int err = 0;
-
-	xattr_list_len = ksmbd_vfs_listxattr(dentry, &xattr_list);
-	if (xattr_list_len < 0) {
-		goto out;
-	} else if (!xattr_list_len) {
-		ksmbd_debug(SMB, "empty xattr in the file\n");
-		goto out;
-	}
-
-	for (name = xattr_list; name - xattr_list < xattr_list_len;
-			name += strlen(name) + 1) {
-		ksmbd_debug(SMB, "%s, len %zd\n", name, strlen(name));
 
-		if (!strncmp(name, XATTR_NAME_SD, XATTR_NAME_SD_LEN)) {
-			err = ksmbd_vfs_remove_xattr(user_ns, dentry, name);
-			if (err)
-				ksmbd_debug(SMB, "remove xattr failed : %s\n", name);
+		err = ksmbd_vfs_lock_parent(parent_path->dentry, path->dentry);
+		if (err) {
+			mnt_drop_write(parent_path->mnt);
+			path_put(parent_path);
+			path_put(path);
 		}
 	}
-out:
-	kvfree(xattr_list);
 	return err;
 }
 
-static struct xattr_smb_acl *ksmbd_vfs_make_xattr_posix_acl(struct user_namespace *user_ns,
-							    struct inode *inode,
-							    int acl_type)
+void ksmbd_vfs_kern_path_unlock(struct path *parent_path, struct path *path)
 {
-	struct xattr_smb_acl *smb_acl = NULL;
-	struct posix_acl *posix_acls;
-	struct posix_acl_entry *pa_entry;
-	struct xattr_acl_entry *xa_entry;
-	int i;
-
-	if (!IS_ENABLED(CONFIG_FS_POSIX_ACL))
-		return NULL;
-
-	posix_acls = get_inode_acl(inode, acl_type);
-	if (!posix_acls)
-		return NULL;
-
-	smb_acl = kzalloc(sizeof(struct xattr_smb_acl) +
-			  sizeof(struct xattr_acl_entry) * posix_acls->a_count,
-			  GFP_KERNEL);
-	if (!smb_acl)
-		goto out;
-
-	smb_acl->count = posix_acls->a_count;
-	pa_entry = posix_acls->a_entries;
-	xa_entry = smb_acl->entries;
-	for (i = 0; i < posix_acls->a_count; i++, pa_entry++, xa_entry++) {
-		switch (pa_entry->e_tag) {
-		case ACL_USER:
-			xa_entry->type = SMB_ACL_USER;
-			xa_entry->uid = posix_acl_uid_translate(user_ns, pa_entry);
-			break;
-		case ACL_USER_OBJ:
-			xa_entry->type = SMB_ACL_USER_OBJ;
-			break;
-		case ACL_GROUP:
-			xa_entry->type = SMB_ACL_GROUP;
-			xa_entry->gid = posix_acl_gid_translate(user_ns, pa_entry);
-			break;
-		case ACL_GROUP_OBJ:
-			xa_entry->type = SMB_ACL_GROUP_OBJ;
-			break;
-		case ACL_OTHER:
-			xa_entry->type = SMB_ACL_OTHER;
-			break;
-		case ACL_MASK:
-			xa_entry->type = SMB_ACL_MASK;
-			break;
-		default:
-			pr_err("unknown type : 0x%x\n", pa_entry->e_tag);
-			goto out;
-		}
-
-		if (pa_entry->e_perm & ACL_READ)
-			xa_entry->perm |= SMB_ACL_READ;
-		if (pa_entry->e_perm & ACL_WRITE)
-			xa_entry->perm |= SMB_ACL_WRITE;
-		if (pa_entry->e_perm & ACL_EXECUTE)
-			xa_entry->perm |= SMB_ACL_EXECUTE;
-	}
-out:
-	posix_acl_release(posix_acls);
-	return smb_acl;
+	inode_unlock(d_inode(parent_path->dentry));
+	mnt_drop_write(parent_path->mnt);
+	path_put(path);
+	path_put(parent_path);
 }
 
-int ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,
-			   struct user_namespace *user_ns,
-			   struct dentry *dentry,
-			   struct smb_ntsd *pntsd, int len)
+#else
+/**
+ * ksmbd_vfs_kern_path() - lookup a file and get path info
+ * @name:	file path that is relative to share
+ * @flags:	lookup flags
+ * @path:	if lookup succeed, return path info
+ * @caseless:	caseless filename lookup
+ *
+ * Return:	0 on success, otherwise error
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+int ksmbd_vfs_kern_path(struct ksmbd_work *work, char *name,
+			unsigned int flags, struct path *path, bool caseless)
 {
-	int rc;
-	struct ndr sd_ndr = {0}, acl_ndr = {0};
-	struct xattr_ntacl acl = {0};
-	struct xattr_smb_acl *smb_acl, *def_smb_acl = NULL;
-	struct inode *inode = d_inode(dentry);
+	struct ksmbd_share_config *share_conf = work->tcon->share_conf;
+	int err;
 
-	acl.version = 4;
-	acl.hash_type = XATTR_SD_HASH_TYPE_SHA256;
-	acl.current_time = ksmbd_UnixTimeToNT(current_time(inode));
+	flags |= LOOKUP_BENEATH;
+	err = vfs_path_lookup(share_conf->vfs_path.dentry,
+			      share_conf->vfs_path.mnt,
+			      name,
+			      flags,
+			      path);
+	if (!err)
+		return 0;
 
-	memcpy(acl.desc, "posix_acl", 9);
-	acl.desc_len = 10;
+	if (caseless) {
+		char *filepath;
+		struct path parent;
+		size_t path_len, remain_len;
 
-	pntsd->osidoffset =
-		cpu_to_le32(le32_to_cpu(pntsd->osidoffset) + NDR_NTSD_OFFSETOF);
-	pntsd->gsidoffset =
-		cpu_to_le32(le32_to_cpu(pntsd->gsidoffset) + NDR_NTSD_OFFSETOF);
-	pntsd->dacloffset =
-		cpu_to_le32(le32_to_cpu(pntsd->dacloffset) + NDR_NTSD_OFFSETOF);
+		filepath = kstrdup(name, GFP_KERNEL);
+		if (!filepath)
+			return -ENOMEM;
 
-	acl.sd_buf = (char *)pntsd;
-	acl.sd_size = len;
+		path_len = strlen(filepath);
+		remain_len = path_len;
 
-	rc = ksmbd_gen_sd_hash(conn, acl.sd_buf, acl.sd_size, acl.hash);
-	if (rc) {
-		pr_err("failed to generate hash for ndr acl\n");
-		return rc;
-	}
+		parent = share_conf->vfs_path;
+		path_get(&parent);
 
-	smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
-						 ACL_TYPE_ACCESS);
-	if (S_ISDIR(inode->i_mode))
-		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
-							     ACL_TYPE_DEFAULT);
+		while (d_can_lookup(parent.dentry)) {
+			char *filename = filepath + path_len - remain_len;
+			char *next = strchrnul(filename, '/');
+			size_t filename_len = next - filename;
+			bool is_last = !next[0];
 
-	rc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode,
-				  smb_acl, def_smb_acl);
-	if (rc) {
-		pr_err("failed to encode ndr to posix acl\n");
-		goto out;
-	}
+			if (filename_len == 0)
+				break;
 
-	rc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset,
-			       acl.posix_acl_hash);
-	if (rc) {
-		pr_err("failed to generate hash for ndr acl\n");
-		goto out;
-	}
+			err = ksmbd_vfs_lookup_in_dir(&parent, filename,
+						      filename_len,
+						      work->conn->um);
+			path_put(&parent);
+			if (err)
+				goto out;
 
-	rc = ndr_encode_v4_ntacl(&sd_ndr, &acl);
-	if (rc) {
-		pr_err("failed to encode ndr to posix acl\n");
-		goto out;
-	}
+			next[0] = '\0';
 
-	rc = ksmbd_vfs_setxattr(user_ns, dentry,
-				XATTR_NAME_SD, sd_ndr.data,
-				sd_ndr.offset, 0);
-	if (rc < 0)
-		pr_err("Failed to store XATTR ntacl :%d\n", rc);
+			err = vfs_path_lookup(share_conf->vfs_path.dentry,
+					      share_conf->vfs_path.mnt,
+					      filepath,
+					      flags,
+					      &parent);
+			if (err)
+				goto out;
+			else if (is_last) {
+				*path = parent;
+				goto out;
+			}
 
-	kfree(sd_ndr.data);
+			next[0] = '/';
+			remain_len -= filename_len + 1;
+		}
+
+		path_put(&parent);
+		err = -EINVAL;
 out:
-	kfree(acl_ndr.data);
-	kfree(smb_acl);
-	kfree(def_smb_acl);
-	return rc;
+		kfree(filepath);
+	}
+	return err;
 }
-
-int ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,
-			   struct user_namespace *user_ns,
-			   struct dentry *dentry,
-			   struct smb_ntsd **pntsd)
+#else
+int ksmbd_vfs_kern_path(struct ksmbd_work *work, char *name,
+			unsigned int flags, struct path *path, bool caseless)
 {
-	int rc;
-	struct ndr n;
-	struct inode *inode = d_inode(dentry);
-	struct ndr acl_ndr = {0};
-	struct xattr_ntacl acl;
-	struct xattr_smb_acl *smb_acl = NULL, *def_smb_acl = NULL;
-	__u8 cmp_hash[XATTR_SD_HASH_SIZE] = {0};
-
-	rc = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_SD, &n.data);
-	if (rc <= 0)
-		return rc;
-
-	n.length = rc;
-	rc = ndr_decode_v4_ntacl(&n, &acl);
-	if (rc)
-		goto free_n_data;
+	char *abs_name;
+	int err;
 
-	smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
-						 ACL_TYPE_ACCESS);
-	if (S_ISDIR(inode->i_mode))
-		def_smb_acl = ksmbd_vfs_make_xattr_posix_acl(user_ns, inode,
-							     ACL_TYPE_DEFAULT);
+	abs_name = convert_to_unix_name(work->tcon->share_conf, name);
+	if (IS_ERR(abs_name))
+		return PTR_ERR(abs_name);
 
-	rc = ndr_encode_posix_acl(&acl_ndr, user_ns, inode, smb_acl,
-				  def_smb_acl);
-	if (rc) {
-		pr_err("failed to encode ndr to posix acl\n");
-		goto out_free;
+	err = kern_path(abs_name, flags, path);
+	if (!err) {
+		err = 0;
+		goto free_abs_name;
 	}
 
-	rc = ksmbd_gen_sd_hash(conn, acl_ndr.data, acl_ndr.offset, cmp_hash);
-	if (rc) {
-		pr_err("failed to generate hash for ndr acl\n");
-		goto out_free;
-	}
+	if (caseless) {
+		char *filepath;
+		struct path parent;
+		size_t path_len, remain_len;
 
-	if (memcmp(cmp_hash, acl.posix_acl_hash, XATTR_SD_HASH_SIZE)) {
-		pr_err("hash value diff\n");
-		rc = -EINVAL;
-		goto out_free;
-	}
+		filepath = kstrdup(abs_name, GFP_KERNEL);
+		if (!filepath) {
+			err = -ENOMEM;
+			goto free_abs_name;
+		}
 
-	*pntsd = acl.sd_buf;
-	if (acl.sd_size < sizeof(struct smb_ntsd)) {
-		pr_err("sd size is invalid\n");
-		goto out_free;
-	}
+		path_len = strlen(filepath);
+		remain_len = path_len - 1;
 
-	(*pntsd)->osidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->osidoffset) -
-					   NDR_NTSD_OFFSETOF);
-	(*pntsd)->gsidoffset = cpu_to_le32(le32_to_cpu((*pntsd)->gsidoffset) -
-					   NDR_NTSD_OFFSETOF);
-	(*pntsd)->dacloffset = cpu_to_le32(le32_to_cpu((*pntsd)->dacloffset) -
-					   NDR_NTSD_OFFSETOF);
+		err = kern_path("/", flags, &parent);
+		if (err)
+			goto out;
 
-	rc = acl.sd_size;
-out_free:
-	kfree(acl_ndr.data);
-	kfree(smb_acl);
-	kfree(def_smb_acl);
-	if (rc < 0) {
-		kfree(acl.sd_buf);
-		*pntsd = NULL;
-	}
+		while (d_can_lookup(parent.dentry)) {
+			char *filename = filepath + path_len - remain_len;
+			char *next = strchrnul(filename, '/');
+			size_t filename_len = next - filename;
+			bool is_last = !next[0];
 
-free_n_data:
-	kfree(n.data);
-	return rc;
-}
+			if (filename_len == 0)
+				break;
 
-int ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,
-				   struct dentry *dentry,
-				   struct xattr_dos_attrib *da)
-{
-	struct ndr n;
-	int err;
+			err = ksmbd_vfs_lookup_in_dir(&parent, filename,
+						      filename_len,
+						      work->conn->um);
+			if (err) {
+				path_put(&parent);
+				goto out;
+			}
 
-	err = ndr_encode_dos_attr(&n, da);
-	if (err)
-		return err;
+			path_put(&parent);
+			next[0] = '\0';
 
-	err = ksmbd_vfs_setxattr(user_ns, dentry, XATTR_NAME_DOS_ATTRIBUTE,
-				 (void *)n.data, n.offset, 0);
-	if (err)
-		ksmbd_debug(SMB, "failed to store dos attribute in xattr\n");
-	kfree(n.data);
+			err = kern_path(filepath, flags, &parent);
+			if (err)
+				goto out;
 
-	return err;
-}
+			if (is_last) {
+				path->mnt = parent.mnt;
+				path->dentry = parent.dentry;
+				goto out;
+			}
 
-int ksmbd_vfs_get_dos_attrib_xattr(struct user_namespace *user_ns,
-				   struct dentry *dentry,
-				   struct xattr_dos_attrib *da)
-{
-	struct ndr n;
-	int err;
+			next[0] = '/';
+			remain_len -= filename_len + 1;
+		}
 
-	err = ksmbd_vfs_getxattr(user_ns, dentry, XATTR_NAME_DOS_ATTRIBUTE,
-				 (char **)&n.data);
-	if (err > 0) {
-		n.length = err;
-		if (ndr_decode_dos_attr(&n, da))
-			err = -EINVAL;
-		kfree(n.data);
-	} else {
-		ksmbd_debug(SMB, "failed to load dos attribute in xattr\n");
+		path_put(&parent);
+		err = -EINVAL;
+out:
+		kfree(filepath);
 	}
 
+free_abs_name:
+	kfree(abs_name);
 	return err;
 }
+#endif
+#endif
 
 /**
  * ksmbd_vfs_init_kstat() - convert unix stat information to smb stat format
@@ -1637,7 +3031,7 @@ void *ksmbd_vfs_init_kstat(char **p, struct ksmbd_kstat *ksmbd_kstat)
 	time = ksmbd_UnixTimeToNT(kstat->ctime);
 	info->ChangeTime = cpu_to_le64(time);
 
-	if (ksmbd_kstat->file_attributes & FILE_ATTRIBUTE_DIRECTORY_LE) {
+	if (ksmbd_kstat->file_attributes & ATTR_DIRECTORY_LE) {
 		info->EndOfFile = 0;
 		info->AllocationSize = 0;
 	} else {
@@ -1649,15 +3043,35 @@ void *ksmbd_vfs_init_kstat(char **p, struct ksmbd_kstat *ksmbd_kstat)
 	return info;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
+				struct mnt_idmap *idmap,
+				struct dentry *dentry,
+				struct ksmbd_kstat *ksmbd_kstat)
+#else
 int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
 				struct user_namespace *user_ns,
 				struct dentry *dentry,
 				struct ksmbd_kstat *ksmbd_kstat)
+#endif
 {
 	u64 time;
 	int rc;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 6, 0)
+	generic_fillattr(idmap, STATX_BASIC_STATS, d_inode(dentry),
+			 ksmbd_kstat->kstat);
+#else
+	generic_fillattr(idmap, d_inode(dentry), ksmbd_kstat->kstat);
+#endif
+#else
 	generic_fillattr(user_ns, d_inode(dentry), ksmbd_kstat->kstat);
+#endif
+#else
+	generic_fillattr(d_inode(dentry), ksmbd_kstat->kstat);
+#endif
 
 	time = ksmbd_UnixTimeToNT(ksmbd_kstat->kstat->ctime);
 	ksmbd_kstat->create_time = time;
@@ -1667,15 +3081,19 @@ int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
 	 * or that acl is disable in server's filesystem and the config is yes.
 	 */
 	if (S_ISDIR(ksmbd_kstat->kstat->mode))
-		ksmbd_kstat->file_attributes = FILE_ATTRIBUTE_DIRECTORY_LE;
+		ksmbd_kstat->file_attributes = ATTR_DIRECTORY_LE;
 	else
-		ksmbd_kstat->file_attributes = FILE_ATTRIBUTE_ARCHIVE_LE;
+		ksmbd_kstat->file_attributes = ATTR_ARCHIVE_LE;
 
 	if (test_share_config_flag(work->tcon->share_conf,
 				   KSMBD_SHARE_FLAG_STORE_DOS_ATTRS)) {
 		struct xattr_dos_attrib da;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = ksmbd_vfs_get_dos_attrib_xattr(idmap, dentry, &da);
+#else
 		rc = ksmbd_vfs_get_dos_attrib_xattr(user_ns, dentry, &da);
+#endif
 		if (rc > 0) {
 			ksmbd_kstat->file_attributes = cpu_to_le32(da.attr);
 			ksmbd_kstat->create_time = da.create_time;
@@ -1687,7 +3105,11 @@ int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
 	return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ssize_t ksmbd_vfs_casexattr_len(struct mnt_idmap *idmap,
+#else
 ssize_t ksmbd_vfs_casexattr_len(struct user_namespace *user_ns,
+#endif
 				struct dentry *dentry, char *attr_name,
 				int attr_name_len)
 {
@@ -1704,7 +3126,11 @@ ssize_t ksmbd_vfs_casexattr_len(struct user_namespace *user_ns,
 		if (strncasecmp(attr_name, name, attr_name_len))
 			continue;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		value_len = ksmbd_vfs_xattr_len(idmap, dentry, name);
+#else
 		value_len = ksmbd_vfs_xattr_len(user_ns, dentry, name);
+#endif
 		break;
 	}
 
@@ -1793,10 +3219,18 @@ int ksmbd_vfs_copy_file_ranges(struct ksmbd_work *work,
 
 		ret = vfs_copy_file_range(src_fp->filp, src_off,
 					  dst_fp->filp, dst_off, len, 0);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 19, 0)
 		if (ret == -EOPNOTSUPP || ret == -EXDEV)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
 			ret = vfs_copy_file_range(src_fp->filp, src_off,
 						  dst_fp->filp, dst_off, len,
 						  COPY_FILE_SPLICE);
+#else
+			ret = generic_copy_file_range(src_fp->filp, src_off,
+						      dst_fp->filp, dst_off,
+						      len, 0);
+#endif
+#endif
 		if (ret < 0)
 			return ret;
 
@@ -1823,11 +3257,17 @@ void ksmbd_vfs_posix_lock_unblock(struct file_lock *flock)
 	locks_delete_block(flock);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_set_init_posix_acl(struct mnt_idmap *idmap,
+				 struct path *path)
+#else
 int ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,
-				 struct dentry *dentry)
+				 struct path *path)
+#endif
 {
 	struct posix_acl_state acl_state;
 	struct posix_acl *acls;
+	struct dentry *dentry = path->dentry;
 	struct inode *inode = d_inode(dentry);
 	int rc;
 
@@ -1857,35 +3297,71 @@ int ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,
 		return -ENOMEM;
 	}
 	posix_state_to_acl(&acl_state, acls->a_entries);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = set_posix_acl(idmap, dentry, ACL_TYPE_ACCESS, acls);
+#else
 	rc = set_posix_acl(user_ns, dentry, ACL_TYPE_ACCESS, acls);
+#endif
+#else
+	rc = set_posix_acl(user_ns, inode, ACL_TYPE_ACCESS, acls);
+#endif
+#else
+	rc = set_posix_acl(inode, ACL_TYPE_ACCESS, acls);
+#endif
 	if (rc < 0)
 		ksmbd_debug(SMB, "Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\n",
 			    rc);
 	else if (S_ISDIR(inode->i_mode)) {
 		posix_state_to_acl(&acl_state, acls->a_entries);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = set_posix_acl(idmap, dentry, ACL_TYPE_DEFAULT, acls);
+#else
 		rc = set_posix_acl(user_ns, dentry, ACL_TYPE_DEFAULT, acls);
+#endif
+#else
+		rc = set_posix_acl(user_ns, inode, ACL_TYPE_DEFAULT, acls);
+#endif
+#else
+		rc = set_posix_acl(inode, ACL_TYPE_DEFAULT, acls);
+#endif
 		if (rc < 0)
 			ksmbd_debug(SMB, "Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\n",
 				    rc);
 	}
+
 	free_acl_state(&acl_state);
 	posix_acl_release(acls);
 	return rc;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_inherit_posix_acl(struct mnt_idmap *idmap,
+				struct path *path, struct inode *parent_inode)
+#else
 int ksmbd_vfs_inherit_posix_acl(struct user_namespace *user_ns,
-				struct dentry *dentry, struct inode *parent_inode)
+				struct path *path, struct inode *parent_inode)
+#endif
 {
 	struct posix_acl *acls;
 	struct posix_acl_entry *pace;
+	struct dentry *dentry = path->dentry;
 	struct inode *inode = d_inode(dentry);
 	int rc, i;
 
 	if (!IS_ENABLED(CONFIG_FS_POSIX_ACL))
 		return -EOPNOTSUPP;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
 	acls = get_inode_acl(parent_inode, ACL_TYPE_DEFAULT);
-	if (!acls)
+#else
+	acls = get_acl(parent_inode, ACL_TYPE_DEFAULT);
+#endif
+	if (IS_ERR_OR_NULL(acls))
 		return -ENOENT;
 	pace = acls->a_entries;
 
@@ -1896,17 +3372,44 @@ int ksmbd_vfs_inherit_posix_acl(struct user_namespace *user_ns,
 		}
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	rc = set_posix_acl(idmap, dentry, ACL_TYPE_ACCESS, acls);
+#else
 	rc = set_posix_acl(user_ns, dentry, ACL_TYPE_ACCESS, acls);
+#endif
+#else
+	rc = set_posix_acl(user_ns, inode, ACL_TYPE_ACCESS, acls);
+#endif
+#else
+	rc = set_posix_acl(inode, ACL_TYPE_ACCESS, acls);
+#endif
 	if (rc < 0)
 		ksmbd_debug(SMB, "Set posix acl(ACL_TYPE_ACCESS) failed, rc : %d\n",
 			    rc);
 	if (S_ISDIR(inode->i_mode)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		rc = set_posix_acl(idmap, dentry, ACL_TYPE_DEFAULT,
+				   acls);
+#else
 		rc = set_posix_acl(user_ns, dentry, ACL_TYPE_DEFAULT,
 				   acls);
+#endif
+#else
+		rc = set_posix_acl(user_ns, inode, ACL_TYPE_DEFAULT,
+				   acls);
+#endif
+#else
+		rc = set_posix_acl(inode, ACL_TYPE_DEFAULT, acls);
+#endif
 		if (rc < 0)
 			ksmbd_debug(SMB, "Set posix acl(ACL_TYPE_DEFAULT) failed, rc : %d\n",
 				    rc);
 	}
+
 	posix_acl_release(acls);
 	return rc;
 }
diff --git a/fs/ksmbd/vfs.h b/fs/ksmbd/vfs.h
index 0d73d735cc39..eb5b291af7b4 100644
--- a/fs/ksmbd/vfs.h
+++ b/fs/ksmbd/vfs.h
@@ -26,9 +26,48 @@ enum {
 };
 
 /* CreateOptions */
+/* Flag is set, it must not be a file , valid for directory only */
+#define FILE_DIRECTORY_FILE_LE			cpu_to_le32(0x00000001)
+#define FILE_WRITE_THROUGH_LE			cpu_to_le32(0x00000002)
+#define FILE_SEQUENTIAL_ONLY_LE			cpu_to_le32(0x00000004)
+
+/* Should not buffer on server*/
+#define FILE_NO_INTERMEDIATE_BUFFERING_LE	cpu_to_le32(0x00000008)
+/* MBZ */
+#define FILE_SYNCHRONOUS_IO_ALERT_LE		cpu_to_le32(0x00000010)
+/* MBZ */
+#define FILE_SYNCHRONOUS_IO_NONALERT_LE		cpu_to_le32(0x00000020)
+
+/* Flaf must not be set for directory */
+#define FILE_NON_DIRECTORY_FILE_LE		cpu_to_le32(0x00000040)
+
+/* Should be zero */
 #define CREATE_TREE_CONNECTION			cpu_to_le32(0x00000080)
+#define FILE_COMPLETE_IF_OPLOCKED_LE		cpu_to_le32(0x00000100)
+#define FILE_NO_EA_KNOWLEDGE_LE			cpu_to_le32(0x00000200)
+#define FILE_OPEN_REMOTE_INSTANCE		cpu_to_le32(0x00000400)
+
+/**
+ * Doc says this is obsolete "open for recovery" flag should be zero
+ * in any case.
+ */
+#define CREATE_OPEN_FOR_RECOVERY		cpu_to_le32(0x00000400)
+#define FILE_RANDOM_ACCESS_LE			cpu_to_le32(0x00000800)
+#define FILE_DELETE_ON_CLOSE_LE			cpu_to_le32(0x00001000)
+#define FILE_OPEN_BY_FILE_ID_LE			cpu_to_le32(0x00002000)
+#define FILE_OPEN_FOR_BACKUP_INTENT_LE		cpu_to_le32(0x00004000)
+#define FILE_NO_COMPRESSION_LE			cpu_to_le32(0x00008000)
+
+/* Should be zero*/
+#define FILE_OPEN_REQUIRING_OPLOCK		cpu_to_le32(0x00010000)
+#define FILE_DISALLOW_EXCLUSIVE			cpu_to_le32(0x00020000)
 #define FILE_RESERVE_OPFILTER_LE		cpu_to_le32(0x00100000)
+#define FILE_OPEN_REPARSE_POINT_LE		cpu_to_le32(0x00200000)
+#define FILE_OPEN_NO_RECALL_LE			cpu_to_le32(0x00400000)
 
+/* Should be zero */
+#define FILE_OPEN_FOR_FREE_SPACE_QUERY_LE	cpu_to_le32(0x00800000)
+#define CREATE_OPTIONS_MASK			cpu_to_le32(0x00FFFFFF)
 #define CREATE_OPTION_READONLY			0x10000000
 /* system. NB not sent over wire */
 #define CREATE_OPTION_SPECIAL			0x20000000
@@ -39,6 +78,9 @@ struct ksmbd_conn;
 
 struct ksmbd_dir_info {
 	const char	*name;
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	char		*smb1_name;
+#endif
 	char		*wptr;
 	char		*rptr;
 	int		name_len;
@@ -71,25 +113,74 @@ struct ksmbd_kstat {
 	__le32			file_attributes;
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 12, 0)
+static inline struct user_namespace *mnt_user_ns(const struct vfsmount *mnt)
+{
+	return &init_user_ns;
+}
+
+static inline struct user_namespace *file_mnt_user_ns(struct file *file)
+{
+	return &init_user_ns;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+int ksmbd_vfs_lock_parent(struct dentry *parent, struct dentry *child);
+#else
+int ksmbd_vfs_lock_parent(struct mnt_idmap *idmap, struct dentry *parent,
+			  struct dentry *child);
+int ksmbd_vfs_may_delete(struct mnt_idmap *idmap, struct dentry *dentry);
+#endif
+void ksmbd_vfs_query_maximal_access(struct mnt_idmap *idmap,
+				   struct dentry *dentry, __le32 *daccess);
+#else
 int ksmbd_vfs_lock_parent(struct user_namespace *user_ns, struct dentry *parent,
 			  struct dentry *child);
 int ksmbd_vfs_may_delete(struct user_namespace *user_ns, struct dentry *dentry);
 int ksmbd_vfs_query_maximal_access(struct user_namespace *user_ns,
 				   struct dentry *dentry, __le32 *daccess);
+#endif
 int ksmbd_vfs_create(struct ksmbd_work *work, const char *name, umode_t mode);
 int ksmbd_vfs_mkdir(struct ksmbd_work *work, const char *name, umode_t mode);
-int ksmbd_vfs_read(struct ksmbd_work *work, struct ksmbd_file *fp,
-		   size_t count, loff_t *pos);
+int ksmbd_vfs_read(struct ksmbd_work *work, struct ksmbd_file *fp, size_t count,
+		   loff_t *pos, char *rbuf);
 int ksmbd_vfs_write(struct ksmbd_work *work, struct ksmbd_file *fp,
 		    char *buf, size_t count, loff_t *pos, bool sync,
 		    ssize_t *written);
 int ksmbd_vfs_fsync(struct ksmbd_work *work, u64 fid, u64 p_id);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+int ksmbd_vfs_remove_file(struct ksmbd_work *work, const struct path *path);
+#else
 int ksmbd_vfs_remove_file(struct ksmbd_work *work, char *name);
+#endif
 int ksmbd_vfs_link(struct ksmbd_work *work,
 		   const char *oldname, const char *newname);
 int ksmbd_vfs_getattr(const struct path *path, struct kstat *stat);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+int ksmbd_vfs_setattr(struct ksmbd_work *work, const char *name,
+		      u64 fid, struct iattr *attrs);
+int ksmbd_vfs_symlink(struct ksmbd_work *work,
+		      const char *name, const char *symname);
+int ksmbd_vfs_readlink(struct path *path, char *buf, int lenp);
+int ksmbd_vfs_readdir_name(struct ksmbd_work *work,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+			   struct mnt_idmap *idmap,
+#else
+			   struct user_namespace *user_ns,
+#endif
+			   struct ksmbd_kstat *ksmbd_kstat,
+			   const char *de_name, int de_name_len,
+			   const char *dir_path);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+int ksmbd_vfs_rename(struct ksmbd_work *work, const struct path *old_path,
+		     char *newname, int flags);
+#else
 int ksmbd_vfs_fp_rename(struct ksmbd_work *work, struct ksmbd_file *fp,
 			char *newname);
+#endif
 int ksmbd_vfs_truncate(struct ksmbd_work *work,
 		       struct ksmbd_file *fp, loff_t size);
 struct srv_copychunk;
@@ -101,24 +192,59 @@ int ksmbd_vfs_copy_file_ranges(struct ksmbd_work *work,
 			       unsigned int *chunk_count_written,
 			       unsigned int *chunk_size_written,
 			       loff_t  *total_size_written);
+struct ksmbd_file *ksmbd_vfs_dentry_open(struct ksmbd_work *work,
+					 const struct path *path, int flags,
+					 __le32 option, int fexist);
 ssize_t ksmbd_vfs_listxattr(struct dentry *dentry, char **list);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ssize_t ksmbd_vfs_getxattr(struct mnt_idmap *idmap,
+#else
 ssize_t ksmbd_vfs_getxattr(struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry,
 			   char *xattr_name,
 			   char **xattr_buf);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+ssize_t ksmbd_vfs_casexattr_len(struct mnt_idmap *idmap,
+#else
 ssize_t ksmbd_vfs_casexattr_len(struct user_namespace *user_ns,
+#endif
 				struct dentry *dentry, char *attr_name,
 				int attr_name_len);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_setxattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_setxattr(struct user_namespace *user_ns,
-		       struct dentry *dentry, const char *attr_name,
-		       void *attr_value, size_t attr_size, int flags);
+#endif
+		       const struct path *path, const char *attr_name,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+		       void *attr_value, size_t attr_size, int flags,
+		       bool get_write);
+#else
+		       const void *attr_value, size_t attr_size, int flags,
+		       bool get_write);
+#endif
+int ksmbd_vfs_fsetxattr(struct ksmbd_work *work, const char *filename,
+			const char *attr_name, const void *attr_value,
+			size_t attr_size, int flags);
 int ksmbd_vfs_xattr_stream_name(char *stream_name, char **xattr_stream_name,
 				size_t *xattr_stream_name_size, int s_type);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_xattr(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_remove_xattr(struct user_namespace *user_ns,
-			   struct dentry *dentry, char *attr_name);
+#endif
+			   const struct path *path, char *attr_name);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+int ksmbd_vfs_kern_path_locked(struct ksmbd_work *work, char *name,
+			       unsigned int flags, struct path *parent_path,
+			       struct path *path, bool caseless);
+void ksmbd_vfs_kern_path_unlock(struct path *parent_path, struct path *path);
+#else
 int ksmbd_vfs_kern_path(struct ksmbd_work *work,
 			char *name, unsigned int flags, struct path *path,
 			bool caseless);
+#endif
 struct dentry *ksmbd_vfs_kern_path_create(struct ksmbd_work *work,
 					  const char *name,
 					  unsigned int flags,
@@ -131,37 +257,90 @@ struct file_allocated_range_buffer;
 int ksmbd_vfs_fqar_lseek(struct ksmbd_file *fp, loff_t start, loff_t length,
 			 struct file_allocated_range_buffer *ranges,
 			 unsigned int in_count, unsigned int *out_count);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+int ksmbd_vfs_unlink(struct file *filp);
+#else
+int ksmbd_vfs_unlink(struct mnt_idmap *idmap, struct dentry *dir,
+		     struct dentry *dentry);
+#endif
+#else
 int ksmbd_vfs_unlink(struct user_namespace *user_ns,
 		     struct dentry *dir, struct dentry *dentry);
+#endif
 void *ksmbd_vfs_init_kstat(char **p, struct ksmbd_kstat *ksmbd_kstat);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
+				struct mnt_idmap *idmap,
+				struct dentry *dentry,
+				struct ksmbd_kstat *ksmbd_kstat);
+#else
 int ksmbd_vfs_fill_dentry_attrs(struct ksmbd_work *work,
 				struct user_namespace *user_ns,
 				struct dentry *dentry,
 				struct ksmbd_kstat *ksmbd_kstat);
+#endif
 void ksmbd_vfs_posix_lock_wait(struct file_lock *flock);
 int ksmbd_vfs_posix_lock_wait_timeout(struct file_lock *flock, long timeout);
 void ksmbd_vfs_posix_lock_unblock(struct file_lock *flock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_acl_xattrs(struct mnt_idmap *idmap,
+				const struct path *path);
+#else
 int ksmbd_vfs_remove_acl_xattrs(struct user_namespace *user_ns,
-				struct dentry *dentry);
+				const struct path *path);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_remove_sd_xattrs(struct mnt_idmap *idmap,
+#else
 int ksmbd_vfs_remove_sd_xattrs(struct user_namespace *user_ns,
-			       struct dentry *dentry);
+#endif
+			       const struct path *path);
 int ksmbd_vfs_set_sd_xattr(struct ksmbd_conn *conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			   struct mnt_idmap *idmap,
+#else
 			   struct user_namespace *user_ns,
-			   struct dentry *dentry,
-			   struct smb_ntsd *pntsd, int len);
+#endif
+			   const struct path *path,
+			   struct smb_ntsd *pntsd, int len,
+			   bool get_write);
 int ksmbd_vfs_get_sd_xattr(struct ksmbd_conn *conn,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			   struct mnt_idmap *idmap,
+#else
 			   struct user_namespace *user_ns,
+#endif
 			   struct dentry *dentry,
 			   struct smb_ntsd **pntsd);
-int ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_set_dos_attrib_xattr(struct mnt_idmap *idmap,
+				   const struct path *path,
+				   struct xattr_dos_attrib *da,
+				   bool get_write);
+int ksmbd_vfs_get_dos_attrib_xattr(struct mnt_idmap *idmap,
 				   struct dentry *dentry,
 				   struct xattr_dos_attrib *da);
+#else
+int ksmbd_vfs_set_dos_attrib_xattr(struct user_namespace *user_ns,
+				   const struct path *path,
+				   struct xattr_dos_attrib *da,
+				   bool get_write);
 int ksmbd_vfs_get_dos_attrib_xattr(struct user_namespace *user_ns,
 				   struct dentry *dentry,
 				   struct xattr_dos_attrib *da);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+int ksmbd_vfs_set_init_posix_acl(struct mnt_idmap *idmap,
+				 struct path *path);
+int ksmbd_vfs_inherit_posix_acl(struct mnt_idmap *idmap,
+				struct path *path,
+				struct inode *parent_inode);
+#else
 int ksmbd_vfs_set_init_posix_acl(struct user_namespace *user_ns,
-				 struct dentry *dentry);
+				 struct path *path);
 int ksmbd_vfs_inherit_posix_acl(struct user_namespace *user_ns,
-				struct dentry *dentry,
+				struct path *path,
 				struct inode *parent_inode);
+#endif
 #endif /* __KSMBD_VFS_H__ */
diff --git a/fs/ksmbd/vfs_cache.c b/fs/ksmbd/vfs_cache.c
index 0ae5dd0829e9..59eb1efa2d52 100644
--- a/fs/ksmbd/vfs_cache.c
+++ b/fs/ksmbd/vfs_cache.c
@@ -5,6 +5,10 @@
  */
 
 #include <linux/fs.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#include <linux/filelock.h>
+#endif
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 
@@ -65,14 +69,14 @@ static unsigned long inode_hash(struct super_block *sb, unsigned long hashval)
 	return tmp & inode_hash_mask;
 }
 
-static struct ksmbd_inode *__ksmbd_inode_lookup(struct inode *inode)
+static struct ksmbd_inode *__ksmbd_inode_lookup(struct dentry *de)
 {
 	struct hlist_head *head = inode_hashtable +
-		inode_hash(inode->i_sb, inode->i_ino);
+		inode_hash(d_inode(de)->i_sb, (unsigned long)de);
 	struct ksmbd_inode *ci = NULL, *ret_ci = NULL;
 
 	hlist_for_each_entry(ci, head, m_hash) {
-		if (ci->m_inode == inode) {
+		if (ci->m_de == de) {
 			if (atomic_inc_not_zero(&ci->m_count))
 				ret_ci = ci;
 			break;
@@ -83,29 +87,30 @@ static struct ksmbd_inode *__ksmbd_inode_lookup(struct inode *inode)
 
 static struct ksmbd_inode *ksmbd_inode_lookup(struct ksmbd_file *fp)
 {
-	return __ksmbd_inode_lookup(file_inode(fp->filp));
+	return __ksmbd_inode_lookup(fp->filp->f_path.dentry);
 }
 
-static struct ksmbd_inode *ksmbd_inode_lookup_by_vfsinode(struct inode *inode)
+struct ksmbd_inode *ksmbd_inode_lookup_lock(struct dentry *d)
 {
 	struct ksmbd_inode *ci;
 
 	read_lock(&inode_hash_lock);
-	ci = __ksmbd_inode_lookup(inode);
+	ci = __ksmbd_inode_lookup(d);
 	read_unlock(&inode_hash_lock);
+
 	return ci;
 }
 
-int ksmbd_query_inode_status(struct inode *inode)
+int ksmbd_query_inode_status(struct dentry *dentry)
 {
 	struct ksmbd_inode *ci;
 	int ret = KSMBD_INODE_STATUS_UNKNOWN;
 
 	read_lock(&inode_hash_lock);
-	ci = __ksmbd_inode_lookup(inode);
+	ci = __ksmbd_inode_lookup(dentry);
 	if (ci) {
 		ret = KSMBD_INODE_STATUS_OK;
-		if (ci->m_flags & S_DEL_PENDING)
+		if (ci->m_flags & (S_DEL_PENDING | S_DEL_ON_CLS))
 			ret = KSMBD_INODE_STATUS_PENDING_DELETE;
 		atomic_dec(&ci->m_count);
 	}
@@ -115,7 +120,7 @@ int ksmbd_query_inode_status(struct inode *inode)
 
 bool ksmbd_inode_pending_delete(struct ksmbd_file *fp)
 {
-	return (fp->f_ci->m_flags & S_DEL_PENDING);
+	return (fp->f_ci->m_flags & (S_DEL_PENDING | S_DEL_ON_CLS));
 }
 
 void ksmbd_set_inode_pending_delete(struct ksmbd_file *fp)
@@ -142,7 +147,7 @@ void ksmbd_fd_set_delete_on_close(struct ksmbd_file *fp,
 static void ksmbd_inode_hash(struct ksmbd_inode *ci)
 {
 	struct hlist_head *b = inode_hashtable +
-		inode_hash(ci->m_inode->i_sb, ci->m_inode->i_ino);
+		inode_hash(d_inode(ci->m_de)->i_sb, (unsigned long)ci->m_de);
 
 	hlist_add_head(&ci->m_hash, b);
 }
@@ -156,7 +161,6 @@ static void ksmbd_inode_unhash(struct ksmbd_inode *ci)
 
 static int ksmbd_inode_init(struct ksmbd_inode *ci, struct ksmbd_file *fp)
 {
-	ci->m_inode = file_inode(fp->filp);
 	atomic_set(&ci->m_count, 1);
 	atomic_set(&ci->op_count, 0);
 	atomic_set(&ci->sop_count, 0);
@@ -165,6 +169,7 @@ static int ksmbd_inode_init(struct ksmbd_inode *ci, struct ksmbd_file *fp)
 	INIT_LIST_HEAD(&ci->m_fp_list);
 	INIT_LIST_HEAD(&ci->m_op_list);
 	rwlock_init(&ci->m_lock);
+	ci->m_de = fp->filp->f_path.dentry;
 	return 0;
 }
 
@@ -208,7 +213,7 @@ static void ksmbd_inode_free(struct ksmbd_inode *ci)
 	kfree(ci);
 }
 
-static void ksmbd_inode_put(struct ksmbd_inode *ci)
+void ksmbd_inode_put(struct ksmbd_inode *ci)
 {
 	if (atomic_dec_and_test(&ci->m_count))
 		ksmbd_inode_free(ci);
@@ -243,7 +248,9 @@ void ksmbd_release_inode_hash(void)
 
 static void __ksmbd_inode_close(struct ksmbd_file *fp)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
 	struct dentry *dir, *dentry;
+#endif
 	struct ksmbd_inode *ci = fp->f_ci;
 	int err;
 	struct file *filp;
@@ -251,8 +258,12 @@ static void __ksmbd_inode_close(struct ksmbd_file *fp)
 	filp = fp->filp;
 	if (ksmbd_stream_fd(fp) && (ci->m_flags & S_DEL_ON_CLS_STREAM)) {
 		ci->m_flags &= ~S_DEL_ON_CLS_STREAM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		err = ksmbd_vfs_remove_xattr(file_mnt_idmap(filp),
+#else
 		err = ksmbd_vfs_remove_xattr(file_mnt_user_ns(filp),
-					     filp->f_path.dentry,
+#endif
+					     &filp->f_path,
 					     fp->stream.name);
 		if (err)
 			pr_err("remove xattr failed : %s\n",
@@ -262,11 +273,21 @@ static void __ksmbd_inode_close(struct ksmbd_file *fp)
 	if (atomic_dec_and_test(&ci->m_count)) {
 		write_lock(&ci->m_lock);
 		if (ci->m_flags & (S_DEL_ON_CLS | S_DEL_PENDING)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 4, 0)
 			dentry = filp->f_path.dentry;
 			dir = dentry->d_parent;
+#endif
 			ci->m_flags &= ~(S_DEL_ON_CLS | S_DEL_PENDING);
 			write_unlock(&ci->m_lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 4, 0)
+			ksmbd_vfs_unlink(filp);
+#else
+			ksmbd_vfs_unlink(file_mnt_idmap(filp), dir, dentry);
+#endif
+#else
 			ksmbd_vfs_unlink(file_mnt_user_ns(filp), dir, dentry);
+#endif
 			write_lock(&ci->m_lock);
 		}
 		write_unlock(&ci->m_lock);
@@ -327,7 +348,9 @@ static void __ksmbd_close_fd(struct ksmbd_file_table *ft, struct ksmbd_file *fp)
 		locks_free_lock(smb_lock->fl);
 		kfree(smb_lock);
 	}
-
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	kfree(fp->filename);
+#endif
 	if (ksmbd_stream_fd(fp))
 		kfree(fp->stream.name);
 	kmem_cache_free(filp_cache, fp);
@@ -335,6 +358,9 @@ static void __ksmbd_close_fd(struct ksmbd_file_table *ft, struct ksmbd_file *fp)
 
 static struct ksmbd_file *ksmbd_fp_get(struct ksmbd_file *fp)
 {
+	if (fp->f_state != FP_INITED)
+		return NULL;
+
 	if (!atomic_inc_not_zero(&fp->refcount))
 		return NULL;
 	return fp;
@@ -384,15 +410,20 @@ int ksmbd_close_fd(struct ksmbd_work *work, u64 id)
 		return 0;
 
 	ft = &work->sess->file_table;
-	read_lock(&ft->lock);
+	write_lock(&ft->lock);
 	fp = idr_find(ft->idr, id);
 	if (fp) {
 		set_close_state_blocked_works(fp);
 
-		if (!atomic_dec_and_test(&fp->refcount))
+		if (fp->f_state != FP_INITED)
 			fp = NULL;
+		else {
+			fp->f_state = FP_CLOSED;
+			if (!atomic_dec_and_test(&fp->refcount))
+				fp = NULL;
+		}
 	}
-	read_unlock(&ft->lock);
+	write_unlock(&ft->lock);
 
 	if (!fp)
 		return -EINVAL;
@@ -482,12 +513,45 @@ struct ksmbd_file *ksmbd_lookup_fd_cguid(char *cguid)
 	return fp;
 }
 
-struct ksmbd_file *ksmbd_lookup_fd_inode(struct inode *inode)
+#ifdef CONFIG_SMB_INSECURE_SERVER
+struct ksmbd_file *ksmbd_lookup_fd_filename(struct ksmbd_work *work, char *filename)
+{
+	struct ksmbd_file	*fp = NULL;
+	unsigned int		id;
+	char			*pathname;
+
+	pathname = kmalloc(PATH_MAX, GFP_KERNEL);
+	if (!pathname)
+		return NULL;
+
+	read_lock(&work->sess->file_table.lock);
+	idr_for_each_entry(work->sess->file_table.idr, fp, id) {
+		char *path = d_path(&fp->filp->f_path, pathname, PATH_MAX);
+
+		if (IS_ERR(path))
+			break;
+
+		if (!strcmp(path, filename)) {
+			fp = ksmbd_fp_get(fp);
+			break;
+		}
+	}
+	read_unlock(&work->sess->file_table.lock);
+
+	kfree(pathname);
+	return fp;
+}
+#endif
+
+struct ksmbd_file *ksmbd_lookup_fd_inode(struct dentry *dentry)
 {
 	struct ksmbd_file	*lfp;
 	struct ksmbd_inode	*ci;
+	struct inode		*inode = d_inode(dentry);
 
-	ci = ksmbd_inode_lookup_by_vfsinode(inode);
+	read_lock(&inode_hash_lock);
+	ci = __ksmbd_inode_lookup(dentry);
+	read_unlock(&inode_hash_lock);
 	if (!ci)
 		return NULL;
 
@@ -529,7 +593,13 @@ static int __open_id(struct ksmbd_file_table *ft, struct ksmbd_file *fp,
 
 	idr_preload(GFP_KERNEL);
 	write_lock(&ft->lock);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	ret = idr_alloc_cyclic(ft->idr, fp, 0,
+			       IS_SMB2(fp->conn) ? INT_MAX - 1 : 0xFFFF,
+			       GFP_NOWAIT);
+#else
 	ret = idr_alloc_cyclic(ft->idr, fp, 0, INT_MAX - 1, GFP_NOWAIT);
+#endif
 	if (ret >= 0) {
 		id = ret;
 		ret = 0;
@@ -572,6 +642,7 @@ struct ksmbd_file *ksmbd_open_fd(struct ksmbd_work *work, struct file *filp)
 	fp->tcon		= work->tcon;
 	fp->volatile_id		= KSMBD_NO_FID;
 	fp->persistent_id	= KSMBD_NO_FID;
+	fp->f_state		= FP_NEW;
 	fp->f_ci		= ksmbd_inode_get(fp);
 
 	if (!fp->f_ci) {
@@ -593,6 +664,17 @@ struct ksmbd_file *ksmbd_open_fd(struct ksmbd_work *work, struct file *filp)
 	return ERR_PTR(ret);
 }
 
+void ksmbd_update_fstate(struct ksmbd_file_table *ft, struct ksmbd_file *fp,
+			 unsigned int state)
+{
+	if (!fp)
+		return;
+
+	write_lock(&ft->lock);
+	fp->f_state = state;
+	write_unlock(&ft->lock);
+}
+
 static int
 __close_file_table_ids(struct ksmbd_file_table *ft,
 		       struct ksmbd_tree_connect *tcon,
@@ -665,6 +747,22 @@ void ksmbd_free_global_file_table(void)
 	ksmbd_destroy_file_table(&global_ft);
 }
 
+int ksmbd_file_table_flush(struct ksmbd_work *work)
+{
+	struct ksmbd_file	*fp = NULL;
+	unsigned int		id;
+	int			ret;
+
+	read_lock(&work->sess->file_table.lock);
+	idr_for_each_entry(work->sess->file_table.idr, fp, id) {
+		ret = ksmbd_vfs_fsync(work, fp->volatile_id, KSMBD_NO_FID);
+		if (ret)
+			break;
+	}
+	read_unlock(&work->sess->file_table.lock);
+	return ret;
+}
+
 int ksmbd_init_file_table(struct ksmbd_file_table *ft)
 {
 	ft->idr = kzalloc(sizeof(struct idr), GFP_KERNEL);
diff --git a/fs/ksmbd/vfs_cache.h b/fs/ksmbd/vfs_cache.h
index fcb13413fa8d..de8c43eb1332 100644
--- a/fs/ksmbd/vfs_cache.h
+++ b/fs/ksmbd/vfs_cache.h
@@ -51,7 +51,7 @@ struct ksmbd_inode {
 	atomic_t			op_count;
 	/* opinfo count for streams */
 	atomic_t			sop_count;
-	struct inode			*m_inode;
+	struct dentry			*m_de;
 	unsigned int			m_flags;
 	struct hlist_node		m_hash;
 	struct list_head		m_fp_list;
@@ -60,6 +60,12 @@ struct ksmbd_inode {
 	__le32				m_fattr;
 };
 
+enum {
+	FP_NEW = 0,
+	FP_INITED,
+	FP_CLOSED
+};
+
 struct ksmbd_file {
 	struct file			*filp;
 	u64				persistent_id;
@@ -95,9 +101,25 @@ struct ksmbd_file {
 
 	int				durable_timeout;
 
+#ifdef CONFIG_SMB_INSECURE_SERVER
+	/* for SMB1 */
+	int				pid;
+
+	/* conflict lock fail count for SMB1 */
+	unsigned int			cflock_cnt;
+	/* last lock failure start offset for SMB1 */
+	unsigned long long		llock_fstart;
+
+	int				dirent_offset;
+
+	/* for find_first/find_next */
+	char				*filename;
+#endif
 	/* if ls is happening on directory, below is valid*/
 	struct ksmbd_readdir_data	readdir_data;
 	int				dot_dotdot[2];
+	unsigned int			f_state;
+	bool				reserve_lease_break;
 };
 
 static inline void set_ctx_actor(struct dir_context *ctx,
@@ -131,9 +153,14 @@ struct ksmbd_file *ksmbd_lookup_foreign_fd(struct ksmbd_work *work, u64 id);
 struct ksmbd_file *ksmbd_lookup_fd_slow(struct ksmbd_work *work, u64 id,
 					u64 pid);
 void ksmbd_fd_put(struct ksmbd_work *work, struct ksmbd_file *fp);
+struct ksmbd_inode *ksmbd_inode_lookup_lock(struct dentry *d);
+void ksmbd_inode_put(struct ksmbd_inode *ci);
 struct ksmbd_file *ksmbd_lookup_durable_fd(unsigned long long id);
 struct ksmbd_file *ksmbd_lookup_fd_cguid(char *cguid);
-struct ksmbd_file *ksmbd_lookup_fd_inode(struct inode *inode);
+#ifdef CONFIG_SMB_INSECURE_SERVER
+struct ksmbd_file *ksmbd_lookup_fd_filename(struct ksmbd_work *work, char *filename);
+#endif
+struct ksmbd_file *ksmbd_lookup_fd_inode(struct dentry *dentry);
 unsigned int ksmbd_open_durable_fd(struct ksmbd_file *fp);
 struct ksmbd_file *ksmbd_open_fd(struct ksmbd_work *work, struct file *filp);
 void ksmbd_close_tree_conn_fds(struct ksmbd_work *work);
@@ -141,7 +168,10 @@ void ksmbd_close_session_fds(struct ksmbd_work *work);
 int ksmbd_close_inode_fds(struct ksmbd_work *work, struct inode *inode);
 int ksmbd_init_global_file_table(void);
 void ksmbd_free_global_file_table(void);
+int ksmbd_file_table_flush(struct ksmbd_work *work);
 void ksmbd_set_fd_limit(unsigned long limit);
+void ksmbd_update_fstate(struct ksmbd_file_table *ft, struct ksmbd_file *fp,
+			 unsigned int state);
 
 /*
  * INODE hash
@@ -155,7 +185,7 @@ enum KSMBD_INODE_STATUS {
 	KSMBD_INODE_STATUS_PENDING_DELETE,
 };
 
-int ksmbd_query_inode_status(struct inode *inode);
+int ksmbd_query_inode_status(struct dentry *dentry);
 bool ksmbd_inode_pending_delete(struct ksmbd_file *fp);
 void ksmbd_set_inode_pending_delete(struct ksmbd_file *fp);
 void ksmbd_clear_inode_pending_delete(struct ksmbd_file *fp);
diff --git a/fs/ksmbd/xattr.h b/fs/ksmbd/xattr.h
index 16499ca5c82d..8857c01093d9 100644
--- a/fs/ksmbd/xattr.h
+++ b/fs/ksmbd/xattr.h
@@ -76,7 +76,7 @@ struct xattr_acl_entry {
 struct xattr_smb_acl {
 	int count;
 	int next;
-	struct xattr_acl_entry entries[];
+	struct xattr_acl_entry entries[0];
 };
 
 /* 64bytes hash in xattr_ntacl is computed with sha256 */
-- 
2.39.2

